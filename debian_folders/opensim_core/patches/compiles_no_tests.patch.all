diff --git a/Applications/Analyze/test/testInducedAccelerations.cpp b/Applications/Analyze/test/testInducedAccelerations.cpp
index 531fa1229..b78cd8fdf 100644
--- a/Applications/Analyze/test/testInducedAccelerations.cpp
+++ b/Applications/Analyze/test/testInducedAccelerations.cpp
@@ -31,13 +31,12 @@
 #include <OpenSim/Analyses/InducedAccelerationsSolver.h>
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 // Prototypes
 void testDoublePendulumWithSolver();
 void testDoublePendulum();
-Vector calcDoublePendulumUdot(const Model &model, State &s, double Torq1, double Torq2, bool gravity, bool velocity);
+SimTK::Vector calcDoublePendulumUdot(const Model &model, SimTK::State &s, double Torq1, double Torq2, bool gravity, bool velocity);
 
 int main()
 {
@@ -91,29 +90,29 @@ void testDoublePendulumWithSolver()
     controller->prescribeControlForActuator("Torq2", Constant(torq2));
     pendulum.addController(controller);
 
-    State &s = pendulum.initSystem();
+    SimTK::State &s = pendulum.initSystem();
 
     InducedAccelerationsSolver iaaSolver(pendulum);
 
     for(int i=0; i<nt; ++i){
         s.updTime() = time[i];
-        Vector &q = s.updQ();
-        Vector &u = s.updU();
+        SimTK::Vector &q = s.updQ();
+        SimTK::Vector &u = s.updU();
         q[0]= (states[0])[i];
         q[1]= (states[1])[i];
         u[0]= (states[2])[i];
         u[1]= (states[3])[i];
 
         // Compute total acceleration due to all force contributors
-        Vector udot_tot = iaaSolver.solve(s, "total");
-        Vector udot = calcDoublePendulumUdot(pendulum, s, torq1, torq2, true, true);
+        SimTK::Vector udot_tot = iaaSolver.solve(s, "total");
+        SimTK::Vector udot = calcDoublePendulumUdot(pendulum, s, torq1, torq2, true, true);
         ASSERT_EQUAL(udot[0], udot_tot[0], 1e-5, __FILE__, __LINE__,
             "Total Induced Accelerations for double pendulum q1 FAILED");
         ASSERT_EQUAL(udot[1], udot_tot[1], 1e-5, __FILE__, __LINE__,
             "Total Induced Accelerations for double pendulum q2 FAILED");
 
         // Compute velocity contribution
-        Vector udot_vel = iaaSolver.solve(s, "velocity");
+        SimTK::Vector udot_vel = iaaSolver.solve(s, "velocity");
         // velocity first, since other contributors set u's to zero and the state is not restored until next iteration.
          udot = calcDoublePendulumUdot(pendulum, s, 0, 0, false, true);
 
@@ -138,24 +137,24 @@ void testDoublePendulumWithSolver()
         ASSERT_EQUAL(udot[0]+udot[1], rod2Acc[0][2], 1e-5, __FILE__, __LINE__, "Induced rod2 Acceleration due to velocity FAILED");
 
         // Compute gravity contribution
-        Vector udot_grav = iaaSolver.solve(s, "gravity");
+        SimTK::Vector udot_grav = iaaSolver.solve(s, "gravity");
         udot = calcDoublePendulumUdot(pendulum, s, 0, 0, true, false);
 
         ASSERT_EQUAL(udot[0], udot_grav[0], 1e-5, __FILE__, __LINE__, "Induced Accelerations of gravity for double pendulum q1 FAILED");
         ASSERT_EQUAL(udot[1], udot_grav[1], 1e-5, __FILE__, __LINE__, "Induced Accelerations of gravity for double pendulum q2 FAILED");
 
-        // Vec3 comAcc = iaaSolver.getInducedMassCenterAcceleration(s);
+        // SimTK::Vec3 comAcc = iaaSolver.getInducedMassCenterAcceleration(s);
         //cout << "CoM Acceleration due to gravity: " << comAcc << endl;
 
         // Compute Torq1 contribution
-        Vector udot_torq1 = iaaSolver.solve(s, "Torq1");
+        SimTK::Vector udot_torq1 = iaaSolver.solve(s, "Torq1");
         udot = calcDoublePendulumUdot(pendulum, s, torq1, 0, false, false);
 
         ASSERT_EQUAL(udot[0], udot_torq1[0], 1e-5, __FILE__, __LINE__, "Induced Accelerations of Torq1 for double pendulum q1 FAILED");
         ASSERT_EQUAL(udot[1], udot_torq1[1], 1e-5, __FILE__, __LINE__, "Induced Accelerations of Torq1 for double pendulum q2 FAILED");
 
         // Compute Torq2 contribution
-        Vector udot_torq2 = iaaSolver.solve(s, "Torq2");
+        SimTK::Vector udot_torq2 = iaaSolver.solve(s, "Torq2");
         udot = calcDoublePendulumUdot(pendulum, s, 0, torq2, false, false);
 
         ASSERT_EQUAL(udot[0], udot_torq2[0], 1e-5, __FILE__, __LINE__, "Induced Accelerations of Torq2 for double pendulum q1 FAILED");
@@ -192,11 +191,11 @@ void testDoublePendulum()
     q2_iaa.getDataColumn("Torq2", u2dot_torq2);
 
     Model pendulum("double_pendulum.osim");
-    State &s = pendulum.initSystem();
+    SimTK::State &s = pendulum.initSystem();
 
     for(int i=0; i<nt; ++i){
-        Vector &q = s.updQ();
-        Vector &u = s.updU();
+        SimTK::Vector &q = s.updQ();
+        SimTK::Vector &u = s.updU();
         s.updTime() = time[i];
         q[0]= (states[0])[i];
         q[1]= (states[1])[i];
@@ -205,7 +204,7 @@ void testDoublePendulum()
 
         // Compute velocity contribution
         // velocity first, since other contributors set u's to zero and the state is not restored until next iteration.
-        Vector udot = calcDoublePendulumUdot(pendulum, s, 0, 0, false, true);
+        SimTK::Vector udot = calcDoublePendulumUdot(pendulum, s, 0, 0, false, true);
         ASSERT_EQUAL(udot[0], u1dot_vel[i], 1e-5, __FILE__, __LINE__, "Induced Accelerations of velocity for double pendulum q1 FAILED");
         ASSERT_EQUAL(udot[1], u2dot_vel[i], 1e-5, __FILE__, __LINE__, "Induced Accelerations of velocity for double pendulum q2 FAILED");
 
@@ -229,7 +228,7 @@ void testDoublePendulum()
 }
 
 
-Vector calcDoublePendulumUdot(const Model &model, State &s, double Torq1, double Torq2, bool gravity, bool velocity)
+SimTK::Vector calcDoublePendulumUdot(const Model &model, SimTK::State &s, double Torq1, double Torq2, bool gravity, bool velocity)
 {
     if(gravity)
         model.getGravityForce().enable(s);
@@ -240,14 +239,14 @@ Vector calcDoublePendulumUdot(const Model &model, State &s, double Torq1, double
     if(!velocity)
         s.updU() = 0.0;
 
-    MultibodySystem &sys = model.updMultibodySystem();
-    Vector &mobilityForces = sys.updMobilityForces(s, Stage::Dynamics);
-    sys.realize(s, Stage::Dynamics);
+    SimTK::MultibodySystem &sys = model.updMultibodySystem();
+    SimTK::Vector &mobilityForces = sys.updMobilityForces(s, SimTK::Stage::Dynamics);
+    sys.realize(s, SimTK::Stage::Dynamics);
 
     mobilityForces[0] = Torq1;
     mobilityForces[1] = Torq2;
 
-    sys.realize(s, Stage::Acceleration);
+    sys.realize(s, SimTK::Stage::Acceleration);
 
     return s.getUDot();
-}
+}
\ No newline at end of file
diff --git a/Applications/Scale/test/testScale.cpp b/Applications/Scale/test/testScale.cpp
index 24cdf3af5..96e307f4e 100644
--- a/Applications/Scale/test/testScale.cpp
+++ b/Applications/Scale/test/testScale.cpp
@@ -112,8 +112,8 @@ void compareModelToStandard(const std::string&  resultFilename,
         OPENSIM_THROW_IF(!target->hasComponent(absPathStr), Exception,
             "Marker '" + absPathStr + "' not found in standard model.");
 
-        const Vec3& result_loc = mResult.get_location();
-        const Vec3& target_loc =
+        const SimTK::Vec3& result_loc = mResult.get_location();
+        const SimTK::Vec3& target_loc =
             target->getComponent<Marker>(absPathStr).get_location();
 
         cout << "  '" << absPathStr << "' - location: " << result_loc << endl;
@@ -146,9 +146,9 @@ void compareModelToStandard(const std::string&  resultFilename,
         cout << "  '" << absPathStr << "'" << endl;
         for (int i = 0; i < gpResult.getPathPointSet().getSize(); ++i)
         {
-            const Vec3& result_loc =
+            const SimTK::Vec3& result_loc =
                 gpResult.getPathPointSet()[i].getLocation(sResult);
-            const Vec3& target_loc =
+            const SimTK::Vec3& target_loc =
                 target->getComponent<GeometryPath>(absPathStr)
                 .getPathPointSet()[i].getLocation(sTarget);
 
@@ -343,30 +343,28 @@ void scalePhysicalOffsetFrames()
 {
     cout << "Scaling PhysicalOffsetFrames and models with atypical ownership "
          << "trees..." << endl;
-
-    using namespace SimTK;
-    const Transform tfY = Transform(Vec3(0,1,0));
+    const SimTK::Transform tfY = SimTK::Transform(SimTK::Vec3(0,1,0));
 
     // Create ScaleSet to scale the OpenSim::Body named "body".
     const double scaleFactor = 1.234;
     ScaleSet scaleSet;
     Scale* scale = new Scale();
     scale->setSegmentName("body");
-    scale->setScaleFactors(Vec3(scaleFactor));
+    scale->setScaleFactors(SimTK::Vec3(scaleFactor));
     scale->setApply(true);
     scaleSet.adoptAndAppend(scale);
 
     // Expected location of COM in Ground after scaling.
-    Vec3 expectedLoc = Vec3(0, -scaleFactor, 0);
+    SimTK::Vec3 expectedLoc = SimTK::Vec3(0, -scaleFactor, 0);
 
     // Helper function to scale the model, report the COM location, and compare
     // to the expected location.
-    auto testScaling = [&](Model* model, State& s) -> void
+    auto testScaling = [&](Model* model, SimTK::State& s) -> void
     {
         const OpenSim::Body& body = model->getBodySet().get("body");
-        const Vec3 initialLoc = body.findStationLocationInGround(s, Vec3(0));
+        const SimTK::Vec3 initialLoc = body.findStationLocationInGround(s, SimTK::Vec3(0));
         model->scale(s, scaleSet, false);
-        const Vec3 finalLoc = body.findStationLocationInGround(s, Vec3(0));
+        const SimTK::Vec3 finalLoc = body.findStationLocationInGround(s, SimTK::Vec3(0));
 
         ASSERT_EQUAL(finalLoc, expectedLoc, SimTK::SignificantReal,
             __FILE__, __LINE__,
@@ -382,14 +380,14 @@ void scalePhysicalOffsetFrames()
         cout << "- case 1" << endl;
 
         Model* model = new Model();
-        OpenSim::Body* body = new OpenSim::Body("body", 1, Vec3(0), Inertia(0));
+        OpenSim::Body* body = new OpenSim::Body("body", 1, SimTK::Vec3(0), SimTK::Inertia(0));
         model->addBody(body);
 
-        PinJoint* pin = new PinJoint("pin", model->getGround(), Vec3(0), Vec3(0),
-                                            *body, Vec3(0,1,0), Vec3(0));
+        PinJoint* pin = new PinJoint("pin", model->getGround(), SimTK::Vec3(0), SimTK::Vec3(0),
+                                            *body, SimTK::Vec3(0,1,0), SimTK::Vec3(0));
         model->addJoint(pin);
 
-        State& s = model->initSystem();
+        SimTK::State& s = model->initSystem();
         testScaling(model, s);
     }
 
@@ -402,7 +400,7 @@ void scalePhysicalOffsetFrames()
         cout << "- case 2(" << std::string("abc").substr(i,1) << ")" << endl;
 
         Model* model = new Model();
-        OpenSim::Body* body = new OpenSim::Body("body", 1, Vec3(0), Inertia(0));
+        OpenSim::Body* body = new OpenSim::Body("body", 1, SimTK::Vec3(0), SimTK::Inertia(0));
         model->addBody(body);
 
         PinJoint* pin = new PinJoint();
@@ -420,7 +418,7 @@ void scalePhysicalOffsetFrames()
         pin->connectSocket_parent_frame(model->getGround());
         pin->connectSocket_child_frame(*pof);
 
-        State& s = model->initSystem();
+        SimTK::State& s = model->initSystem();
         testScaling(model, s);
     }
 
@@ -440,17 +438,17 @@ void scalePhysicalOffsetFrames()
         Model* model = new Model();
 
         // First add a body and joint as in Case 1.
-        OpenSim::Body* otherBody = new OpenSim::Body("otherBody", 1, Vec3(0),
-                                                     Inertia(0));
+        OpenSim::Body* otherBody = new OpenSim::Body("otherBody", 1, SimTK::Vec3(0),
+                                                     SimTK::Inertia(0));
         model->addBody(otherBody);
 
         PinJoint* otherPin = new PinJoint("otherPin",
-                                          model->getGround(), Vec3(0), Vec3(0),
-                                          *otherBody, Vec3(0,1,0), Vec3(0));
+                                          model->getGround(), SimTK::Vec3(0), SimTK::Vec3(0),
+                                          *otherBody, SimTK::Vec3(0,1,0), SimTK::Vec3(0));
         model->addJoint(otherPin);
 
         // Now add the components for the test.
-        OpenSim::Body* body = new OpenSim::Body("body", 1, Vec3(0), Inertia(0));
+        OpenSim::Body* body = new OpenSim::Body("body", 1, SimTK::Vec3(0), SimTK::Inertia(0));
         model->addBody(body);
 
         PinJoint* pin = new PinJoint();
@@ -466,7 +464,7 @@ void scalePhysicalOffsetFrames()
         pin->connectSocket_parent_frame(model->getGround());
         pin->connectSocket_child_frame(*pof);
 
-        State& s = model->initSystem();
+        SimTK::State& s = model->initSystem();
         testScaling(model, s);
     }
     */
@@ -478,31 +476,31 @@ void scalePhysicalOffsetFrames()
         cout << "- case 4" << endl;
 
         Model* model = new Model();
-        OpenSim::Body* body = new OpenSim::Body("body", 1, Vec3(0), Inertia(0));
+        OpenSim::Body* body = new OpenSim::Body("body", 1, SimTK::Vec3(0), SimTK::Inertia(0));
         model->addBody(body);
 
         FreeJoint* free = new FreeJoint("free", model->getGround(), *body);
         free->setName("free");
         model->addJoint(free);
 
-        // First Marker is attached to and owned by the Body.
-        const Vec3 offset1 = Vec3(0.3, 0.6, 0.9);
+        // First Marker is attached to and owned by the SimTK::Body.
+        const SimTK::Vec3 offset1 = SimTK::Vec3(0.3, 0.6, 0.9);
         Marker* marker1 = new Marker("marker1", *body, offset1);
         body->addComponent(marker1);
 
-        // Second Marker is attached to the Body via one PhysicalOffsetFrame.
+        // Second Marker is attached to the SimTK::Body via one PhysicalOffsetFrame.
         // The POF is owned by the Model; the Marker is owned by the Joint.
-        const Vec3 offset2  = offset1 / 2.;
-        const Transform tf2 = Transform(offset2);
+        const SimTK::Vec3 offset2  = offset1 / 2.;
+        const SimTK::Transform tf2 = SimTK::Transform(offset2);
         PhysicalOffsetFrame* pof2 = new PhysicalOffsetFrame("pof2", *body, tf2);
         model->addComponent(pof2);
         Marker* marker2 = new Marker("marker2", *pof2, offset2);
         free->addComponent(marker2);
 
-        // Third Marker is attached to the Body via two PhysicalOffsetFrames.
+        // Third Marker is attached to the SimTK::Body via two PhysicalOffsetFrames.
         // All new ModelComponents are owned by the first Marker.
-        const Vec3 offset3  = offset1 / 3.;
-        const Transform tf3 = Transform(offset3);
+        const SimTK::Vec3 offset3  = offset1 / 3.;
+        const SimTK::Transform tf3 = SimTK::Transform(offset3);
         PhysicalOffsetFrame* pof3a = new PhysicalOffsetFrame("pof3a", *body, tf3);
         marker1->addComponent(pof3a);
         PhysicalOffsetFrame* pof3b = new PhysicalOffsetFrame("pof3b", *pof3a, tf3);
@@ -510,15 +508,15 @@ void scalePhysicalOffsetFrames()
         Marker* marker3 = new Marker("marker3", *pof3b, offset3);
         marker1->addComponent(marker3);
 
-        State& s = model->initSystem();
+        SimTK::State& s = model->initSystem();
 
         // Ensure all Markers are coincident before scaling.
-        Vec3 expectedMarkerLoc = offset1;
+        SimTK::Vec3 expectedMarkerLoc = offset1;
 
         auto testMarkerLoc =
-            [&](Marker* marker, const State& s, const std::string& msg) -> void
+            [&](Marker* marker, const SimTK::State& s, const std::string& msg) -> void
         {
-            const Vec3 loc = marker->getLocationInGround(s);
+            const SimTK::Vec3 loc = marker->getLocationInGround(s);
 
             ASSERT_EQUAL(loc, expectedMarkerLoc, SimTK::SignificantReal,
                 __FILE__, __LINE__,
@@ -532,10 +530,10 @@ void scalePhysicalOffsetFrames()
         testMarkerLoc(marker3, s, "before scaling");
 
         // Scale the model (updates the model's properties, reinitializes the
-        // computational system, and updates the State that is passed in).
+        // computational system, and updates the SimTK::State that is passed in).
         model->scale(s, scaleSet, false);
         expectedMarkerLoc =
-            expectedMarkerLoc.elementwiseMultiply(Vec3(scaleFactor));
+            expectedMarkerLoc.elementwiseMultiply(SimTK::Vec3(scaleFactor));
 
         // Ensure all Markers are coincident after scaling.
         testMarkerLoc(marker1, s, "after scaling");
@@ -550,43 +548,43 @@ void scalePhysicalOffsetFrames()
         cout << "- case 5" << endl;
 
         Model* model = new Model();
-        OpenSim::Body* body = new OpenSim::Body("body", 1, Vec3(0), Inertia(0));
+        OpenSim::Body* body = new OpenSim::Body("body", 1, SimTK::Vec3(0), SimTK::Inertia(0));
         model->addBody(body);
 
         FreeJoint* free = new FreeJoint("free", model->getGround(), *body);
         free->setName("free");
         model->addJoint(free);
 
-        // First PathActuator is attached to and owned by the Body.
-        const Vec3 offset1 = Vec3(0.2, 0.4, 0.6);
+        // First PathActuator is attached to and owned by the SimTK::Body.
+        const SimTK::Vec3 offset1 = SimTK::Vec3(0.2, 0.4, 0.6);
         PathActuator* act1 = new PathActuator();
         act1->setName("pathActuator1");
-        act1->addNewPathPoint("point1a", model->updGround(), Vec3(0));
+        act1->addNewPathPoint("point1a", model->updGround(), SimTK::Vec3(0));
         act1->addNewPathPoint("point1b", *body, offset1);
         body->addComponent(act1);
 
-        // Second PathActuator is attached to the Body via a POF. Both new
+        // Second PathActuator is attached to the SimTK::Body via a POF. Both new
         // ModelComponents are owned by the first PathActuator.
-        const Vec3 offset2 = offset1 / 2.;
-        const Transform tf2 = Transform(offset2);
+        const SimTK::Vec3 offset2 = offset1 / 2.;
+        const SimTK::Transform tf2 = SimTK::Transform(offset2);
 
         PhysicalOffsetFrame* pof2 = new PhysicalOffsetFrame("pof2", *body, tf2);
         act1->addComponent(pof2);
 
         PathActuator* act2 = new PathActuator();
         act2->setName("pathActuator2");
-        act2->addNewPathPoint("point2a", model->updGround(), Vec3(0));
+        act2->addNewPathPoint("point2a", model->updGround(), SimTK::Vec3(0));
         act2->addNewPathPoint("point2b", *pof2, offset2);
         act1->addComponent(act2);
 
-        State& s = model->initSystem();
+        SimTK::State& s = model->initSystem();
 
         const std::string pathToAct1 = act1->getAbsolutePathString();
         const std::string pathToAct2 = act2->getAbsolutePathString();
 
         // Ensure PathPoints are coincident before scaling.
         auto testPathPointLoc =
-            [&](const State& s, const std::string& msg) -> void
+            [&](const SimTK::State& s, const std::string& msg) -> void
         {
             const PathActuator& pa1 =
                 model->getComponent<PathActuator>(pathToAct1);
@@ -598,8 +596,8 @@ void scalePhysicalOffsetFrames()
 
             for (int i = 0; i < 2; ++i)
             {
-                const Vec3& p1 = pps1[i].getLocationInGround(s);
-                const Vec3& p2 = pps2[i].getLocationInGround(s);
+                const SimTK::Vec3& p1 = pps1[i].getLocationInGround(s);
+                const SimTK::Vec3& p2 = pps2[i].getLocationInGround(s);
 
                 ASSERT_EQUAL(p1, p2, SimTK::SignificantReal, __FILE__, __LINE__,
                     "The location of point " + std::to_string(i)
@@ -611,7 +609,7 @@ void scalePhysicalOffsetFrames()
         testPathPointLoc(s, "before scaling");
 
         // Scale the model (updates the model's properties, reinitializes the
-        // computational system, and updates the State that is passed in).
+        // computational system, and updates the SimTK::State that is passed in).
         model->scale(s, scaleSet, false);
 
         // Ensure PathPoints are coincident after scaling.
@@ -622,11 +620,8 @@ void scalePhysicalOffsetFrames()
 void scaleJointsAndConstraints()
 {
     cout << "Scaling Joints and Constraints..." << endl;
-
-    using namespace SimTK;
-
     // Create ScaleSet to scale "body1" and "body2".
-    const Vec3 scaleFactors = Vec3(1.1, 2.22, 3.333);
+    const SimTK::Vec3 scaleFactors = SimTK::Vec3(1.1, 2.22, 3.333);
     ScaleSet scaleSet;
     auto addBodyScale = [&](const std::string& bodyName) -> void {
         Scale* scale = new Scale();
@@ -639,17 +634,17 @@ void scaleJointsAndConstraints()
     addBodyScale("body2");
 
     // Test EllipsoidJoint scaling. Ensure radii are scaled if the parent is a
-    // Body but does not change if the parent is Ground.
+    // SimTK::Body but does not change if the parent is Ground.
     {
         cout << "- EllipsoidJoint" << endl;
 
         Model* model = new Model();
-        OpenSim::Body* body1 = new OpenSim::Body("body1", 1, Vec3(0), Inertia(0));
+        OpenSim::Body* body1 = new OpenSim::Body("body1", 1, SimTK::Vec3(0), SimTK::Inertia(0));
         model->addBody(body1);
-        OpenSim::Body* body2 = new OpenSim::Body("body2", 1, Vec3(0), Inertia(0));
+        OpenSim::Body* body2 = new OpenSim::Body("body2", 1, SimTK::Vec3(0), SimTK::Inertia(0));
         model->addBody(body2);
 
-        const Vec3 radii = Vec3(0.123, 0.456, 0.789);
+        const SimTK::Vec3 radii = SimTK::Vec3(0.123, 0.456, 0.789);
 
         EllipsoidJoint* ellipsoid1 =
             new EllipsoidJoint("ellipsoid1", model->getGround(), *body1, radii);
@@ -659,13 +654,13 @@ void scaleJointsAndConstraints()
         model->addJoint(ellipsoid2);
 
         // Scale the model (updates the model's properties, reinitializes the
-        // computational system, and updates the State that is passed in).
-        State& s = model->initSystem();
+        // computational system, and updates the SimTK::State that is passed in).
+        SimTK::State& s = model->initSystem();
         model->scale(s, scaleSet, false);
 
         // Radii of ellipsoid1 should not have changed.
-        const Vec3& actual1   = ellipsoid1->get_radii_x_y_z();
-        const Vec3& expected1 = radii;
+        const SimTK::Vec3& actual1   = ellipsoid1->get_radii_x_y_z();
+        const SimTK::Vec3& expected1 = radii;
         ASSERT_EQUAL(actual1, expected1, SimTK::SignificantReal,
             __FILE__, __LINE__,
             "EllipsoidJoint 'ellipsoid1' has incorrect radii.\n  actual: "
@@ -673,8 +668,8 @@ void scaleJointsAndConstraints()
 
         // Radii of ellipsoid2 should have been scaled using the scale factors
         // corresponding to body2.
-        const Vec3& actual2   = ellipsoid2->get_radii_x_y_z();
-        const Vec3& expected2 = radii.elementwiseMultiply(scaleFactors);
+        const SimTK::Vec3& actual2   = ellipsoid2->get_radii_x_y_z();
+        const SimTK::Vec3& expected2 = radii.elementwiseMultiply(scaleFactors);
         ASSERT_EQUAL(actual2, expected2, SimTK::SignificantReal,
             __FILE__, __LINE__,
             "EllipsoidJoint 'ellipsoid2' has incorrect radii.\n  actual: "
@@ -682,14 +677,14 @@ void scaleJointsAndConstraints()
     }
 
     // Test CustomJoint scaling. Ensure SpatialTransform is scaled if the parent
-    // is a Body but does not change if the parent is Ground.
+    // is a SimTK::Body but does not change if the parent is Ground.
     {
         cout << "- CustomJoint" << endl;
 
         Model* model = new Model();
-        OpenSim::Body* body1 = new OpenSim::Body("body1", 1, Vec3(0), Inertia(0));
+        OpenSim::Body* body1 = new OpenSim::Body("body1", 1, SimTK::Vec3(0), SimTK::Inertia(0));
         model->addBody(body1);
-        OpenSim::Body* body2 = new OpenSim::Body("body2", 1, Vec3(0), Inertia(0));
+        OpenSim::Body* body2 = new OpenSim::Body("body2", 1, SimTK::Vec3(0), SimTK::Inertia(0));
         model->addBody(body2);
 
         SpatialTransform transform;
@@ -697,9 +692,9 @@ void scaleJointsAndConstraints()
         transform[3].setFunction(new LinearFunction(1.234, 5.678));
 
         // Evaluate LinearFunction before scaling and compare after scaling.
-        const Vector xA = Vector(1, 0.);
+        const SimTK::Vector xA = SimTK::Vector(1, 0.);
         const double yA = transform[3].getFunction().calcValue(xA);
-        const Vector xB = Vector(1, 123.456);
+        const SimTK::Vector xB = SimTK::Vector(1, 123.456);
         const double yB = transform[3].getFunction().calcValue(xB);
 
         CustomJoint* custom1 =
@@ -710,11 +705,11 @@ void scaleJointsAndConstraints()
         model->addJoint(custom2);
 
         // Scale the model (updates the model's properties, reinitializes the
-        // computational system, and updates the State that is passed in).
-        State& s = model->initSystem();
+        // computational system, and updates the SimTK::State that is passed in).
+        SimTK::State& s = model->initSystem();
         model->scale(s, scaleSet, false);
 
-        // Transform of custom1 should not have changed.
+        // SimTK::Transform of custom1 should not have changed.
         const OpenSim::Function& fn1 =
             custom1->getSpatialTransform()[3].getFunction();
         ASSERT_EQUAL(fn1.calcValue(xA), yA, SimTK::SignificantReal,
@@ -722,7 +717,7 @@ void scaleJointsAndConstraints()
         ASSERT_EQUAL(fn1.calcValue(xB), yB, SimTK::SignificantReal,
             __FILE__, __LINE__, "CustomJoint 'custom1' was incorrectly scaled.");
 
-        // Transform of custom2 should have been scaled using the scale factors
+        // SimTK::Transform of custom2 should have been scaled using the scale factors
         // corresponding to body2.
         const OpenSim::Function& fn2 =
             custom2->getSpatialTransform()[3].getFunction();
@@ -739,9 +734,9 @@ void scaleJointsAndConstraints()
         cout << "- CoordinateCouplerConstraint" << endl;
 
         Model* model = new Model();
-        OpenSim::Body* body1 = new OpenSim::Body("body1", 1, Vec3(0), Inertia(0));
+        OpenSim::Body* body1 = new OpenSim::Body("body1", 1, SimTK::Vec3(0), SimTK::Inertia(0));
         model->addBody(body1);
-        OpenSim::Body* body2 = new OpenSim::Body("body2", 1, Vec3(0), Inertia(0));
+        OpenSim::Body* body2 = new OpenSim::Body("body2", 1, SimTK::Vec3(0), SimTK::Inertia(0));
         model->addBody(body2);
 
         // Attach bodies to Ground with slider joints.
@@ -768,7 +763,7 @@ void scaleJointsAndConstraints()
         // Scale the model with non-uniform scale factors. Should fetch the
         // scale factors corresponding to body2 and then throw because only
         // uniform scaling is currently supported.
-        State& s = model->initSystem();
+        SimTK::State& s = model->initSystem();
         ASSERT_THROW(OpenSim::Exception, model->scale(s, scaleSet, false));
 
         // Test coupling function before scaling.
@@ -787,7 +782,7 @@ void scaleJointsAndConstraints()
         ScaleSet scaleSetUniform;
         Scale* scale = new Scale();
         scale->setSegmentName("body1");
-        scale->setScaleFactors(Vec3(uniformFactor));
+        scale->setScaleFactors(SimTK::Vec3(uniformFactor));
         scale->setApply(true);
         scaleSetUniform.adoptAndAppend(scale);
 
@@ -806,4 +801,4 @@ void scaleJointsAndConstraints()
             SimTK::SignificantReal, __FILE__, __LINE__,
             "SliderJoint has incorrect Coordinate value after scaling.");
     }
-}
+}
\ No newline at end of file
diff --git a/Applications/opensim-visualize/opensim-visualize.cpp b/Applications/opensim-visualize/opensim-visualize.cpp
index 5aa20ab5d..e6cc0c1d3 100644
--- a/Applications/opensim-visualize/opensim-visualize.cpp
+++ b/Applications/opensim-visualize/opensim-visualize.cpp
@@ -37,11 +37,10 @@
 #include <OpenSim/Simulation/OpenSense/OpenSenseUtilities.h>
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 SimTK::Vec3 parseRotationsString(const std::string& rotationString) {
-    Vec3 returnVec3{0};
+    SimTK::Vec3 returnVec3{0};
     std::stringstream ss(rotationString);
     ss >> returnVec3;
     return returnVec3;
@@ -116,7 +115,7 @@ int main(int argc, char** argv) {
                 }
                 if (option == "-R") {
                     if (argc < i + 2) {
-                        cout << "No Rotation specified after option -R";
+                        cout << "No SimTK::Rotation specified after option -R";
                         PrintUsage(argv[0], cout);
                         exit(-1);
                     }
@@ -232,4 +231,4 @@ void PrintUsage(const char* aProgName, ostream& aOStream) {
                 "layout is one of {line, circle, model}, If model      \n"
                 "                                                       "
                 "is specified, it's used to layout data on screen.     \n";
-}
+}
\ No newline at end of file
diff --git a/Bindings/Java/OpenSimJNI/Test/testContext.cpp b/Bindings/Java/OpenSimJNI/Test/testContext.cpp
index 54bed517b..6a2aecc71 100644
--- a/Bindings/Java/OpenSimJNI/Test/testContext.cpp
+++ b/Bindings/Java/OpenSimJNI/Test/testContext.cpp
@@ -46,7 +46,6 @@
 #include <OpenSim/Actuators/Thelen2003Muscle.h>
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 #define ASSERT_EQUAL(expected, found, tolerance) { \
@@ -130,7 +129,7 @@ int main()
              << path[i]->getLocation(context->getCurrentStateRef()) << endl;
     // Compare to known path 
     const OpenSim::Body& dBody = model->getBodySet().get("r_ulna_radius_hand");
-    Transform xform = context->getTransform(dBody);
+    SimTK::Transform xform = context->getTransform(dBody);
     cout << xform << endl;
     double flat[16];
     context->getTransformAsDouble16(xform, flat);
@@ -261,5 +260,4 @@ int main()
       cout << "Exception: " << e.what() << endl;
       return 1;
   }
-}
-
+}
\ No newline at end of file
diff --git a/CMakeLists.txt b/CMakeLists.txt
index ffd2b0a28..4cd6b6b2d 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -9,7 +9,7 @@
 
 cmake_minimum_required(VERSION 3.15)
 project(OpenSim)
-
+set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
 if(COMMAND cmake_policy)
     cmake_policy(SET CMP0003 NEW)
     cmake_policy(SET CMP0005 NEW)
diff --git a/OpenSim/Actuators/ActiveForceLengthCurve.cpp b/OpenSim/Actuators/ActiveForceLengthCurve.cpp
index 651e57720..0270ba2e4 100644
--- a/OpenSim/Actuators/ActiveForceLengthCurve.cpp
+++ b/OpenSim/Actuators/ActiveForceLengthCurve.cpp
@@ -24,7 +24,6 @@
 #include <OpenSim/Common/SmoothSegmentedFunctionFactory.h>
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 //==============================================================================
@@ -205,4 +204,4 @@ void ActiveForceLengthCurve::printMuscleCurveToCSVFile(const std::string& path)
     double xmax = max(2.0, get_max_norm_active_fiber_length());
 
     m_curve.printMuscleCurveToCSVFile(path,xmin,xmax);
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Actuators/BodyActuator.cpp b/OpenSim/Actuators/BodyActuator.cpp
index 17f87cee2..210f309a6 100644
--- a/OpenSim/Actuators/BodyActuator.cpp
+++ b/OpenSim/Actuators/BodyActuator.cpp
@@ -50,7 +50,7 @@ BodyActuator::BodyActuator()
 /**
 * Convenience constructor.
 */
-BodyActuator::BodyActuator(const Body& body, 
+BodyActuator::BodyActuator(const OpenSim::Body& body,
                            const SimTK::Vec3& point,
                            bool pointIsGlobal,
                            bool spatialForceIsGlobal)
@@ -74,12 +74,12 @@ void BodyActuator::constructProperties()
 
 void BodyActuator::setBodyName(const std::string& name)
 {
-    updSocket<Body>("body").setConnecteePath(name);
+    updSocket<OpenSim::Body>("body").setConnecteePath(name);
 }
 
 const std::string& BodyActuator::getBodyName() const
 {
-    return getSocket<Body>("body").getConnecteePath();
+    return getSocket<OpenSim::Body>("body").getConnecteePath();
 }
 
 //=============================================================================
@@ -87,19 +87,19 @@ const std::string& BodyActuator::getBodyName() const
 //=============================================================================
 //_____________________________________________________________________________
 /**
-* Set the Body to which the BodyActuator is applied
+* Set the OpenSim::Body to which the BodyActuator is applied
 */
-void BodyActuator::setBody(const Body& body)
+void BodyActuator::setBody(const OpenSim::Body& body)
 {
     connectSocket_body(body);
 }
 
 /**
-* Get the Body to which the BodyActuator is applied
+* Get the OpenSim::Body to which the BodyActuator is applied
 */
-const Body& BodyActuator::getBody() const
+const OpenSim::Body& BodyActuator::getBody() const
 {
-    return getConnectee<Body>("body");
+    return getConnectee<OpenSim::Body>("body");
 }
 
 //_____________________________________________________________________________
@@ -110,7 +110,7 @@ const Body& BodyActuator::getBody() const
 */
 double BodyActuator::getPower(const SimTK::State& s) const
 {
-    const Body& body = getBody();
+    const OpenSim::Body& body = getBody();
 
     const SimTK::MobilizedBody& body_mb = body.getMobilizedBody();
     SimTK::SpatialVec bodySpatialVelocities = body_mb.getBodyVelocity(s);
@@ -137,7 +137,7 @@ void BodyActuator::implProduceForces(const SimTK::State& s,
 
     const bool spatialForceIsGlobal = getSpatialForceIsGlobal();
 
-    const Body& body = getBody();
+    const OpenSim::Body& body = getBody();
     // const SimTK::MobilizedBody& body_mb = body.getMobilizedBody();
 
     Vec3 pointOfApplication = get_point(); 
diff --git a/OpenSim/Actuators/ConstantMuscleActivation.cpp b/OpenSim/Actuators/ConstantMuscleActivation.cpp
index 3e20c1f0b..8d4ec3f72 100644
--- a/OpenSim/Actuators/ConstantMuscleActivation.cpp
+++ b/OpenSim/Actuators/ConstantMuscleActivation.cpp
@@ -25,8 +25,6 @@
 
 using namespace std;
 using namespace OpenSim;
-using namespace SimTK;
-
 //==============================================================================
 // CONSTRUCTORS
 //==============================================================================
@@ -85,4 +83,4 @@ setActivation(SimTK::State& s, double activation) const
 void ConstantMuscleActivation::setNull()
 {
     setAuthors("Thomas Uchida, Ajay Seth");
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Actuators/FiberCompressiveForceCosPennationCurve.cpp b/OpenSim/Actuators/FiberCompressiveForceCosPennationCurve.cpp
index cf3951925..6aedcfd81 100644
--- a/OpenSim/Actuators/FiberCompressiveForceCosPennationCurve.cpp
+++ b/OpenSim/Actuators/FiberCompressiveForceCosPennationCurve.cpp
@@ -24,7 +24,6 @@
 #include <OpenSim/Common/SmoothSegmentedFunctionFactory.h>
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 //=============================================================================
@@ -90,7 +89,7 @@ void FiberCompressiveForceCosPennationCurve::buildCurve( bool computeIntegral )
 {
     SmoothSegmentedFunction* f = SmoothSegmentedFunctionFactory::
         createFiberCompressiveForceCosPennationCurve(   
-                cos(get_engagement_angle_in_degrees()*Pi/180.0), 
+                cos(get_engagement_angle_in_degrees()*SimTK::Pi/180.0), 
                 m_stiffnessAtPerpendicularInUse,
                 m_curvinessInUse,
                 computeIntegral,
@@ -114,7 +113,7 @@ void FiberCompressiveForceCosPennationCurve::ensureCurveUpToDate()
             getProperty_curviness().empty() == true)
         {
             double eAngleRad = get_engagement_angle_in_degrees()
-                              *Pi/180.0;
+                              *SimTK::Pi/180.0;
 
             m_stiffnessAtPerpendicularInUse= -2.0/cos(eAngleRad); 
             m_curvinessInUse = 0.1;
@@ -172,7 +171,7 @@ SimTK::Function* FiberCompressiveForceCosPennationCurve::createSimTKFunction() c
     
     return SmoothSegmentedFunctionFactory::
         createFiberCompressiveForceCosPennationCurve(   
-                cos(get_engagement_angle_in_degrees()*Pi/180.0), 
+                cos(get_engagement_angle_in_degrees()*SimTK::Pi/180.0), 
                 m_stiffnessAtPerpendicularInUse,
                 m_curvinessInUse,
                 false,
@@ -290,4 +289,4 @@ void FiberCompressiveForceCosPennationCurve::
 
 
     m_curve.printMuscleCurveToCSVFile(path,xmin,xmax);
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Actuators/FiberCompressiveForceLengthCurve.cpp b/OpenSim/Actuators/FiberCompressiveForceLengthCurve.cpp
index f4c582bab..b6d2a8fef 100644
--- a/OpenSim/Actuators/FiberCompressiveForceLengthCurve.cpp
+++ b/OpenSim/Actuators/FiberCompressiveForceLengthCurve.cpp
@@ -24,7 +24,6 @@
 #include <OpenSim/Common/SmoothSegmentedFunctionFactory.h>
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 //=============================================================================
@@ -277,4 +276,4 @@ void FiberCompressiveForceLengthCurve::
     double xmax = max(1.0,get_norm_length_at_zero_force());
 
     m_curve.printMuscleCurveToCSVFile(path,xmin,xmax);
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Actuators/FiberForceLengthCurve.cpp b/OpenSim/Actuators/FiberForceLengthCurve.cpp
index 12944e94e..deda8dd23 100644
--- a/OpenSim/Actuators/FiberForceLengthCurve.cpp
+++ b/OpenSim/Actuators/FiberForceLengthCurve.cpp
@@ -24,7 +24,6 @@
 #include <OpenSim/Common/SmoothSegmentedFunctionFactory.h>
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 static int RefFiber_e0_Idx     = 0;
@@ -457,4 +456,4 @@ SimTK::Vec5 FiberForceLengthCurve::calcReferencePassiveFiber(
     properties[RefFiber_normPE_Idx] = intF1-intF0;
 
     return properties;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Actuators/FirstOrderMuscleActivationDynamics.cpp b/OpenSim/Actuators/FirstOrderMuscleActivationDynamics.cpp
index 20e055603..0b98ae200 100644
--- a/OpenSim/Actuators/FirstOrderMuscleActivationDynamics.cpp
+++ b/OpenSim/Actuators/FirstOrderMuscleActivationDynamics.cpp
@@ -25,8 +25,6 @@
 
 using namespace std;
 using namespace OpenSim;
-using namespace SimTK;
-
 const std::string FirstOrderMuscleActivationDynamics::
                   STATE_NAME_ACTIVATION = "activation";
 
@@ -144,4 +142,4 @@ calcActivationDerivative(double excitation, double activation) const
                  ? getActivationTimeConstant() * (0.5 + 1.5*activation)
                  : getDeactivationTimeConstant() / (0.5 + 1.5*activation);
     return (excitation-activation)/tau;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Actuators/ForceVelocityCurve.cpp b/OpenSim/Actuators/ForceVelocityCurve.cpp
index e3db748d9..b75a97fb9 100644
--- a/OpenSim/Actuators/ForceVelocityCurve.cpp
+++ b/OpenSim/Actuators/ForceVelocityCurve.cpp
@@ -24,7 +24,6 @@
 #include <OpenSim/Common/SmoothSegmentedFunctionFactory.h>
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 //==============================================================================
@@ -218,4 +217,4 @@ void ForceVelocityCurve::printMuscleCurveToCSVFile(const std::string& path)
 {
     ensureCurveUpToDate();
     m_curve.printMuscleCurveToCSVFile(path, -1.25, 1.25);
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Actuators/ForceVelocityInverseCurve.cpp b/OpenSim/Actuators/ForceVelocityInverseCurve.cpp
index bbc1e2af5..9be759cda 100644
--- a/OpenSim/Actuators/ForceVelocityInverseCurve.cpp
+++ b/OpenSim/Actuators/ForceVelocityInverseCurve.cpp
@@ -24,7 +24,6 @@
 #include <OpenSim/Common/SmoothSegmentedFunctionFactory.h>
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 //==============================================================================
@@ -217,4 +216,4 @@ printMuscleCurveToCSVFile(const std::string& path)
     double xmax = get_max_eccentric_velocity_force_multiplier() + 0.1;
 
     m_curve.printMuscleCurveToCSVFile(path, xmin, xmax);
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Actuators/MuscleActivationDynamics.cpp b/OpenSim/Actuators/MuscleActivationDynamics.cpp
index 5ff5d5983..29f787a88 100644
--- a/OpenSim/Actuators/MuscleActivationDynamics.cpp
+++ b/OpenSim/Actuators/MuscleActivationDynamics.cpp
@@ -25,8 +25,6 @@
 
 using namespace std;
 using namespace OpenSim;
-using namespace SimTK;
-
 //==============================================================================
 // CONSTRUCTORS AND DESTRUCTOR
 //==============================================================================
@@ -63,13 +61,13 @@ double MuscleActivationDynamics::getDefaultActivation() const
 
 void MuscleActivationDynamics::setMinimumActivation(double minimumActivation)
 {
-    set_minimum_activation( clamp(0,minimumActivation,getMaximumActivation()) );
+    set_minimum_activation( clamp(0.0,minimumActivation,getMaximumActivation()) );
     set_default_activation( clampToValidInterval(getDefaultActivation()) );
 }
 
 void MuscleActivationDynamics::setMaximumActivation(double maximumActivation)
 {
-    set_maximum_activation( clamp(getMinimumActivation(),maximumActivation,1) );
+    set_maximum_activation( clamp(getMinimumActivation(),maximumActivation,1.0) );
     set_default_activation( clampToValidInterval(getDefaultActivation()) );
 }
 
diff --git a/OpenSim/Actuators/MuscleFirstOrderActivationDynamicModel.cpp b/OpenSim/Actuators/MuscleFirstOrderActivationDynamicModel.cpp
index c243d260c..f84bc6043 100644
--- a/OpenSim/Actuators/MuscleFirstOrderActivationDynamicModel.cpp
+++ b/OpenSim/Actuators/MuscleFirstOrderActivationDynamicModel.cpp
@@ -24,8 +24,6 @@
 
 using namespace std;
 using namespace OpenSim;
-using namespace SimTK;
-
 //==============================================================================
 // CONSTRUCTION
 //==============================================================================
@@ -113,4 +111,4 @@ void MuscleFirstOrderActivationDynamicModel::extendFinalizeFromProperties()
         InvalidPropertyValue,
         getProperty_minimum_activation().getName(),
         "Minimum activation must be in the range [0, 1)");
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Actuators/MuscleFixedWidthPennationModel.cpp b/OpenSim/Actuators/MuscleFixedWidthPennationModel.cpp
index 40baf1851..e534583bf 100644
--- a/OpenSim/Actuators/MuscleFixedWidthPennationModel.cpp
+++ b/OpenSim/Actuators/MuscleFixedWidthPennationModel.cpp
@@ -23,7 +23,6 @@
 #include "MuscleFixedWidthPennationModel.h"
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 void MuscleFixedWidthPennationModel::setNull()
@@ -95,13 +94,13 @@ void MuscleFixedWidthPennationModel::extendFinalizeFromProperties()
         get_pennation_angle_at_optimal() > SimTK::Pi/2.0-SimTK::SignificantReal,
         InvalidPropertyValue,
         getProperty_pennation_angle_at_optimal().getName(),
-        "Pennation angle at optimal fiber length must be in the range [0, Pi/2)");
+        "Pennation angle at optimal fiber length must be in the range [0, SimTK::Pi/2)");
     OPENSIM_THROW_IF_FRMOBJ(
         get_maximum_pennation_angle() < 0 ||
         get_maximum_pennation_angle() > SimTK::Pi/2.0,
         InvalidPropertyValue,
         getProperty_maximum_pennation_angle().getName(),
-        "Maximum pennation angle must be in the range [0, Pi/2]");
+        "Maximum pennation angle must be in the range [0, SimTK::Pi/2]");
 
     // Compute quantities that are used often.
     m_parallelogramHeight = get_optimal_fiber_length()
@@ -353,4 +352,4 @@ calcFiberVelocity(double cosPennationAngle,
     // Differentiate h = l^M sin(phi) .............(2)
     // Solve (2) for phidot, substitute into (1), and solve for v^M.
     return (muscleVelocity-tendonVelocity)*cosPennationAngle;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Actuators/MuscleSecondOrderActivationDynamicModel.cpp b/OpenSim/Actuators/MuscleSecondOrderActivationDynamicModel.cpp
index 93f1d7176..4056d65c2 100644
--- a/OpenSim/Actuators/MuscleSecondOrderActivationDynamicModel.cpp
+++ b/OpenSim/Actuators/MuscleSecondOrderActivationDynamicModel.cpp
@@ -26,7 +26,6 @@
 #include "MuscleSecondOrderActivationDynamicModel.h"
 using namespace std;
 using namespace OpenSim;
-using namespace SimTK;
 //=============================================================================
 // Code
 //=============================================================================
@@ -289,5 +288,4 @@ int MuscleSecondOrderActivationDynamicModel::
     getMaxDerivativeOrder() const
 {
     return 2;
-}
-
+}
\ No newline at end of file
diff --git a/OpenSim/Actuators/TendonForceLengthCurve.cpp b/OpenSim/Actuators/TendonForceLengthCurve.cpp
index aa40d8d68..be7ce9cd2 100644
--- a/OpenSim/Actuators/TendonForceLengthCurve.cpp
+++ b/OpenSim/Actuators/TendonForceLengthCurve.cpp
@@ -24,7 +24,6 @@
 #include <OpenSim/Common/SmoothSegmentedFunctionFactory.h>
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 static int RefTendon_e0_Idx        = 0;
@@ -333,4 +332,4 @@ calcReferenceTendon(double strainAtOneNormForce)
     tdnProp[RefTendon_normPE_Idx]    = peNormTotal;
 
     return tdnProp;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Actuators/Test/testActuators.cpp b/OpenSim/Actuators/Test/testActuators.cpp
index 6561a36e3..b6317922c 100644
--- a/OpenSim/Actuators/Test/testActuators.cpp
+++ b/OpenSim/Actuators/Test/testActuators.cpp
@@ -51,7 +51,6 @@ const static double duration = 1.0;
 const static SimTK::Vec3 gravity_vec = SimTK::Vec3(0, -9.8065, 0);
 
 TEST_CASE("testTorqueActuator") {
-    using namespace SimTK;
     // start timing
     std::clock_t startTime = std::clock();
 
@@ -59,7 +58,7 @@ TEST_CASE("testTorqueActuator") {
     Model *model = new Model;
 
     // turn off gravity
-    model->setGravity(Vec3(0));
+    model->setGravity(SimTK::Vec3(0));
 
     //OpenSim bodies
     const Ground& ground = model->getGround();
@@ -67,67 +66,67 @@ TEST_CASE("testTorqueActuator") {
     //Cylindrical bodies
     double r = 0.25, h = 1.0;
     double m1 = 1.0, m2 = 2.0;
-    Inertia j1 = m1*Inertia::cylinderAlongY(r, h);
-    Inertia j2 = m2*Inertia::cylinderAlongY(r, h);
+    SimTK::Inertia j1 = m1*SimTK::Inertia::cylinderAlongY(r, h);
+    SimTK::Inertia j2 = m2*SimTK::Inertia::cylinderAlongY(r, h);
 
     //OpenSim bodies
     OpenSim::Body* bodyA 
-        = new OpenSim::Body("A", m1, Vec3(0), j1);
+        = new OpenSim::Body("A", m1, SimTK::Vec3(0), j1);
     
     OpenSim::Body* bodyB 
-        = new OpenSim::Body("B", m2, Vec3(0), j2);
+        = new OpenSim::Body("B", m2, SimTK::Vec3(0), j2);
 
     // connect bodyA to ground with 6dofs
     FreeJoint* base = 
-        new FreeJoint("base", ground, Vec3(0), Vec3(0), *bodyA, Vec3(0), Vec3(0));
+        new FreeJoint("base", ground, SimTK::Vec3(0), SimTK::Vec3(0), *bodyA, SimTK::Vec3(0), SimTK::Vec3(0));
 
     model->addBody(bodyA);
     model->addJoint(base);
 
     // connect bodyA to bodyB by a Ball joint
-    BallJoint* bInA = new BallJoint("bInA", *bodyA, Vec3(0,-h/2, 0), Vec3(0), 
-                           *bodyB, Vec3(0, h/2, 0), Vec3(0));
+    BallJoint* bInA = new BallJoint("bInA", *bodyA, SimTK::Vec3(0,-h/2, 0), SimTK::Vec3(0), 
+                           *bodyB, SimTK::Vec3(0, h/2, 0), SimTK::Vec3(0));
 
     model->addBody(bodyB);
     model->addJoint(bInA);
 
     // specify magnitude and direction of applied torque
     double torqueMag = 2.1234567890;
-    Vec3 torqueAxis(1/sqrt(2.0), 0, 1/sqrt(2.0));
-    Vec3 torqueInG = torqueMag*torqueAxis;
+    SimTK::Vec3 torqueAxis(1/sqrt(2.0), 0, 1/sqrt(2.0));
+    SimTK::Vec3 torqueInG = torqueMag*torqueAxis;
 
     model->print("testTorqueActuator.osim");
 
-    State state = model->initSystem();
+    SimTK::State state = model->initSystem();
 
-    model->getMultibodySystem().realize(state, Stage::Dynamics);
-    Vector_<SpatialVec>& bodyForces = 
-        model->getMultibodySystem().updRigidBodyForces(state, Stage::Dynamics);
-    bodyForces.dump("Body Forces before applying torque");
+    model->getMultibodySystem().realize(state, SimTK::Stage::Dynamics);
+    SimTK::Vector_<SimTK::SpatialVec>& bodyForces = 
+        model->getMultibodySystem().updRigidBodyForces(state, SimTK::Stage::Dynamics);
+    bodyForces.dump("SimTK::Body Forces before applying torque");
     model->getMatterSubsystem().addInBodyTorque(state, bodyA->getMobilizedBodyIndex(),
         torqueMag*torqueAxis, bodyForces);
     model->getMatterSubsystem().addInBodyTorque(state, bodyB->getMobilizedBodyIndex(),
         -torqueMag*torqueAxis, bodyForces);
-    bodyForces.dump("Body Forces after applying torque to bodyA and bodyB");
+    bodyForces.dump("SimTK::Body Forces after applying torque to bodyA and bodyB");
 
-    model->getMultibodySystem().realize(state, Stage::Acceleration);
-    const Vector& udotBody = state.getUDot();
+    model->getMultibodySystem().realize(state, SimTK::Stage::Acceleration);
+    const SimTK::Vector& udotBody = state.getUDot();
     udotBody.dump("Accelerations due to body forces");
 
     // clear body forces
     bodyForces *= 0;
 
     // update mobility forces
-    Vector& mobilityForces = model->getMultibodySystem()
-        .updMobilityForces(state, Stage::Dynamics);
+    SimTK::Vector& mobilityForces = model->getMultibodySystem()
+        .updMobilityForces(state, SimTK::Stage::Dynamics);
 
     // Apply torques as mobility forces of the ball joint
     for(int i=0; i<3; ++i){
         mobilityForces[6+i] = torqueInG[i]; 
     }
 
-    model->getMultibodySystem().realize(state, Stage::Acceleration);
-    const Vector& udotMobility = state.getUDot();
+    model->getMultibodySystem().realize(state, SimTK::Stage::Acceleration);
+    const SimTK::Vector& udotMobility = state.getUDot();
     udotMobility.dump("Accelerations due to mobility forces");
 
     // First make sure that accelerations are not zero accidentally
@@ -160,7 +159,7 @@ TEST_CASE("testTorqueActuator") {
     /*
     ActuatorPowerProbe* powerProbe = new ActuatorPowerProbe(Array<string>("torque",1),false, 1); 
     powerProbe->setOperation("integrate");
-    powerProbe->setInitialConditions(Vector(1, 0.0));
+    powerProbe->setInitialConditions(SimTK::Vector(1, 0.0));
     */
 
     //model->addProbe(powerProbe);
@@ -174,7 +173,7 @@ TEST_CASE("testTorqueActuator") {
 
     model->computeStateVariableDerivatives(state);
 
-    const Vector &udotTorqueActuator = state.getUDot();
+    const SimTK::Vector &udotTorqueActuator = state.getUDot();
 
     // First make sure that accelerations are not zero accidentally
     ASSERT(udotMobility.norm() != 0.0 || udotTorqueActuator.norm() != 0.0);
@@ -221,8 +220,6 @@ TEST_CASE("testTorqueActuator") {
 
 
 TEST_CASE("testClutchedPathSpring") {
-    using namespace SimTK;
-
     // start timing
     std::clock_t startTime = std::clock();
 
@@ -244,13 +241,13 @@ TEST_CASE("testClutchedPathSpring") {
     
     // body that acts as the pulley that the path wraps over
     OpenSim::Body* pulleyBody =
-        new OpenSim::Body("PulleyBody", mass ,Vec3(0),  mass*Inertia::brick(0.1, 0.1, 0.1));
+        new OpenSim::Body("PulleyBody", mass ,SimTK::Vec3(0),  mass*SimTK::Inertia::brick(0.1, 0.1, 0.1));
     
     // body the path spring is connected to at both ends
     OpenSim::Body* block =
-        new OpenSim::Body("block", mass ,Vec3(0),  mass*Inertia::brick(0.2, 0.1, 0.1));
-    block->attachGeometry(new Brick(Vec3(0.2, 0.1, 0.1)));
-    block->scale(Vec3(0.2, 0.1, 0.1), false);
+        new OpenSim::Body("block", mass ,SimTK::Vec3(0),  mass*SimTK::Inertia::brick(0.2, 0.1, 0.1));
+    block->attachGeometry(new Brick(SimTK::Vec3(0.2, 0.1, 0.1)));
+    block->scale(SimTK::Vec3(0.2, 0.1, 0.1), false);
 
     //double dh = mass*gravity_vec(1)/stiffness;
     
@@ -263,10 +260,10 @@ TEST_CASE("testClutchedPathSpring") {
 
     // Add joints
     WeldJoint* weld = 
-        new WeldJoint("weld", *ground, Vec3(0, 1.0, 0), Vec3(0), *pulleyBody, Vec3(0), Vec3(0));
+        new WeldJoint("weld", *ground, SimTK::Vec3(0, 1.0, 0), SimTK::Vec3(0), *pulleyBody, SimTK::Vec3(0), SimTK::Vec3(0));
     
     SliderJoint* slider =
-        new SliderJoint("slider", *ground, Vec3(0), Vec3(0,0,Pi/2),*block, Vec3(0), Vec3(0,0,Pi/2));
+        new SliderJoint("slider", *ground, SimTK::Vec3(0), SimTK::Vec3(0,0,SimTK::Pi/2),*block, SimTK::Vec3(0), SimTK::Vec3(0,0,SimTK::Pi/2));
 
     double positionRange[2] = {-10, 10};
     // Rename coordinates for a slider joint
@@ -282,19 +279,19 @@ TEST_CASE("testClutchedPathSpring") {
     ClutchedPathSpring* spring = 
         new ClutchedPathSpring("clutch_spring", stiffness, dissipation, 0.01);
 
-    spring->updGeometryPath().appendNewPathPoint("origin", *block, Vec3(-0.1, 0.0 ,0.0));
+    spring->updGeometryPath().appendNewPathPoint("origin", *block, SimTK::Vec3(-0.1, 0.0 ,0.0));
     
     int N = 10;
     for(int i=1; i<N; ++i){
-        double angle = i*Pi/N;
+        double angle = i*SimTK::Pi/N;
         double x = 0.1*cos(angle);
         double y = 0.1*sin(angle);
-        spring->updGeometryPath().appendNewPathPoint("", *pulleyBody, Vec3(-x, y ,0.0));
+        spring->updGeometryPath().appendNewPathPoint("", *pulleyBody, SimTK::Vec3(-x, y ,0.0));
     }
 
-    spring->updGeometryPath().appendNewPathPoint("insertion", *block, Vec3(0.1, 0.0 ,0.0));
+    spring->updGeometryPath().appendNewPathPoint("insertion", *block, SimTK::Vec3(0.1, 0.0 ,0.0));
 
-    // BUG in defining wrapping API requires that the Force containing the GeometryPath be
+    // BUG in defining wrapping API requires that the SimTK::Force containing the GeometryPath be
     // connected to the model before the wrap can be added
     model->addForce(spring);
 
@@ -326,7 +323,7 @@ TEST_CASE("testClutchedPathSpring") {
 
     CoordinateSet& coords = model->updCoordinateSet();
     coords[0].setValue(state, start_h);
-    model->getMultibodySystem().realize(state, Stage::Position );
+    model->getMultibodySystem().realize(state, SimTK::Stage::Position );
 
     //==========================================================================
     // Compute the force and torque at the specified times.
@@ -341,7 +338,7 @@ TEST_CASE("testClutchedPathSpring") {
     state = manager.integrate(final_t);
 
     // tension is dynamics dependent because controls must be computed
-    model->getMultibodySystem().realize(state, Stage::Dynamics);
+    model->getMultibodySystem().realize(state, SimTK::Stage::Dynamics);
 
     spring = dynamic_cast<ClutchedPathSpring*>(
                 &model->updForceSet().get("clutch_spring"));
@@ -362,7 +359,7 @@ TEST_CASE("testClutchedPathSpring") {
     state = manager.integrate(final_t);
 
     // tension is dynamics dependent because controls must be computed
-    model->getMultibodySystem().realize(state, Stage::Dynamics);
+    model->getMultibodySystem().realize(state, SimTK::Stage::Dynamics);
 
     // tension should go to zero quickly
     model_force = spring->getTension(state);
@@ -376,7 +373,7 @@ TEST_CASE("testClutchedPathSpring") {
     state = manager.integrate(final_t);
 
     // tension is dynamics dependent because controls must be computed
-    model->getMultibodySystem().realize(state, Stage::Dynamics);
+    model->getMultibodySystem().realize(state, SimTK::Stage::Dynamics);
 
     // tension should build to support the block again
     model_force = spring->getTension(state);
@@ -409,27 +406,25 @@ TEST_CASE("testMcKibbenActuator") {
     double pressure = 5 * 10e5; // 5 bars
     double num_turns = 1.5;     // 1.5 turns
     double B = 277.1 * 10e-4;  // 277.1 mm
-
-    using namespace SimTK;
     std::clock_t startTime = std::clock();
 
     double mass = 1;
     double ball_radius = 10e-6;
 
     Model *model = new Model;
-    model->setGravity(Vec3(0));
+    model->setGravity(SimTK::Vec3(0));
 
     Ground& ground = model->updGround();
 
     McKibbenActuator *actuator = new McKibbenActuator("mckibben", num_turns, B);
 
-    OpenSim::Body* ball = new OpenSim::Body("ball", mass, Vec3(0), mass*SimTK::Inertia::sphere(0.1));
-    ball->scale(Vec3(ball_radius), false);
+    OpenSim::Body* ball = new OpenSim::Body("ball", mass, SimTK::Vec3(0), mass*SimTK::Inertia::sphere(0.1));
+    ball->scale(SimTK::Vec3(ball_radius), false);
 
-    actuator->addNewPathPoint("mck_ground", ground, Vec3(0));
-    actuator->addNewPathPoint("mck_ball", *ball, Vec3(ball_radius));
+    actuator->addNewPathPoint("mck_ground", ground, SimTK::Vec3(0));
+    actuator->addNewPathPoint("mck_ball", *ball, SimTK::Vec3(ball_radius));
 
-    Vec3 locationInParent(0, ball_radius, 0), orientationInParent(0), locationInBody(0), orientationInBody(0);
+    SimTK::Vec3 locationInParent(0, ball_radius, 0), orientationInParent(0), locationInBody(0), orientationInBody(0);
     SliderJoint *ballToGround = new SliderJoint("ballToGround", ground, locationInParent, orientationInParent, *ball, locationInBody, orientationInBody);
 
     ballToGround->updCoordinate().setName("ball_d");
@@ -451,7 +446,7 @@ TEST_CASE("testMcKibbenActuator") {
 
     SimTK::State& si = model->initSystem();
 
-    model->getMultibodySystem().realize(si, Stage::Position);
+    model->getMultibodySystem().realize(si, SimTK::Stage::Position);
 
     double final_t = 10.0;
     double nsteps = 10;
@@ -464,8 +459,8 @@ TEST_CASE("testMcKibbenActuator") {
 
     for (int i = 1; i <= nsteps; i++) {
         si = manager.integrate(dt*i);
-        model->getMultibodySystem().realize(si, Stage::Velocity);
-        Vec3 pos = ball->findStationLocationInGround(si, Vec3(0));
+        model->getMultibodySystem().realize(si, SimTK::Stage::Velocity);
+        SimTK::Vec3 pos = ball->findStationLocationInGround(si, SimTK::Vec3(0));
 
         double applied = actuator->computeActuation(si);;
 
@@ -487,7 +482,6 @@ TEST_CASE("testMcKibbenActuator") {
 * @author Soha Pouya
 */
 TEST_CASE("testBodyActuator") {
-    using namespace SimTK;
     // start timing
     std::clock_t startTime = std::clock();
 
@@ -495,7 +489,7 @@ TEST_CASE("testBodyActuator") {
     Model *model = new Model;
 
     // turn off gravity
-    model->setGravity(Vec3(0));
+    model->setGravity(SimTK::Vec3(0));
 
     //OpenSim body 1: Ground
     const Ground& ground = model->getGround();
@@ -503,19 +497,19 @@ TEST_CASE("testBodyActuator") {
     // OpenSim body 2: A Block
     // Geometrical/Inertial properties for the block
     double blockMass = 1.0, blockSideLength = 1;
-    Vec3 blockMassCenter(0);
-    Inertia blockInertia = blockMass*Inertia::brick(blockSideLength/2,
+    SimTK::Vec3 blockMassCenter(0);
+    SimTK::Inertia blockInertia = blockMass*SimTK::Inertia::brick(blockSideLength/2,
         blockSideLength/2, blockSideLength/2); // for the halves see doxygen for brick 
 
     OpenSim::Body *block = new OpenSim::Body("block", blockMass, 
                                              blockMassCenter, blockInertia);
 
     // Add display geometry to the block to visualize in the GUI
-    block->attachGeometry(new Brick(Vec3(blockSideLength/2,
+    block->attachGeometry(new Brick(SimTK::Vec3(blockSideLength/2,
                                      blockSideLength/2, 
                                      blockSideLength/2)));
 
-    Vec3 locationInParent(0, blockSideLength / 2, 0), orientationInParent(0), 
+    SimTK::Vec3 locationInParent(0, blockSideLength / 2, 0), orientationInParent(0), 
         locationInBody(0), orientationInBody(0);
     FreeJoint *blockToGroundFree = new FreeJoint("blockToGroundBall", 
         ground, locationInParent, orientationInParent, 
@@ -526,40 +520,40 @@ TEST_CASE("testBodyActuator") {
     
     // specify magnitude and direction of applied force and torque
     double forceMag = 1.0;
-    Vec3 forceAxis(1, 1, 1);
-    Vec3 forceInG = forceMag * forceAxis;
+    SimTK::Vec3 forceAxis(1, 1, 1);
+    SimTK::Vec3 forceInG = forceMag * forceAxis;
 
     double torqueMag = 1.0;
-    Vec3 torqueAxis(1, 1, 1);
-    Vec3 torqueInG = torqueMag*torqueAxis;
+    SimTK::Vec3 torqueAxis(1, 1, 1);
+    SimTK::Vec3 torqueInG = torqueMag*torqueAxis;
 
     // ---------------------------------------------------------------------------
     // Use MobilityForces to Apply the given Torques and Forces to the body
     // ---------------------------------------------------------------------------
-    State& state = model->initSystem();
+    SimTK::State& state = model->initSystem();
 
-    model->getMultibodySystem().realize(state, Stage::Dynamics);
-    Vector_<SpatialVec>& bodyForces =
-        model->getMultibodySystem().updRigidBodyForces(state, Stage::Dynamics);
-    bodyForces.dump("Body Forces before applying 6D spatial force:");
+    model->getMultibodySystem().realize(state, SimTK::Stage::Dynamics);
+    SimTK::Vector_<SimTK::SpatialVec>& bodyForces =
+        model->getMultibodySystem().updRigidBodyForces(state, SimTK::Stage::Dynamics);
+    bodyForces.dump("SimTK::Body Forces before applying 6D spatial force:");
 
     model->getMatterSubsystem().addInBodyTorque(state, block->getMobilizedBodyIndex(),
         torqueInG, bodyForces);
     model->getMatterSubsystem().addInStationForce(state, block->getMobilizedBodyIndex(),
-        Vec3(0), forceInG, bodyForces);
+        SimTK::Vec3(0), forceInG, bodyForces);
 
-    bodyForces.dump("Body Forces after applying 6D spatial force to the block");
+    bodyForces.dump("SimTK::Body Forces after applying 6D spatial force to the block");
 
-    model->getMultibodySystem().realize(state, Stage::Acceleration);
-    Vector udotBody = state.getUDot();
+    model->getMultibodySystem().realize(state, SimTK::Stage::Acceleration);
+    SimTK::Vector udotBody = state.getUDot();
     udotBody.dump("Accelerations due to body forces");
 
     // clear body forces
     bodyForces *= 0;
 
     // update mobility forces
-    Vector& mobilityForces = model->getMultibodySystem()
-        .updMobilityForces(state, Stage::Dynamics);
+    SimTK::Vector& mobilityForces = model->getMultibodySystem()
+        .updMobilityForces(state, SimTK::Stage::Dynamics);
 
     // Apply torques as mobility forces of the ball joint
     for (int i = 0; i<3; ++i){
@@ -569,8 +563,8 @@ TEST_CASE("testBodyActuator") {
     mobilityForces.dump("Mobility Forces after applying 6D spatial force to the block");
 
 
-    model->getMultibodySystem().realize(state, Stage::Acceleration);
-    Vector udotMobility = state.getUDot();
+    model->getMultibodySystem().realize(state, SimTK::Stage::Acceleration);
+    SimTK::Vector udotMobility = state.getUDot();
     udotMobility.dump("Accelerations due to mobility forces");
 
     // First make sure that accelerations are not zero accidentally
@@ -594,16 +588,16 @@ TEST_CASE("testBodyActuator") {
     model->setUseVisualizer(false);
 
     // get a new system and state to reflect additions to the model
-    State& state1 = model->initSystem();
+    SimTK::State& state1 = model->initSystem();
 
     model->print("TestBodyActuatorModel.osim");
 
     // -------------- Provide control signals for bodyActuator ----------
     // Get the default control vector of the model
-    Vector modelControls = model->getDefaultControls();
+    SimTK::Vector modelControls = model->getDefaultControls();
     
     // Specify a vector of control signals to include desired torques and forces
-    Vector fixedControls(6);
+    SimTK::Vector fixedControls(6);
     for (int i = 0; i < 3; i++){
         fixedControls(i) = torqueInG(i);
         fixedControls(i + 3) = forceInG(i);
@@ -618,7 +612,7 @@ TEST_CASE("testBodyActuator") {
     // Compute the acc due to spatial forces applied by body actuator
     model->computeStateVariableDerivatives(state1);
 
-    Vector udotBodyActuator = state1.getUDot();
+    SimTK::Vector udotBodyActuator = state1.getUDot();
     udotBodyActuator.dump("Accelerations due to body actuator");
 
     // First make sure that accelerations are not zero accidentally
@@ -663,7 +657,6 @@ TEST_CASE("testBodyActuator") {
 * @author Soha Pouya
 */
 TEST_CASE("testActuatorsCombination") {
-    using namespace SimTK;
     // start timing
     std::clock_t startTime = std::clock();
 
@@ -671,7 +664,7 @@ TEST_CASE("testActuatorsCombination") {
     Model *model = new Model;
 
     // turn off gravity
-    model->setGravity(Vec3(0));
+    model->setGravity(SimTK::Vec3(0));
 
     // OpenSim bodies: 1) The ground
     const Ground& ground = model->getGround();
@@ -680,9 +673,9 @@ TEST_CASE("testActuatorsCombination") {
     // OpenSim bodies: 2) A Block
     // Geometrical/Inertial properties for the block
     double blockMass = 1.0, blockSideLength = 1.0;
-    Vec3 blockMassCenter(0);
-    // Brick Inertia: for the halves see doxygen  
-    Inertia blockInertia = blockMass*Inertia::brick(blockSideLength/2, 
+    SimTK::Vec3 blockMassCenter(0);
+    // Brick SimTK::Inertia: for the halves see doxygen  
+    SimTK::Inertia blockInertia = blockMass*SimTK::Inertia::brick(blockSideLength/2, 
                                     blockSideLength/2, blockSideLength/2);
     std::cout << "blockInertia: " << blockInertia << std::endl;
 
@@ -690,12 +683,12 @@ TEST_CASE("testActuatorsCombination") {
                                     blockMassCenter, blockInertia);
 
     // Add display geometry to the block to visualize in the GUI
-    block->attachGeometry(new Brick(Vec3(blockSideLength/2, 
+    block->attachGeometry(new Brick(SimTK::Vec3(blockSideLength/2, 
                                      blockSideLength/2, 
                                      blockSideLength/2)));
 
     // Make a FreeJoint from block to ground
-    Vec3 locationInParent(0, blockSideLength/2, 0), orientationInParent(0), //locationInParent(0, blockSideLength, 0)
+    SimTK::Vec3 locationInParent(0, blockSideLength/2, 0), orientationInParent(0), //locationInParent(0, blockSideLength, 0)
          locationInBody(0), orientationInBody(0);
     FreeJoint *blockToGroundFree = new FreeJoint("blockToGroundFreeJoint", 
                 ground, locationInParent, orientationInParent, 
@@ -707,17 +700,17 @@ TEST_CASE("testActuatorsCombination") {
 
     // specify magnitude and direction of desired force and torque vectors to apply
     double forceMag = 1.0;
-    Vec3 forceAxis(1, 1, 1);
+    SimTK::Vec3 forceAxis(1, 1, 1);
     SimTK::UnitVec3 forceUnitAxis(forceAxis); // to normalize
-    Vec3 forceInG = forceMag * forceUnitAxis;
+    SimTK::Vec3 forceInG = forceMag * forceUnitAxis;
 
     double torqueMag = 1.0;
-    Vec3 torqueAxis(1, 2, 1);
+    SimTK::Vec3 torqueAxis(1, 2, 1);
     SimTK::UnitVec3 torqueUnitAxis(torqueAxis); // to normalize
-    Vec3 torqueInG = torqueMag*torqueUnitAxis;
+    SimTK::Vec3 torqueInG = torqueMag*torqueUnitAxis;
 
     // needed to be called here once to build controller for body actuator
-    /*State& state = */model->initSystem();
+    /*SimTK::State& state = */model->initSystem();
     
     // ---------------------------------------------------------------------------
     // Add a set of PointActuator, TorqueActuator and BodyActuator to the model
@@ -725,7 +718,7 @@ TEST_CASE("testActuatorsCombination") {
     // Create and add a body actuator to the model
     BodyActuator* bodyActuator1 = new BodyActuator(*block);
     bodyActuator1->setName("BodyAct1");
-    bodyActuator1->set_point(Vec3(0, blockSideLength/2, 0));
+    bodyActuator1->set_point(SimTK::Vec3(0, blockSideLength/2, 0));
     model->addForce(bodyActuator1);
     
     // Create and add a torque actuator to the model
@@ -739,7 +732,7 @@ TEST_CASE("testActuatorsCombination") {
         new PointActuator("block");
     pointActuator->setName("pointAct");
     pointActuator->set_direction(forceUnitAxis);
-    pointActuator->set_point(Vec3(0, blockSideLength/2,0));
+    pointActuator->set_point(SimTK::Vec3(0, blockSideLength/2,0));
     model->addForce(pointActuator);
     model->finalizeConnections(); // Needed so sockets have correct path
     // ------ build the model -----
@@ -747,29 +740,29 @@ TEST_CASE("testActuatorsCombination") {
     model->setUseVisualizer(false);
 
     // get a new system and state to reflect additions to the model
-    State& state1 = model->initSystem();
+    SimTK::State& state1 = model->initSystem();
 
     // ------------------- Provide control signals for bodyActuator ----------------
     // Get the default control vector of the model
-    Vector modelControls = model->getDefaultControls();
+    SimTK::Vector modelControls = model->getDefaultControls();
 
     // Specify a vector of control signals for desired torques and forces
-    Vector bodyActuator1Controls(6,0.0); 
+    SimTK::Vector bodyActuator1Controls(6,0.0); 
     for (int i=0; i<3; i++) bodyActuator1Controls(i) = torqueInG(i); // torque in 3 axes
     for (int i=0; i<3; i++) bodyActuator1Controls(i+3) = forceInG(i); // force along 3 axes
     
     
-    bodyActuator1Controls.dump("Spatial forces applied by first Body Actuator:");
+    bodyActuator1Controls.dump("Spatial forces applied by first SimTK::Body Actuator:");
 
     // Add control values and set their values
     bodyActuator1->addInControls(bodyActuator1Controls, modelControls);
     model->setDefaultControls(modelControls);
 
     // ---------------- Provide control signals for torqueActuator -----------------
-    Vector torqueActuatorControls(1); // input to addInControl should be a Vector
+    SimTK::Vector torqueActuatorControls(1); // input to addInControl should be a SimTK::Vector
     torqueActuatorControls(0) = torqueMag; // axis already defined when initializing 
 
-    Vector torqueActuatorVector(3); // to print out the 3D vector of applied torque
+    SimTK::Vector torqueActuatorVector(3); // to print out the 3D vector of applied torque
     for (int i = 0; i < 3; i++){
         torqueActuatorVector(i) = torqueInG(i);
     }
@@ -780,10 +773,10 @@ TEST_CASE("testActuatorsCombination") {
     model->setDefaultControls(modelControls);
 
     // ------------------ Provide control signals for pointActuator ----------------
-    Vector pointActuatorControls(1); // input to addInControl should be a Vector
+    SimTK::Vector pointActuatorControls(1); // input to addInControl should be a SimTK::Vector
     pointActuatorControls(0) = forceMag; // axis already defined when initializing
 
-    Vector pointActuatorVector(3); // to print out the whole force vector
+    SimTK::Vector pointActuatorVector(3); // to print out the whole force vector
     for (int i = 0; i < 3; i++){
         pointActuatorVector(i) = forceInG(i);
     }
@@ -798,7 +791,7 @@ TEST_CASE("testActuatorsCombination") {
     // compare the acc due to forces/torques applied by all actuator
     model->computeStateVariableDerivatives(state1);
 
-    Vector udotActuatorsCombination = state1.getUDot();
+    SimTK::Vector udotActuatorsCombination = state1.getUDot();
     udotActuatorsCombination.dump("Accelerations due to all 3 actuators");
 
 
@@ -809,17 +802,17 @@ TEST_CASE("testActuatorsCombination") {
     BodyActuator* bodyActuator_sum = new BodyActuator(*block);
     bodyActuator_sum->setName("BodyAct_Sum");
     model->addForce(bodyActuator_sum);
-    bodyActuator_sum->set_point(Vec3(0, blockSideLength / 2, 0));
+    bodyActuator_sum->set_point(SimTK::Vec3(0, blockSideLength / 2, 0));
 
 
-    State& state2 = model->initSystem();
+    SimTK::State& state2 = model->initSystem();
     model->setUseVisualizer(true);
 
     // Get the default control vector of the model
-    Vector modelControls_2 = model->getDefaultControls();
+    SimTK::Vector modelControls_2 = model->getDefaultControls();
 
     // Specify a vector of control signals for desired torques and forces
-    Vector bodyActuatorSum_Controls(6,0.0);
+    SimTK::Vector bodyActuatorSum_Controls(6,0.0);
 
     // make the torque component as the sum of body, torque and point actuators used 
     // in previous test case
@@ -828,7 +821,7 @@ TEST_CASE("testActuatorsCombination") {
         bodyActuatorSum_Controls(i+3) = 2*forceInG(i);
     }   
 
-    bodyActuatorSum_Controls.dump("Spatial forces applied by 2nd Body Actuator:");
+    bodyActuatorSum_Controls.dump("Spatial forces applied by 2nd SimTK::Body Actuator:");
     std::cout <<"(encloses sum of the above spatial forces in one BodyActuator)"<< std::endl;
 
     // Add control values and set their values
@@ -839,7 +832,7 @@ TEST_CASE("testActuatorsCombination") {
     // now compare the acc due to forces/torques applied by this body actuator
     model->computeStateVariableDerivatives(state2);
 
-    Vector udotOnlyBodyActuator = state2.getUDot();
+    SimTK::Vector udotOnlyBodyActuator = state2.getUDot();
     udotOnlyBodyActuator.dump("Accelerations due to only-one body actuator");
 
     // Verify that the bodyActuator_sum also generates the same acceleration
@@ -868,7 +861,7 @@ TEST_CASE("testActuatorsCombination") {
 // ActivationCoordinateActautor.
 TEST_CASE("testActivationCoordinateActuator") {
     Model model;
-    auto* body = new Body("body", 1, SimTK::Vec3(0), SimTK::Inertia(1.0));
+    auto* body = new SimTK::Body("body", 1, SimTK::Vec3(0), SimTK::Inertia(1.0));
     auto* joint = new PinJoint("joint", *body, model.getGround());
     joint->updCoordinate().setName("coord");
     model.addBody(body);
@@ -905,4 +898,4 @@ TEST_CASE("testActivationCoordinateActuator") {
     const double foundFinalActivation =
             aca->getStateVariableValue(state, "activation");
     ASSERT_EQUAL(expectedFinalActivation, foundFinalActivation, 1e-4);
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Actuators/Test/testMuscleFirstOrderActivationDynamicModel.cpp b/OpenSim/Actuators/Test/testMuscleFirstOrderActivationDynamicModel.cpp
index 02c42701a..0e7217a79 100644
--- a/OpenSim/Actuators/Test/testMuscleFirstOrderActivationDynamicModel.cpp
+++ b/OpenSim/Actuators/Test/testMuscleFirstOrderActivationDynamicModel.cpp
@@ -32,8 +32,6 @@
 
 using namespace std;
 using namespace OpenSim;
-using namespace SimTK;
-
 namespace {
 
     /**
@@ -219,7 +217,7 @@ namespace {
     };
 
     /**
-    This is the nice user interface class to MySystemGuts, which creates a System
+    This is the nice user interface class to MySystemGuts, which creates a SimTK::System
     object that is required to use SimTK's integrators to integrate the Bezier
     curve sets
     */
@@ -230,7 +228,7 @@ namespace {
     by the function calcNumIntBezierYfcnX, which evaluates the numerical integral
     of a Bezier curve set.
 
-    A System is actually two classes: System::Guts does the work while System
+    A SimTK::System is actually two classes: SimTK::System::Guts does the work while SimTK::System
     provides a pleasant veneer to make usage easier. This is the workhorse
     */
     class MySystemGuts : public SimTK::System::Guts {
@@ -238,21 +236,21 @@ namespace {
 
         MySystemGuts(const FunctionData afuncData) : funcData(afuncData) {}
 
-        // Implement required System::Guts virtuals.
+        // Implement required SimTK::System::Guts virtuals.
         MySystemGuts* cloneImpl() const override {return new MySystemGuts(*this);}
 
-        // During realizeTopology() we allocate the needed State.
-        int realizeTopologyImpl(State& state) const override {
+        // During realizeTopology() we allocate the needed SimTK::State.
+        int realizeTopologyImpl(SimTK::State& state) const override {
             // HERE'S WHERE THE IC GETS SET
-            Vector zInit(1, funcData.m_ic); // initial value for z
-            state.allocateZ(SubsystemIndex(0), zInit);
+            SimTK::Vector zInit(1, funcData.m_ic); // initial value for z
+            state.allocateZ(SimTK::SubsystemIndex(0), zInit);
             return 0;
         }
 
-        // During realizeAcceleration() we calculate the State derivative.
-        int realizeAccelerationImpl(const State& state) const override {
-            Real x = state.getTime();
-            Real z = state.getZ()[0];
+        // During realizeAcceleration() we calculate the SimTK::State derivative.
+        int realizeAccelerationImpl(const SimTK::State& state) const override {
+            SimTK::Real x = state.getTime();
+            SimTK::Real z = state.getZ()[0];
 
             //if(z>funcData.m_ic+SimTK::Eps)
             //    printf("z: %f",z);
@@ -268,7 +266,7 @@ namespace {
             funcData.m_tmpXV(funcData.m_intDim) = z;
 
             //Compute the function derivative at the location of interest
-            Real dz = funcData.m_func.calcDerivative(funcData.m_tmpXV[0], funcData.m_tmpXV[1]);
+            SimTK::Real dz = funcData.m_func.calcDerivative(funcData.m_tmpXV[0], funcData.m_tmpXV[1]);
             //if(z>funcData.m_ic+SimTK::Eps)
             //    printf(" dz: %f\n",dz);
 
@@ -278,9 +276,9 @@ namespace {
 
         // Disable prescribe and project since we have no constraints or
         // prescribed state variables to worry about.
-        int prescribeImpl(State&, Stage) const {return 0;}
-        int projectImpl(State&, Real, const Vector&, const Vector&,
-                Vector&, SimTK::ProjectOptions) const {return 0;}
+        int prescribeImpl(SimTK::State&, SimTK::Stage) const {return 0;}
+        int projectImpl(SimTK::State&, SimTK::Real, const SimTK::Vector&, const SimTK::Vector&,
+                SimTK::Vector&, SimTK::ProjectOptions) const {return 0;}
     private:
         /**The Bezier curve data that is being integrated*/
         const FunctionData funcData;
@@ -288,15 +286,15 @@ namespace {
 
     /**
     This is the implementation of the nice user interface class to MySystemGuts,
-    which creates a System object that is required to use SimTK's integrators to
+    which creates a SimTK::System object that is required to use SimTK's integrators to
     integrate the Bezier curve sets. Used in function
     SegmentedQuinticBezierToolkit::calcNumIntBezierYfcnX
     */
-    class MySystem : public System {
+    class MySystem : public SimTK::System {
     public:
         MySystem(const FunctionData& funcData) {
             adoptSystemGuts(new MySystemGuts(funcData));
-            DefaultSystemSubsystem defsub(*this);
+            SimTK::DefaultSystemSubsystem defsub(*this);
         }
     };
 
@@ -334,7 +332,7 @@ namespace {
         //Now spline xM over time
         for(int i=0; i<xM.ncol(); i++){
 
-            splinedInput[i] = SimTK::SplineFitter<Real>::
+            splinedInput[i] = SimTK::SplineFitter<SimTK::Real>::
                 fitForSmoothingParameter(1,timeV,xM(i),0).getSpline();
         }
         fdata.m_splinedInput = splinedInput;
@@ -345,11 +343,11 @@ namespace {
         //double startTime = timeV(0);
         //double endTime   = timeV(timeV.nelt()-1);
         MySystem sys(fdata);
-        State initState = sys.realizeTopology();
+        SimTK::State initState = sys.realizeTopology();
         initState.setTime(startTime);
 
 
-        RungeKuttaMersonIntegrator integ(sys);
+        SimTK::RungeKuttaMersonIntegrator integ(sys);
         integ.setAccuracy(intAcc);
         integ.setFinalTime(endTime);
         integ.setReturnEveryInternalStep(false);
@@ -357,7 +355,7 @@ namespace {
 
         int idx = 0;
         double nextTimeInterval = 0;
-        Integrator::SuccessfulStepStatus status;
+        SimTK::Integrator::SuccessfulStepStatus status;
 
         while (idx < timeV.nelt()) {
             nextTimeInterval = timeV(idx);
@@ -365,12 +363,12 @@ namespace {
             status=integ.stepTo(nextTimeInterval);
 
             // Use this for variable step output.
-            //status = integ.stepTo(Infinity);
+            //status = integ.stepTo(SimTK::Infinity);
 
-            if (status == Integrator::EndOfSimulation)
+            if (status == SimTK::Integrator::EndOfSimulation)
                 break;
 
-            const State& state = integ.getState();
+            const SimTK::State& state = integ.getState();
 
             intXY(idx,0) = nextTimeInterval;
             intXY(idx,1) = (double)state.getZ()[0];
@@ -632,4 +630,4 @@ TEST_CASE("Test MuscleFirstOrderDynamicModel") {
                    "function and "
                 << "the maximum difference in slope of " << maxDxDiff << ".");
     }
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Actuators/Test/testSerializableMuscleCurves.cpp b/OpenSim/Actuators/Test/testSerializableMuscleCurves.cpp
index ab01c010a..509c2469c 100644
--- a/OpenSim/Actuators/Test/testSerializableMuscleCurves.cpp
+++ b/OpenSim/Actuators/Test/testSerializableMuscleCurves.cpp
@@ -37,9 +37,6 @@
 
 using namespace std;
 using namespace OpenSim;
-using namespace SimTK;
-
-
 TEST_CASE("testActiveForceLengthCurve")
 {
 
diff --git a/OpenSim/Common/AbstractDataTable.cpp b/OpenSim/Common/AbstractDataTable.cpp
index 98a02235c..000aef1d9 100644
--- a/OpenSim/Common/AbstractDataTable.cpp
+++ b/OpenSim/Common/AbstractDataTable.cpp
@@ -126,7 +126,6 @@ AbstractDataTable::setColumnLabels(const std::initializer_list<std::string>&
 void 
 AbstractDataTable::setColumnLabel(const size_t columnIndex,
                                   const std::string& columnLabel) {
-    using namespace SimTK;
     using namespace std;
 
     OPENSIM_THROW_IF(!hasColumnLabels(), NoColumnLabels);
@@ -187,4 +186,4 @@ AbstractDataTable::appendColumnLabel(const std::string& columnLabel) {
     validateDependentsMetaData();
 }
 
-} // namespace OpenSim
+} // namespace OpenSim
\ No newline at end of file
diff --git a/OpenSim/Common/AbstractProperty.cpp b/OpenSim/Common/AbstractProperty.cpp
index c22841dc7..6c610ba63 100644
--- a/OpenSim/Common/AbstractProperty.cpp
+++ b/OpenSim/Common/AbstractProperty.cpp
@@ -34,7 +34,6 @@
 #include <utility>
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 namespace
@@ -128,7 +127,7 @@ void AbstractProperty::setAllPropertiesUseDefault(bool shouldUseDefault) {
 // Implement the policy that locates a property value's element within its 
 // parent element and then ask the concrete property to deserialize itself from
 // that element.
-void AbstractProperty::readFromXMLParentElement(Xml::Element& parent,
+void AbstractProperty::readFromXMLParentElement(SimTK::Xml::Element& parent,
                                                 int           versionNumber)
 {
     // If this property has a real name (that is, doesn't use the object type
@@ -136,7 +135,7 @@ void AbstractProperty::readFromXMLParentElement(Xml::Element& parent,
     // that name and read it if found. That is, we're looking for
     //      <propName> ... </propName>
     if (!isUnnamedProperty()) {
-        Xml::element_iterator propElt = parent.element_begin(getName());
+        SimTK::Xml::element_iterator propElt = parent.element_begin(getName());
         if (propElt != parent.element_end()) {
             readFromXMLElement(*propElt, versionNumber);
             setValueIsDefault(false);
@@ -182,8 +181,8 @@ void AbstractProperty::readFromXMLParentElement(Xml::Element& parent,
     //     </Unnamed>
     // and then delegate to the concrete property the job of reading in the
     // property value.
-    Xml::element_iterator prev = parent.element_end();
-    Xml::element_iterator iter = parent.element_begin();
+    SimTK::Xml::element_iterator prev = parent.element_end();
+    SimTK::Xml::element_iterator iter = parent.element_begin();
     if (isUnnamedProperty()) {
         for (; iter != parent.element_end(); prev=iter++) 
             if (isAcceptableObjectTag(iter->getElementTag()))
@@ -224,7 +223,7 @@ void AbstractProperty::readFromXMLParentElement(Xml::Element& parent,
     // Found a match. Borrow the object node briefly and canonicalize it 
     // into a conventional <propName> object </propName> structure.
     std::string propName = isUnnamedProperty() ? "Unnamed" : getName();
-    Xml::Element dummy(propName);
+    SimTK::Xml::Element dummy(propName);
     dummy.insertNodeAfter(dummy.node_end(), parent.removeNode(iter));
     parent.insertNodeAfter(parent.node_end(), dummy);
 
@@ -238,16 +237,16 @@ void AbstractProperty::readFromXMLParentElement(Xml::Element& parent,
 }
 
 
-void AbstractProperty::writeToXMLParentElement(Xml::Element& parent) const {
+void AbstractProperty::writeToXMLParentElement(SimTK::Xml::Element& parent) const {
     // Add comment if any.
     if (!getComment().empty())
-        parent.insertNodeAfter(parent.node_end(), Xml::Comment(getComment()));
+        parent.insertNodeAfter(parent.node_end(), SimTK::Xml::Comment(getComment()));
 
     if (!isOneObjectProperty()) {
         // Concrete property will be represented by an Xml element of
         // the form <propName> value(s) </propName>.
         OPENSIM_ASSERT(!getName().empty());
-        Xml::Element propElement(getName());
+        SimTK::Xml::Element propElement(getName());
         writeToXMLElement(propElement);
         parent.insertNodeAfter(parent.node_end(), propElement);
         return;
@@ -265,5 +264,4 @@ void AbstractProperty::writeToXMLParentElement(Xml::Element& parent) const {
     // If this is a named property then the lone object must have its
     // name attribute set to the property name.
     obj.updateXMLNode(parent, this);
-}
-
+}
\ No newline at end of file
diff --git a/OpenSim/Common/FunctionAdapter.cpp b/OpenSim/Common/FunctionAdapter.cpp
index ebdcbe408..b3174b775 100644
--- a/OpenSim/Common/FunctionAdapter.cpp
+++ b/OpenSim/Common/FunctionAdapter.cpp
@@ -29,8 +29,6 @@
 // STATICS
 //=============================================================================
 using namespace OpenSim;
-using namespace SimTK;
-
 //=============================================================================
 // CONSTRUCTOR(S) AND DESTRUCTOR
 //=============================================================================
@@ -44,10 +42,10 @@ FunctionAdapter::FunctionAdapter(const OpenSim::Function& aFunction) : _function
 //=============================================================================
 // SimTK::Function METHODS
 //=============================================================================
-double FunctionAdapter::calcValue(const Vector& x) const {
+double FunctionAdapter::calcValue(const SimTK::Vector& x) const {
     return _function.calcValue(x);
 }
-double FunctionAdapter::calcDerivative(const std::vector<int>& derivComponents, const Vector& x) const {
+double FunctionAdapter::calcDerivative(const std::vector<int>& derivComponents, const SimTK::Vector& x) const {
     return _function.calcDerivative(derivComponents, x);
 }
 
@@ -61,5 +59,4 @@ int FunctionAdapter::getArgumentSize() const {
 }
 int FunctionAdapter::getMaxDerivativeOrder() const {
     return _function.getMaxDerivativeOrder();
-}
-
+}
\ No newline at end of file
diff --git a/OpenSim/Common/Property.cpp b/OpenSim/Common/Property.cpp
index a648b0f98..5bf9ee72f 100644
--- a/OpenSim/Common/Property.cpp
+++ b/OpenSim/Common/Property.cpp
@@ -29,7 +29,6 @@
 
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 //=============================================================================
@@ -37,7 +36,7 @@ using namespace std;
 //=============================================================================
 
 // Doubles compare equal if they are close enough, and they compare equal
-// if they are both NaN. Vec3, Vector, and Array<double> properties must all
+// if they are both SimTK::NaN. SimTK::Vec3, SimTK::Vector, and Array<double> properties must all
 // be implemented in terms of this method.
 bool Property<double>::TypeHelper::
 isEqual(double a, double b) {
@@ -45,7 +44,7 @@ isEqual(double a, double b) {
         return true; // catch exact match and Infinities
 
     if (SimTK::isNaN(a) && SimTK::isNaN(b))
-        return true; // we define NaN==NaN to be true here
+        return true; // we define SimTK::NaN==SimTK::NaN to be true here
 
     // Floating point need only match to a tolerance.
     // TODO: why is this the right number??
@@ -111,4 +110,4 @@ template class SimpleProperty<int>;
 template class SimpleProperty<double>;
 template class SimpleProperty<std::string>;
 template class ObjectProperty<Object>;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Common/Reporter.cpp b/OpenSim/Common/Reporter.cpp
index 381a0de0f..0ba301213 100644
--- a/OpenSim/Common/Reporter.cpp
+++ b/OpenSim/Common/Reporter.cpp
@@ -23,20 +23,17 @@
 
 #include "Reporter.h"
 #include <OpenSim/Common/TimeSeriesTable.h>
-
-using namespace SimTK;
-
 namespace OpenSim {
 
 class OutputPeriodicReporter : public SimTK::PeriodicEventReporter {
 public:
     OutputPeriodicReporter(const AbstractReporter& owner,
-        const MultibodySystem& system,
-        const Real reportInterval) : PeriodicEventReporter(reportInterval), 
+        const SimTK::MultibodySystem& system,
+        const SimTK::Real reportInterval) : PeriodicEventReporter(reportInterval), 
         _owner(owner), _system(system) {
     }
 
-    void handleEvent(const State& state) const override {
+    void handleEvent(const SimTK::State& state) const override {
         // This should be triggered every (interval) time units.
         SimTK_ASSERT(state.getTime() == getNextEventTime(state, true),
             "Reporter did not report at specified time interval.");
@@ -50,7 +47,7 @@ public:
 
 private:
     const AbstractReporter& _owner;
-    const MultibodySystem& _system;
+    const SimTK::MultibodySystem& _system;
 };
 
 //=============================================================================
@@ -119,4 +116,4 @@ void AbstractReporter::report(const SimTK::State& s) const
 }
 
 
-} // end of namespace OpenSim
+} // end of namespace OpenSim
\ No newline at end of file
diff --git a/OpenSim/Common/STOFileAdapter.cpp b/OpenSim/Common/STOFileAdapter.cpp
index 1abdc81c4..426dc09eb 100644
--- a/OpenSim/Common/STOFileAdapter.cpp
+++ b/OpenSim/Common/STOFileAdapter.cpp
@@ -40,38 +40,36 @@ createSTOFileAdapterForReading(const std::string& fileName) {
             if(!key.empty() && 
                !value.empty() &&
                key.find("DataType") != std::string::npos) {
-                using namespace SimTK;
-
                 if(value == "double")
                     return std::make_shared<STOFileAdapter_<double>>();
-                else if(value == "Vec2")
-                    return std::make_shared<STOFileAdapter_<Vec2>>();
-                else if(value == "Vec3")
-                    return std::make_shared<STOFileAdapter_<Vec3>>();
-                else if(value == "Vec4")
-                    return std::make_shared<STOFileAdapter_<Vec4>>();
-                else if(value == "Vec5")
-                    return std::make_shared<STOFileAdapter_<Vec5>>();
-                else if(value == "Vec6")
-                    return std::make_shared<STOFileAdapter_<Vec6>>();
-                else if(value == "Vec7")
-                    return std::make_shared<STOFileAdapter_<Vec7>>();
-                else if(value == "Vec8")
-                    return std::make_shared<STOFileAdapter_<Vec8>>();
-                else if(value == "Vec9")
-                    return std::make_shared<STOFileAdapter_<Vec9>>();
+                else if(value == "SimTK::Vec2")
+                    return std::make_shared<STOFileAdapter_<SimTK::Vec2>>();
+                else if(value == "SimTK::Vec3")
+                    return std::make_shared<STOFileAdapter_<SimTK::Vec3>>();
+                else if(value == "SimTK::Vec4")
+                    return std::make_shared<STOFileAdapter_<SimTK::Vec4>>();
+                else if(value == "SimTK::Vec5")
+                    return std::make_shared<STOFileAdapter_<SimTK::Vec5>>();
+                else if(value == "SimTK::Vec6")
+                    return std::make_shared<STOFileAdapter_<SimTK::Vec6>>();
+                else if(value == "SimTK::Vec7")
+                    return std::make_shared<STOFileAdapter_<SimTK::Vec7>>();
+                else if(value == "SimTK::Vec8")
+                    return std::make_shared<STOFileAdapter_<SimTK::Vec8>>();
+                else if(value == "SimTK::Vec9")
+                    return std::make_shared<STOFileAdapter_<SimTK::Vec9>>();
                 else if(value == "Vec10")
-                    return std::make_shared<STOFileAdapter_<Vec<10>>>();
+                    return std::make_shared<STOFileAdapter_<SimTK::Vec<10>>>();
                 else if(value == "Vec11")
-                    return std::make_shared<STOFileAdapter_<Vec<11>>>();
+                    return std::make_shared<STOFileAdapter_<SimTK::Vec<11>>>();
                 else if(value == "Vec12")
-                    return std::make_shared<STOFileAdapter_<Vec<12>>>();
-                else if(value == "UnitVec3")
-                    return std::make_shared<STOFileAdapter_<UnitVec3>>();
-                else if(value == "Quaternion")
-                    return std::make_shared<STOFileAdapter_<Quaternion>>();
-                else if(value == "SpatialVec")
-                    return std::make_shared<STOFileAdapter_<SpatialVec>>();
+                    return std::make_shared<STOFileAdapter_<SimTK::Vec<12>>>();
+                else if(value == "SimTK::UnitVec3")
+                    return std::make_shared<STOFileAdapter_<SimTK::UnitVec3>>();
+                else if(value == "SimTK::Quaternion")
+                    return std::make_shared<STOFileAdapter_<SimTK::Quaternion>>();
+                else if(value == "SimTK::SpatialVec")
+                    return std::make_shared<STOFileAdapter_<SimTK::SpatialVec>>();
                 else {
                     OPENSIM_THROW(STODataTypeNotSupported,
                                   value);
@@ -96,30 +94,28 @@ makeAdapter(const AbstractDataTable* absTable) {
 
 std::shared_ptr<DataAdapter>
 createSTOFileAdapterForWriting(const DataAdapter::InputTables& absTables) {
-    using namespace SimTK;
-
     auto* absTable = absTables.at("table");
 
     // Try derived class before base class.
     
-    if (auto adapter = makeAdapter<UnitVec3>(absTable)) return adapter;
-    if (auto adapter = makeAdapter<Quaternion>(absTable)) return adapter;
-    if (auto adapter = makeAdapter<SpatialVec>(absTable)) return adapter;
+    if (auto adapter = makeAdapter<SimTK::UnitVec3>(absTable)) return adapter;
+    if (auto adapter = makeAdapter<SimTK::Quaternion>(absTable)) return adapter;
+    if (auto adapter = makeAdapter<SimTK::SpatialVec>(absTable)) return adapter;
     if (auto adapter = makeAdapter<double>(absTable)) return adapter;
-    if (auto adapter = makeAdapter<Vec2>(absTable)) return adapter;
-    if (auto adapter = makeAdapter<Vec3>(absTable)) return adapter;
-    if (auto adapter = makeAdapter<Vec4>(absTable)) return adapter;
-    if (auto adapter = makeAdapter<Vec5>(absTable)) return adapter;
-    if (auto adapter = makeAdapter<Vec6>(absTable)) return adapter;
-    if (auto adapter = makeAdapter<Vec7>(absTable)) return adapter;
-    if (auto adapter = makeAdapter<Vec8>(absTable)) return adapter;
-    if (auto adapter = makeAdapter<Vec9>(absTable)) return adapter;
-    if (auto adapter = makeAdapter<Vec<10>>(absTable)) return adapter;
-    if (auto adapter = makeAdapter<Vec<11>>(absTable)) return adapter;
-    if (auto adapter = makeAdapter<Vec<12>>(absTable)) return adapter;
+    if (auto adapter = makeAdapter<SimTK::Vec2>(absTable)) return adapter;
+    if (auto adapter = makeAdapter<SimTK::Vec3>(absTable)) return adapter;
+    if (auto adapter = makeAdapter<SimTK::Vec4>(absTable)) return adapter;
+    if (auto adapter = makeAdapter<SimTK::Vec5>(absTable)) return adapter;
+    if (auto adapter = makeAdapter<SimTK::Vec6>(absTable)) return adapter;
+    if (auto adapter = makeAdapter<SimTK::Vec7>(absTable)) return adapter;
+    if (auto adapter = makeAdapter<SimTK::Vec8>(absTable)) return adapter;
+    if (auto adapter = makeAdapter<SimTK::Vec9>(absTable)) return adapter;
+    if (auto adapter = makeAdapter<SimTK::Vec<10>>(absTable)) return adapter;
+    if (auto adapter = makeAdapter<SimTK::Vec<11>>(absTable)) return adapter;
+    if (auto adapter = makeAdapter<SimTK::Vec<12>>(absTable)) return adapter;
 
     OPENSIM_THROW(STODataTypeNotSupported,
                   "<unknown>");
 }
 
-} // namespace OpenSim
+} // namespace OpenSim
\ No newline at end of file
diff --git a/OpenSim/Common/SegmentedQuinticBezierToolkit.cpp b/OpenSim/Common/SegmentedQuinticBezierToolkit.cpp
index b19423c0e..9c10bcdae 100644
--- a/OpenSim/Common/SegmentedQuinticBezierToolkit.cpp
+++ b/OpenSim/Common/SegmentedQuinticBezierToolkit.cpp
@@ -30,7 +30,6 @@
 //=============================================================================
 // STATICS
 //=============================================================================
-using namespace SimTK;
 using namespace OpenSim;
 using namespace std;
 
@@ -944,11 +943,11 @@ SimTK::Matrix SegmentedQuinticBezierToolkit::calcNumIntBezierYfcnX(
     }
 
     MySystem sys(bdata);
-    State initState = sys.realizeTopology();
+    SimTK::State initState = sys.realizeTopology();
     initState.setTime(startTime);
 
 
-    RungeKuttaMersonIntegrator integ(sys);
+    SimTK::RungeKuttaMersonIntegrator integ(sys);
     integ.setAccuracy(intAcc);
     integ.setFinalTime(endTime);
     integ.setReturnEveryInternalStep(false);
@@ -956,7 +955,7 @@ SimTK::Matrix SegmentedQuinticBezierToolkit::calcNumIntBezierYfcnX(
 
     int idx = 0;    
     double nextTimeInterval = 0;
-    Integrator::SuccessfulStepStatus status;
+    SimTK::Integrator::SuccessfulStepStatus status;
 
     while (idx < vX.nelt()) {      
         if(idx < vX.nelt()){
@@ -969,12 +968,12 @@ SimTK::Matrix SegmentedQuinticBezierToolkit::calcNumIntBezierYfcnX(
         status=integ.stepTo(nextTimeInterval);
 
         // Use this for variable step output.
-        //status = integ.stepTo(Infinity);
+        //status = integ.stepTo(SimTK::Infinity);
 
-        if (status == Integrator::EndOfSimulation)
+        if (status == SimTK::Integrator::EndOfSimulation)
             break;
         
-        const State& state = integ.getState();
+        const SimTK::State& state = integ.getState();
 
         if(flag_intLeftToRight){
             intXY(idx,0) = nextTimeInterval;
@@ -988,4 +987,4 @@ SimTK::Matrix SegmentedQuinticBezierToolkit::calcNumIntBezierYfcnX(
     }
     //intXY.resizeKeep(idx,2);
     return intXY;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Common/SmoothSegmentedFunction.cpp b/OpenSim/Common/SmoothSegmentedFunction.cpp
index 11de057e6..22b5d9305 100644
--- a/OpenSim/Common/SmoothSegmentedFunction.cpp
+++ b/OpenSim/Common/SmoothSegmentedFunction.cpp
@@ -36,7 +36,6 @@
 //=============================================================================
 // STATICS
 //=============================================================================
-using namespace SimTK;
 using namespace OpenSim;
 using namespace std;
 
@@ -93,7 +92,7 @@ struct SmoothSegmentedFunctionParameters
     bool _intx0x1 = false;
 };
 
-// Does what you expect, with the exception of NaN==NaN resulting in true, for
+// Does what you expect, with the exception of SimTK::NaN==SimTK::NaN resulting in true, for
 // x0, x1, y0, y1, dydxo, dydx1. This is to catch the uninitialized case.
 bool operator==(
     const SmoothSegmentedFunctionParameters& lhs,
@@ -356,7 +355,7 @@ SmoothSegmentedFunction::~SmoothSegmentedFunction() noexcept = default;
 
         Function detail
             Evaluations Function
-            m           SimTK::SplineFitter<Real>::
+            m           SimTK::SplineFitter<SimTK::Real>::
                             fitForSmoothingParameter(3,x,u,0).getSpline();
             Cost:       ?
 
@@ -386,8 +385,8 @@ SmoothSegmentedFunction::~SmoothSegmentedFunction() noexcept = default;
                                    > 3000 divisions
 
        =========================================================================
-        M: Matrix
-        V: Vector
+        M: SimTK::Matrix
+        V: SimTK::Vector
 
         N.B. These costs are dependent on SegmentedQuinticBezierToolkit
 */
@@ -447,7 +446,7 @@ SmoothSegmentedFunctionData::SmoothSegmentedFunctionData(
             }
         }
         //Create the array of approximate inverses for u(x)    
-        _arraySplineUX[s] = SimTK::SplineFitter<Real>::
+        _arraySplineUX[s] = SimTK::SplineFitter<SimTK::Real>::
             fitForSmoothingParameter(3,x,u,0).getSpline();
     }
 
@@ -475,7 +474,7 @@ SmoothSegmentedFunctionData::SmoothSegmentedFunctionData(
         //    yInt = yInt - yInt(yInt.nelt()-1);
         //}
 
-        _splineYintX = SimTK::SplineFitter<Real>::
+        _splineYintX = SimTK::SplineFitter<SimTK::Real>::
                 fitForSmoothingParameter(3,yInt(0),yInt(1),0).getSpline();
     }
 }
@@ -649,7 +648,7 @@ DerivativeValues calcSelectedDerivatives(
         return y;
     }
 
-    // In case of NaN return NaN.
+    // In case of SimTK::NaN return SimTK::NaN.
     y.fill(SimTK::NaN);
     return y;
 }
@@ -1081,6 +1080,4 @@ void SmoothSegmentedFunction::
         }   
     }
     datafile.close();
-} 
-
-
+} 
\ No newline at end of file
diff --git a/OpenSim/Common/SmoothSegmentedFunctionFactory.cpp b/OpenSim/Common/SmoothSegmentedFunctionFactory.cpp
index d9ec79c97..8df4810c0 100644
--- a/OpenSim/Common/SmoothSegmentedFunctionFactory.cpp
+++ b/OpenSim/Common/SmoothSegmentedFunctionFactory.cpp
@@ -28,7 +28,6 @@
 //=============================================================================
 // STATICS
 //=============================================================================
-using namespace SimTK;
 using namespace OpenSim;
 using namespace std;
 
@@ -411,7 +410,7 @@ SmoothSegmentedFunction* SmoothSegmentedFunctionFactory::
     //Check the input arguments
     SimTK_ERRCHK1_ALWAYS( (phi0>0 && phi0<(SimTK::Pi/2.0)) , 
         "SmoothSegmentedFunctionFactory::createFiberCompressiveForcePennationCurve", 
-        "%s: phi0 must be greater than 0, and less than Pi/2",curveName.c_str());
+        "%s: phi0 must be greater than 0, and less than SimTK::Pi/2",curveName.c_str());
 
     SimTK_ERRCHK2_ALWAYS( k > (1.0/(SimTK::Pi/2.0-phi0)) , 
         "SmoothSegmentedFunctionFactory::createFiberCompressiveForcePennationCurve", 
@@ -779,6 +778,4 @@ SmoothSegmentedFunction* SmoothSegmentedFunctionFactory::
             curveName);
 
     return mclCrvFcn;
-}
-
-
+}
\ No newline at end of file
diff --git a/OpenSim/Common/Test/testComponentInterface.cpp b/OpenSim/Common/Test/testComponentInterface.cpp
index 74db2cc5f..74e2f05c2 100644
--- a/OpenSim/Common/Test/testComponentInterface.cpp
+++ b/OpenSim/Common/Test/testComponentInterface.cpp
@@ -82,9 +82,6 @@ namespace
 
 using namespace OpenSim;
 using namespace std;
-using namespace SimTK;
-
-
 class Foo;
 class Bar;
 
@@ -95,10 +92,10 @@ public:
     Sub() = default;
     virtual ~Sub() = default;
 private:
-    void extendAddToSystem(MultibodySystem &system) const override {
+    void extendAddToSystem(SimTK::MultibodySystem &system) const override {
         Super::extendAddToSystem(system);
-        addStateVariable("subState", Stage::Dynamics);
-        addDiscreteVariable("dvX", Stage::Dynamics);
+        addStateVariable("subState", SimTK::Stage::Dynamics);
+        addDiscreteVariable("dvX", SimTK::Stage::Dynamics);
         addModelingOption("moX", 2);
     }
     void computeStateVariableDerivatives(const SimTK::State& s) const override {
@@ -130,35 +127,35 @@ public:
     void connect() {
         Super::finalizeConnections(*this);
     }
-    void buildUpSystem(MultibodySystem& system) {
+    void buildUpSystem(SimTK::MultibodySystem& system) {
         connect();
         addToSystem(system);
     }
 
-    const SimbodyMatterSubsystem& getMatterSubsystem() const { return *matter; }
-    SimbodyMatterSubsystem& updMatterSubsystem() const { return *matter; }
+    const SimTK::SimbodyMatterSubsystem& getMatterSubsystem() const { return *matter; }
+    SimTK::SimbodyMatterSubsystem& updMatterSubsystem() const { return *matter; }
 
-    const GeneralForceSubsystem& getForceSubsystem() const { return *forces; }
-    GeneralForceSubsystem& updForceSubsystem() const { return *forces; }
+    const SimTK::GeneralForceSubsystem& getForceSubsystem() const { return *forces; }
+    SimTK::GeneralForceSubsystem& updForceSubsystem() const { return *forces; }
 
 protected:
     // Component interface implementation
-    void extendAddToSystem(MultibodySystem& system) const override {
+    void extendAddToSystem(SimTK::MultibodySystem& system) const override {
         if (system.hasMatterSubsystem()){
             matter = system.updMatterSubsystem();
         }
         else{
             // const Sub& subc = getMemberSubcomponent<Sub>(intSubix);
 
-            SimbodyMatterSubsystem* old_matter = matter.release();
+            SimTK::SimbodyMatterSubsystem* old_matter = matter.release();
             delete old_matter;
-            matter = new SimbodyMatterSubsystem(system);
+            matter = new SimTK::SimbodyMatterSubsystem(system);
 
-            GeneralForceSubsystem* old_forces = forces.release();
+            SimTK::GeneralForceSubsystem* old_forces = forces.release();
             delete old_forces;
-            forces = new GeneralForceSubsystem(system);
+            forces = new SimTK::GeneralForceSubsystem(system);
 
-            SimTK::Force::UniformGravity gravity(*forces, *matter, Vec3(0, -9.816, 0));
+            SimTK::Force::UniformGravity gravity(*forces, *matter, SimTK::Vec3(0, -9.816, 0));
             fix = gravity.getForceIndex();
 
             system.updMatterSubsystem().setShowDefaultGeometry(true);
@@ -167,11 +164,11 @@ protected:
 
 private:
     // Keep track of pointers to the underlying computational subsystems.
-    mutable ReferencePtr<SimbodyMatterSubsystem> matter;
-    mutable ReferencePtr<GeneralForceSubsystem> forces;
+    mutable SimTK::ReferencePtr<SimTK::SimbodyMatterSubsystem> matter;
+    mutable SimTK::ReferencePtr<SimTK::GeneralForceSubsystem> forces;
 
     // keep track of the force added by the component
-    mutable ForceIndex fix;
+    mutable SimTK::ForceIndex fix;
 
     MemberSubcomponentIndex intSubix{ constructSubcomponent<Sub>("internalSub") };
 
@@ -194,16 +191,16 @@ public:
 
     OpenSim_DECLARE_OUTPUT(Output3, double, getSomethingElse, SimTK::Stage::Time);
 
-    OpenSim_DECLARE_OUTPUT(Qs, Vector, getQ, SimTK::Stage::Position);
+    OpenSim_DECLARE_OUTPUT(Qs, SimTK::Vector, getQ, SimTK::Stage::Position);
 
-    OpenSim_DECLARE_OUTPUT(BodyAcc, SpatialVec, calcSpatialAcc,
+    OpenSim_DECLARE_OUTPUT(BodyAcc, SimTK::SpatialVec, calcSpatialAcc,
             SimTK::Stage::Velocity);
 
     OpenSim_DECLARE_OUTPUT(return_by_ref, double, getReturnByRef,
             SimTK::Stage::Time);
 
     OpenSim_DECLARE_INPUT(input1, double, SimTK::Stage::Model, "");
-    OpenSim_DECLARE_INPUT(AnglesIn, Vector, SimTK::Stage::Model, "");
+    OpenSim_DECLARE_INPUT(AnglesIn, SimTK::Vector, SimTK::Stage::Model, "");
     OpenSim_DECLARE_INPUT(fiberLength, double, SimTK::Stage::Model, "");
     OpenSim_DECLARE_INPUT(activation, double, SimTK::Stage::Model, "");
     OpenSim_DECLARE_LIST_INPUT(listInput1, double, SimTK::Stage::Model, "");
@@ -258,23 +255,23 @@ protected:
         world = dynamic_cast<TheWorld*>(&root);
     }
 
-    void extendAddToSystem(MultibodySystem &system) const override {
+    void extendAddToSystem(SimTK::MultibodySystem &system) const override {
         Super::extendAddToSystem(system);
 
-        SimbodyMatterSubsystem& matter = system.updMatterSubsystem();
+        SimTK::SimbodyMatterSubsystem& matter = system.updMatterSubsystem();
 
-        Vec3 mInB(0.0, 1.0, 0);
-        Vec3 mInP(0, 0, 0);
+        SimTK::Vec3 mInB(0.0, 1.0, 0);
+        SimTK::Vec3 mInP(0, 0, 0);
 
         SimTK::Body::Rigid bone(
-            MassProperties(1, Vec3(0), Inertia::brick(0.5, 1, 0.5)));
+            SimTK::MassProperties(1, SimTK::Vec3(0), SimTK::Inertia::brick(0.5, 1, 0.5)));
 
         // Thigh connected by hip
-        MobilizedBody::Pin b1ToGround(matter.updGround(), SimTK::Transform(mInP),
+        SimTK::MobilizedBody::Pin b1ToGround(matter.updGround(), SimTK::Transform(mInP),
             bone, SimTK::Transform(mInB));
 
         //Pin knee connects shank
-        MobilizedBody::Pin b1ToB2(b1ToGround, SimTK::Transform(mInP),
+        SimTK::MobilizedBody::Pin b1ToB2(b1ToGround, SimTK::Transform(mInP),
             bone, SimTK::Transform(mInB));
 
         bindex = b1ToB2.getMobilizedBodyIndex();
@@ -293,8 +290,8 @@ private:
     }
 
     // Keep indices and reference to the world
-    mutable MobilizedBodyIndex bindex;
-    ReferencePtr<TheWorld> world;
+    mutable SimTK::MobilizedBodyIndex bindex;
+    SimTK::ReferencePtr<TheWorld> world;
 
 }; // End of class Foo
 
@@ -322,7 +319,7 @@ public:
     OpenSim_DECLARE_OUTPUT_FOR_STATE_VARIABLE(activation);
 
     double getPotentialEnergy(const SimTK::State& state) const {
-        const GeneralForceSubsystem& forces = world->getForceSubsystem();
+        const SimTK::GeneralForceSubsystem& forces = world->getForceSubsystem();
         const SimTK::Force& force = forces.getForce(fix);
         const auto& spring = SimTK::Force::TwoPointLinearSpring::downcast(force);
 
@@ -358,18 +355,18 @@ protected:
     // Copied here from Component for testing purposes.
 
 
-    void extendAddToSystem(MultibodySystem& system) const override{
+    void extendAddToSystem(SimTK::MultibodySystem& system) const override{
 
-        GeneralForceSubsystem& forces = world->updForceSubsystem();
-        SimbodyMatterSubsystem& matter = world->updMatterSubsystem();
+        SimTK::GeneralForceSubsystem& forces = world->updForceSubsystem();
+        SimTK::SimbodyMatterSubsystem& matter = world->updMatterSubsystem();
 
         int nb = matter.getNumBodies();
         if (nb > 2) {
-            const MobilizedBody& b1 = matter.getMobilizedBody(MobilizedBodyIndex(1));
-            const MobilizedBody& b2 = matter.getMobilizedBody(MobilizedBodyIndex(2));
+            const SimTK::MobilizedBody& b1 = matter.getMobilizedBody(SimTK::MobilizedBodyIndex(1));
+            const SimTK::MobilizedBody& b2 = matter.getMobilizedBody(SimTK::MobilizedBodyIndex(2));
 
             SimTK::Force::TwoPointLinearSpring
-                spring(forces, b1, Vec3(0.5,0,0), b2, Vec3(0.5,0,0), 10.0, 0.1);
+                spring(forces, b1, SimTK::Vec3(0.5,0,0), b2, SimTK::Vec3(0.5,0,0), 10.0, 0.1);
             fix = spring.getForceIndex();
         }
 
@@ -389,12 +386,12 @@ protected:
         // were allocated from subsystem different than the default subsystem
         // and to access a dv that is not type double.
         // The following calls put the mo and dv into the maps used to contain
-        // all mo's and dv's exposed in OpenSim. When Stage::Topology is
+        // all mo's and dv's exposed in OpenSim. When SimTK::Stage::Topology is
         // realized, they will be allocated in class Bar's override of
         // extendRealizeTopology(). See below.
         bool allocate = false;
         int maxFlagValue = 1;
-        addDiscreteVariable("point", Stage::Position, allocate);
+        addDiscreteVariable("point", SimTK::Stage::Position, allocate);
         addModelingOption("moY", maxFlagValue, allocate);
     }
 
@@ -406,14 +403,14 @@ protected:
     void extendRealizeTopology(SimTK::State& state) const override {
         Super::extendRealizeTopology(state);
 
-        GeneralForceSubsystem& fsub = world->updForceSubsystem();
+        SimTK::GeneralForceSubsystem& fsub = world->updForceSubsystem();
 
         // Discrete Variable Initialization
         std::string dvName = "point";
-        Vec3 point(0.0, 0.1, 0.2);
+        SimTK::Vec3 point(0.0, 0.1, 0.2);
         SimTK::DiscreteVariableIndex dvIndex =
-            fsub.allocateDiscreteVariable(state, Stage::Dynamics,
-                new Value<Vec3>(point));
+            fsub.allocateDiscreteVariable(state, SimTK::Stage::Dynamics,
+                new SimTK::Value<SimTK::Vec3>(point));
         initializeDiscreteVariableIndexes(dvName,
             fsub.getMySubsystemIndex(), dvIndex);
 
@@ -432,8 +429,8 @@ protected:
         std::string moName = "moY";
         int moVal{0};
         SimTK::DiscreteVariableIndex moIndex =
-            fsub.allocateDiscreteVariable(state, Stage::Dynamics,
-                new Value<int>(moVal));
+            fsub.allocateDiscreteVariable(state, SimTK::Stage::Dynamics,
+                new SimTK::Value<int>(moVal));
         initializeModelingOptionIndexes(moName,
             fsub.getMySubsystemIndex(), moIndex);
 
@@ -458,8 +455,8 @@ protected:
 private:
 
     // keep track of the force added by the component
-    mutable ForceIndex fix;
-    ReferencePtr<TheWorld> world;
+    mutable SimTK::ForceIndex fix;
+    SimTK::ReferencePtr<TheWorld> world;
 
 }; // End of class Bar
 
@@ -522,7 +519,7 @@ SimTK_NICETYPENAME_LITERAL(Bar);
 TEST_CASE("Component Interface Misc.")
 {
     // Define the Simbody system
-    MultibodySystem system;
+    SimTK::MultibodySystem system;
 
     TheWorld theWorld;
     theWorld.setName("World");
@@ -530,7 +527,7 @@ TEST_CASE("Component Interface Misc.")
 
     // ComponentHasNoSystem exception should be thrown if user attempts to read
     // or write state, discrete, or cache variables before Component has an
-    // underlying MultibodySystem.
+    // underlying SimTK::MultibodySystem.
     {
         SimTK::State sBlank;
         const std::string varName = "waldo"; //dummy name
@@ -687,18 +684,18 @@ TEST_CASE("Component Interface Misc.")
     theWorld.print(modelFile);
 
     // Simbody model state setup
-    State s = system.realizeTopology();
+    SimTK::State s = system.realizeTopology();
 
     // int nu = system.getMatterSubsystem().getNumMobilities();
 
     //SimTK::Visualizer viz(system);
     //viz.drawFrameNow(s);
-    const Vector q = Vector(s.getNQ(), SimTK::Pi/2);
-    const Vector u = Vector(s.getNU(), 1.0);
+    const SimTK::Vector q = SimTK::Vector(s.getNQ(), SimTK::Pi/2);
+    const SimTK::Vector u = SimTK::Vector(s.getNU(), 1.0);
 
     // Ensure the "this" pointer inside the output function is for the
     // correct Bar.
-    system.realize(s, Stage::Model);
+    system.realize(s, SimTK::Stage::Model);
     // Since bar0 is not part of any "world", we must call
     // finalizeFromProperties() on it ourselves in order to set the
     // "owner" of its outputs.
@@ -722,7 +719,7 @@ TEST_CASE("Component Interface Misc.")
     for (int i = 0; i < 10; ++i){
         s.updTime() = i*0.01234;
         s.updQ() = (i+1)*q/10.0;
-        system.realize(s, Stage::Velocity);
+        system.realize(s, SimTK::Stage::Velocity);
 
         const AbstractOutput& out1 = foo.getOutput("Output1");
         const AbstractOutput& out2 = foo.getOutput("Output2");
@@ -735,12 +732,12 @@ TEST_CASE("Component Interface Misc.")
         cout << out2.getName() <<"|"<< out2.getTypeName() <<"|"<< out2.getValueAsString(s) << endl;
         cout << out3.getName() <<"|"<< out3.getTypeName() <<"|"<< out3.getValueAsString(s) << endl;
 
-        system.realize(s, Stage::Acceleration);
+        system.realize(s, SimTK::Stage::Acceleration);
         cout << out4.getName() <<"|"<< out4.getTypeName() <<"|"<< out4.getValueAsString(s) << endl;
         cout << out5.getName() <<"|"<< out5.getTypeName() <<"|"<< out5.getValueAsString(s) << endl;
 
         //viz.report(s);
-        system.realize(s, Stage::Report);
+        system.realize(s, SimTK::Stage::Report);
 
         cout << "foo.input1 = " << foo.getInputValue<double>(s, "input1") << endl;
     }
@@ -748,7 +745,7 @@ TEST_CASE("Component Interface Misc.")
     // Test the output that returns by const T&.
     SimTK_TEST(foo.getOutputValue<double>(s, "return_by_ref") == s.getTime());
 
-    MultibodySystem system2;
+    SimTK::MultibodySystem system2;
     TheWorld *world2 = new TheWorld(modelFile, true);
 
     world2->updComponent("Bar").getSocket<Foo>("childFoo");
@@ -855,7 +852,7 @@ TEST_CASE("Component Interface Misc.")
     foo.connectInput_fiberLength(bar.getOutput("fiberLength"));
     foo.connectInput_activation(bar.getOutput("activation"));
 
-    MultibodySystem system3;
+    SimTK::MultibodySystem system3;
     cout << "Building theWorld's system:" << endl;
     theWorld.buildUpSystem(system3);
 
@@ -872,27 +869,27 @@ TEST_CASE("Component Interface Misc.")
     // int nu3 = system3.getMatterSubsystem().getNumMobilities();
 
     // realize simbody system to velocity stage
-    system3.realize(s, Stage::Velocity);
+    system3.realize(s, SimTK::Stage::Velocity);
 
-    RungeKuttaFeldbergIntegrator integ(system3);
+    SimTK::RungeKuttaFeldbergIntegrator integ(system3);
     integ.setAccuracy(1.0e-3);
 
-    TimeStepper ts(system3, integ);
+    SimTK::TimeStepper ts(system3, integ);
     ts.initialize(s);
     ts.stepTo(1.0);
     s = ts.getState();
 
     // realize simbody system to velocity stage
-    system3.realize(s, Stage::Velocity);
+    system3.realize(s, SimTK::Stage::Velocity);
 
     // Get the results of integrating the system forward
-    const TimeSeriesTable_<Real>& results = reporter->getTable();
+    const TimeSeriesTable_<SimTK::Real>& results = reporter->getTable();
     ASSERT(results.getNumRows() == 11, __FILE__, __LINE__,
         "Number of rows in Reporter results not equal to number of time intervals.");
     cout << "************** Contents of Table of Results ****************" << endl;
     cout << results << endl;
     cout << "***************** Qs Output at Final state *****************" << endl;
-    auto& finalVal = foo.getOutputValue<Vector>(s, "Qs");
+    auto& finalVal = foo.getOutputValue<SimTK::Vector>(s, "Qs");
     (~finalVal).dump();
     size_t ncols = results.getNumColumns();
     ASSERT(ncols == static_cast<size_t>(finalVal.size()), __FILE__, __LINE__,
@@ -965,7 +962,7 @@ TEST_CASE("Component Interface Exceptions Finalize From Properties After Copy")
 {
     TheWorld theWorld;
     {
-        MultibodySystem system;
+        SimTK::MultibodySystem system;
         Foo* foo = new Foo();
         theWorld.add(foo);
     }
@@ -977,7 +974,7 @@ TEST_CASE("Component Interface Exceptions Finalize From Properties After Copy")
 
 TEST_CASE("Component Interface List Inputs")
 {
-    MultibodySystem system;
+    SimTK::MultibodySystem system;
     TheWorld theWorld;
     theWorld.setName("World");
 
@@ -1022,13 +1019,13 @@ TEST_CASE("Component Interface List Inputs")
     theWorld.connect();
     theWorld.buildUpSystem(system);
 
-    State s = system.realizeTopology();
+    SimTK::State s = system.realizeTopology();
 
-    const Vector q = Vector(s.getNQ(), SimTK::Pi/2);
+    const SimTK::Vector q = SimTK::Vector(s.getNQ(), SimTK::Pi/2);
     for (int i = 0; i < 10; ++i){
         s.updTime() = i*0.01234;
         s.updQ() = (i+1)*q/10.0;
-        system.realize(s, Stage::Report);
+        system.realize(s, SimTK::Stage::Report);
     }
 
     cout << "  TableReporterMixedOutputs (contents)" << endl;
@@ -1040,7 +1037,7 @@ TEST_CASE("Component Interface List Inputs")
 
 TEST_CASE("Component Interface Sockets")
 {
-    MultibodySystem system;
+    SimTK::MultibodySystem system;
     TheWorld theWorld;
     theWorld.setName("world");
 
@@ -1078,7 +1075,7 @@ TEST_CASE("Component Interface Sockets")
 
         theWorld.connect();
         theWorld.buildUpSystem(system);
-        State s = system.realizeTopology();
+        SimTK::State s = system.realizeTopology();
         CHECK(bar.getConnectee<Foo>("parentFoo").get_mass() == 2.0);
     }
 
@@ -1492,9 +1489,9 @@ TEST_CASE("Component Interface Component::getStateVariableValue")
     top.add(a);
     a->addComponent(b);
 
-    MultibodySystem system;
+    SimTK::MultibodySystem system;
     top.buildUpSystem(system);
-    State s = system.realizeTopology();
+    SimTK::State s = system.realizeTopology();
 
     SimTK_TEST(s.getNY() == 3);
     s.updY()[0] = 10; // "top/internalSub/subState"
@@ -1529,9 +1526,9 @@ TEST_CASE("Component Interface getStateVariableValue with Component Path")
     top.add(a);
     a->addComponent(b);
 
-    MultibodySystem system;
+    SimTK::MultibodySystem system;
     top.buildUpSystem(system);
-    State s = system.realizeTopology();
+    SimTK::State s = system.realizeTopology();
 
     SimTK_TEST(s.getNY() == 3);
     s.updY()[0] = 10; // "top/internalSub/subState"
@@ -1565,14 +1562,14 @@ TEST_CASE("Component Interface Component::resolveVariableNameAndOwner")
     top.add(a);
     a->addComponent(b);
 
-    MultibodySystem system;
+    SimTK::MultibodySystem system;
     top.buildUpSystem(system);
-    State s = system.realizeTopology();
+    SimTK::State s = system.realizeTopology();
 
     const Component& internSub = top.getComponent("/internalSub");
     const Component* owner;
 
-    SECTION("State Variables") {
+    SECTION("SimTK::State Variables") {
         // Get the paths of all state variables under "top"
         const Array<std::string>& svPaths = top.getStateVariableNames();
         REQUIRE(svPaths.size() == 3);
@@ -1764,9 +1761,9 @@ TEST_CASE("Component Interface Modeling Options")
     top.add(a);
     a->addComponent(b);
 
-    MultibodySystem system;
+    SimTK::MultibodySystem system;
     top.buildUpSystem(system);
-    State s = system.realizeTopology();
+    SimTK::State s = system.realizeTopology();
 
     // Get the paths of all discrete variables under "top"
     const Array<std::string>& moPaths = top.getModelingOptionNames();
@@ -1828,9 +1825,9 @@ TEST_CASE("Component Interface Discrete Variables")
     top.add(a);
     a->addComponent(b);
 
-    MultibodySystem system;
+    SimTK::MultibodySystem system;
     top.buildUpSystem(system);
-    State s = system.realizeTopology();
+    SimTK::State s = system.realizeTopology();
 
     // Get the paths of all discrete variables under "top"
     const Array<std::string>& dvPaths = top.getDiscreteVariableNames();
@@ -1872,13 +1869,13 @@ TEST_CASE("Component Interface Discrete Variables")
     }
 }
 
-TEST_CASE("Component Interface Discrete Variables Vec3")
+TEST_CASE("Component Interface Discrete Variables SimTK::Vec3")
 {
     // ------------------------------------------------------------------------
     // Component Bar possesses a discrete variable called "point", which is
-    // a Vec3. Additionally, point was allocated as though it were a member
+    // a SimTK::Vec3. Additionally, point was allocated as though it were a member
     // of a pre-existing Simbody object (e.g., it was allocated from the
-    // GeneralForceSubsystem and not from the DefaultSybsystem like most, if
+    // SimTK::GeneralForceSubsystem and not from the DefaultSybsystem like most, if
     // not all, discrete variables allocated in OpenSim).
     // This test case
     // 1) checks the interface for handling discrete variables that are not
@@ -1888,7 +1885,7 @@ TEST_CASE("Component Interface Discrete Variables Vec3")
     //    allocated by calling Component::addDiscreteVariable()).
     // ------------------------------------------------------------------------
 
-    MultibodySystem system;
+    SimTK::MultibodySystem system;
     TheWorld theWorld;
     theWorld.setName("World");
 
@@ -1912,7 +1909,7 @@ TEST_CASE("Component Interface Discrete Variables Vec3")
     theWorld.connect();
     theWorld.buildUpSystem(system);
 
-    State s = system.realizeTopology();
+    SimTK::State s = system.realizeTopology();
 
     // Get the paths of all discrete variables under "theWorld"
     const Array<std::string>& dvPaths = theWorld.getDiscreteVariableNames();
@@ -1925,27 +1922,27 @@ TEST_CASE("Component Interface Discrete Variables Vec3")
     // Get the starting value of point
     // The starting value should be (0.0, 0.1, 0.2).
     // See Bar::extendRealizeTopology().
-    Vec3 pointStart(0.0, 0.1, 0.2);
-    Vec3 point = theWorld.getDiscreteVariableValue<Vec3>(s, "/Bar/point");
+    SimTK::Vec3 pointStart(0.0, 0.1, 0.2);
+    SimTK::Vec3 point = theWorld.getDiscreteVariableValue<SimTK::Vec3>(s, "/Bar/point");
     REQUIRE(point == pointStart);
 
     // Verify that changes to the local variable point do not change
     // the value of the discrete variable. That is, verify that the local
     // variable point holds a copy of the data.
     point *= 10.0;
-    Vec3 point2 = theWorld.getDiscreteVariableValue<Vec3>(s, "/Bar/point");
+    SimTK::Vec3 point2 = theWorld.getDiscreteVariableValue<SimTK::Vec3>(s, "/Bar/point");
     REQUIRE(point2 != point);
     REQUIRE(point2 == pointStart);
 
     // Set a new value and check it.
-    theWorld.setDiscreteVariableValue<Vec3>(s, "/Bar/point", point);
-    Vec3 point3 = theWorld.getDiscreteVariableValue<Vec3>(s, "/Bar/point");
+    theWorld.setDiscreteVariableValue<SimTK::Vec3>(s, "/Bar/point", point);
+    SimTK::Vec3 point3 = theWorld.getDiscreteVariableValue<SimTK::Vec3>(s, "/Bar/point");
     REQUIRE(point3 == point);
 }
 
-TEST_CASE("Component Interface State Trajectories")
+TEST_CASE("Component Interface SimTK::State Trajectories")
 {
-    MultibodySystem system;
+    SimTK::MultibodySystem system;
     TheWorld wrld;
     wrld.setName("World");
 
@@ -1969,12 +1966,12 @@ TEST_CASE("Component Interface State Trajectories")
     wrld.connect();
     wrld.buildUpSystem(system);
 
-    State s = system.realizeTopology();
+    SimTK::State s = system.realizeTopology();
 
     // Form the q and u vectors
     const Array<std::string>& svPaths = wrld.getStateVariableNames();
     REQUIRE(svPaths.size() == 4);
-    const Vector y = Vector(svPaths.size(), 0.1);
+    const SimTK::Vector y = SimTK::Vector(svPaths.size(), 0.1);
 
     // Get the paths of all discrete variables under "wrld"
     const OpenSim::Array<std::string>& dvPaths =
@@ -1993,7 +1990,7 @@ TEST_CASE("Component Interface State Trajectories")
     // Get the starting value of point
     // The starting value should be (0.0, 0.1, 1.0).
     // See Bar::extendRealizeTopology().
-    Vec3 pointStart = wrld.getDiscreteVariableValue<Vec3>(s, "/Bar/point");
+    SimTK::Vec3 pointStart = wrld.getDiscreteVariableValue<SimTK::Vec3>(s, "/Bar/point");
 
     // Run an artificial simulation and record the state trajectory
     SimTK::Array_<SimTK::State> simTraj;
@@ -2001,11 +1998,11 @@ TEST_CASE("Component Interface State Trajectories")
     simTraj.reserve(nsteps);
     int moX{0}, moY{0};
     double dvX{0.0};
-    Vec3 point(0.0);
+    SimTK::Vec3 point(0.0);
     for (int i = 0; i < nsteps; ++i){
         // Time
         s.updTime() = i*0.01;
-        // State Variables
+        // SimTK::State Variables
         wrld.setStateVariableValue(s, svPaths[0], i*y[0] + 0);
         wrld.setStateVariableValue(s, svPaths[1], i*y[1] + 1);
         wrld.setStateVariableValue(s, svPaths[2], i*y[2] + 2);
@@ -2014,14 +2011,14 @@ TEST_CASE("Component Interface State Trajectories")
         dvX = i*0.5 ;
         wrld.setDiscreteVariableValue(s, dvPaths[0], dvX);
         point = i*pointStart;
-        wrld.setDiscreteVariableValue<Vec3>(s, dvPaths[1], point);
+        wrld.setDiscreteVariableValue<SimTK::Vec3>(s, dvPaths[1], point);
         // Modeling Options
         moX = i % 2;
         wrld.setModelingOption(s, moPaths[0], moX);
         moY = (i+1) % 2;
         wrld.setModelingOption(s, moPaths[1], moY);
         // Accumulate the simulated state trajectory
-        system.realize(s, Stage::Report);
+        system.realize(s, SimTK::Stage::Report);
         simTraj.emplace_back(s);
     }
 
@@ -2034,9 +2031,9 @@ TEST_CASE("Component Interface State Trajectories")
     wrld.getStateVariableTrajectory<double>(svPaths[3], simTraj, y3Traj);
     // discrete variables
     SimTK::Array_<double> dv0Traj;
-    SimTK::Array_<Vec3> dv1Traj;
+    SimTK::Array_<SimTK::Vec3> dv1Traj;
     wrld.getDiscreteVariableTrajectory<double>(dvPaths[0], simTraj, dv0Traj);
-    wrld.getDiscreteVariableTrajectory<Vec3>(dvPaths[1], simTraj, dv1Traj);
+    wrld.getDiscreteVariableTrajectory<SimTK::Vec3>(dvPaths[1], simTraj, dv1Traj);
     // modeling options
     SimTK::Array_<int> mo0Traj;
     wrld.getModelingOptionTrajectory<int>(moPaths[0], simTraj, mo0Traj);
@@ -2069,7 +2066,7 @@ TEST_CASE("Component Interface State Trajectories")
     wrld.setStateVariableTrajectory<double>(svPaths[3], y3Traj, newTraj);
     // discrete variables
     wrld.setDiscreteVariableTrajectory<double>(dvPaths[0], dv0Traj, newTraj);
-    wrld.setDiscreteVariableTrajectory<Vec3>(dvPaths[1], dv1Traj, newTraj);
+    wrld.setDiscreteVariableTrajectory<SimTK::Vec3>(dvPaths[1], dv1Traj, newTraj);
     // modeling option
     wrld.setModelingOptionTrajectory<int>(moPaths[0], mo0Traj, newTraj);
     wrld.setModelingOptionTrajectory<int>(moPaths[1], mo1Traj, newTraj);
@@ -2077,7 +2074,7 @@ TEST_CASE("Component Interface State Trajectories")
     // Check the new state trajectory
     SimTK::Array_<double> nq0Traj, nq1Traj, nq2Traj, nq3Traj;
     SimTK::Array_<double> ndv0Traj;
-    SimTK::Array_<Vec3> ndv1Traj;
+    SimTK::Array_<SimTK::Vec3> ndv1Traj;
     SimTK::Array_<int> nmo0Traj;
     SimTK::Array_<int> nmo1Traj;
     wrld.getStateVariableTrajectory<double>(svPaths[0], newTraj, nq0Traj);
@@ -2085,7 +2082,7 @@ TEST_CASE("Component Interface State Trajectories")
     wrld.getStateVariableTrajectory<double>(svPaths[2], newTraj, nq2Traj);
     wrld.getStateVariableTrajectory<double>(svPaths[3], newTraj, nq3Traj);
     wrld.getDiscreteVariableTrajectory<double>(dvPaths[0], newTraj, ndv0Traj);
-    wrld.getDiscreteVariableTrajectory<Vec3>(dvPaths[1], newTraj, ndv1Traj);
+    wrld.getDiscreteVariableTrajectory<SimTK::Vec3>(dvPaths[1], newTraj, ndv1Traj);
     wrld.getModelingOptionTrajectory<int>(moPaths[0], newTraj, nmo0Traj);
     wrld.getModelingOptionTrajectory<int>(moPaths[1], newTraj, nmo1Traj);
     for (int i = 0; i < nsteps; ++i){
@@ -2118,7 +2115,7 @@ TEST_CASE("Component Interface Input/Output Connections")
         world.add(foo2);
         world.add(bar);
 
-        MultibodySystem mbs;
+        SimTK::MultibodySystem mbs;
 
         world.connect();
 
@@ -2171,11 +2168,11 @@ TEST_CASE("Component Interface Input/Output Connections")
         TheWorld world;
         A* a = new A(); a->setName("a");
         world.add(a);
-        MultibodySystem system;
+        SimTK::MultibodySystem system;
         world.connect();
         world.buildUpSystem(system);
-        State s = system.realizeTopology();
-        system.realize(s, Stage::Model);
+        SimTK::State s = system.realizeTopology();
+        system.realize(s, SimTK::Stage::Model);
         SimTK_TEST_MUST_THROW_EXC(a->getInput<double>("in1").getValue(s),
                 InputNotConnected);
     }
@@ -2189,11 +2186,11 @@ TEST_CASE("Component Interface Input/Output Connections")
         world.add(b);
         world.add(c);
         b->updInput("in1").connect(c->getOutput("out1"));
-        MultibodySystem system;
+        SimTK::MultibodySystem system;
         world.connect();
         world.buildUpSystem(system);
-        State s = system.realizeTopology();
-        system.realize(s, Stage::Model);
+        SimTK::State s = system.realizeTopology();
+        system.realize(s, SimTK::Stage::Model);
         // The following will work, now that the connection is satisfied.
         b->getInput<double>("in1").getValue(s, 0);
         // Disconnect to get the "not connected"exception.
@@ -2273,8 +2270,8 @@ TEST_CASE("Component Interface Exceptions when Connectee Type Mismatches")
     class B : public Component {
         OpenSim_DECLARE_CONCRETE_OBJECT(B, Component);
     public:
-        OpenSim_DECLARE_INPUT(in1, Vec3, SimTK::Stage::Model, "");
-        OpenSim_DECLARE_LIST_INPUT(inL, Vec3, SimTK::Stage::Model, "");
+        OpenSim_DECLARE_INPUT(in1, SimTK::Vec3, SimTK::Stage::Model, "");
+        OpenSim_DECLARE_LIST_INPUT(inL, SimTK::Vec3, SimTK::Stage::Model, "");
     };
     // This class has a socket.
     class C : public Component {
@@ -2428,14 +2425,14 @@ TEST_CASE("Component Interface Throws Exception if Input Name Exists Already")
         class A : public Component {
             OpenSim_DECLARE_CONCRETE_OBJECT(A, Component);
         public:
-            OpenSim_DECLARE_INPUT(in1, Vec3, SimTK::Stage::Model, "");
+            OpenSim_DECLARE_INPUT(in1, SimTK::Vec3, SimTK::Stage::Model, "");
         };
 
-        // BSame tries to reuse the name 'in1', and also connect to Vec3.
+        // BSame tries to reuse the name 'in1', and also connect to SimTK::Vec3.
         class BSame : public A {
             OpenSim_DECLARE_CONCRETE_OBJECT(BSame, A);
         public:
-            OpenSim_DECLARE_INPUT(in1, Vec3, SimTK::Stage::Model, "");
+            OpenSim_DECLARE_INPUT(in1, SimTK::Vec3, SimTK::Stage::Model, "");
         };
 
         // BDifferent uses the same name 'in1' but connects to a different type.
@@ -2457,14 +2454,14 @@ TEST_CASE("Component Interface Throws Exception if Input Name Exists Already")
         class A : public Component {
             OpenSim_DECLARE_CONCRETE_OBJECT(A, Component);
         public:
-            OpenSim_DECLARE_LIST_INPUT(in1, Vec3, SimTK::Stage::Model, "");
+            OpenSim_DECLARE_LIST_INPUT(in1, SimTK::Vec3, SimTK::Stage::Model, "");
         };
 
-        // BSame tries to reuse the name 'in1', and also connect to Vec3.
+        // BSame tries to reuse the name 'in1', and also connect to SimTK::Vec3.
         class BSame : public A {
             OpenSim_DECLARE_CONCRETE_OBJECT(BSame, A);
         public:
-            OpenSim_DECLARE_LIST_INPUT(in1, Vec3, SimTK::Stage::Model, "");
+            OpenSim_DECLARE_LIST_INPUT(in1, SimTK::Vec3, SimTK::Stage::Model, "");
         };
 
         // BDifferent uses the same name 'in1' but connects to a different type.
@@ -2508,8 +2505,8 @@ TEST_CASE("Component Interface Throws Exceptions if Output Name Exists Already")
         class BDifferent : public A {
             OpenSim_DECLARE_CONCRETE_OBJECT(BDifferent, A);
         public:
-            OpenSim_DECLARE_OUTPUT(out1, Vec3, calcOut1, SimTK::Stage::Time);
-            Vec3 calcOut1(const SimTK::State& state) const { return Vec3(0); }
+            OpenSim_DECLARE_OUTPUT(out1, SimTK::Vec3, calcOut1, SimTK::Stage::Time);
+            SimTK::Vec3 calcOut1(const SimTK::State& state) const { return SimTK::Vec3(0); }
         };
 
         ASSERT_THROW_MSG(OpenSim::Exception,
@@ -2544,10 +2541,10 @@ TEST_CASE("Component Interface Throws Exceptions if Output Name Exists Already")
         class BDifferent : public A {
             OpenSim_DECLARE_CONCRETE_OBJECT(BDifferent, A);
         public:
-            OpenSim_DECLARE_LIST_OUTPUT(out1, Vec3, calcOut1,
+            OpenSim_DECLARE_LIST_OUTPUT(out1, SimTK::Vec3, calcOut1,
                                         SimTK::Stage::Time);
-            Vec3 calcOut1(const SimTK::State& state,
-                          const std::string&) const { return Vec3(0); }
+            SimTK::Vec3 calcOut1(const SimTK::State& state,
+                          const std::string&) const { return SimTK::Vec3(0); }
         };
 
         ASSERT_THROW_MSG(OpenSim::Exception,
@@ -2570,8 +2567,6 @@ void assertEqual(const RowVec& a, const RowVec& b) {
 TEST_CASE("Component Interface Table Source")
 {
     using namespace OpenSim;
-    using namespace SimTK;
-
     {
         TheWorld model{};
         auto tablesource = new TableSourceVec3{};
@@ -2612,7 +2607,7 @@ TEST_CASE("Component Interface Table Source")
     auto tableReporter = new TableReporter_<double, double>{};
 
     // Define the Simbody system
-    MultibodySystem system;
+    SimTK::MultibodySystem system;
 
     TheWorld theWorld;
     theWorld.setName("World");
@@ -2629,7 +2624,7 @@ TEST_CASE("Component Interface Table Source")
 
     const auto& report = tableReporter->getTable();
 
-    State s = system.realizeTopology();
+    SimTK::State s = system.realizeTopology();
 
     s.setTime(0);
     tableReporter->report(s);
@@ -2637,7 +2632,7 @@ TEST_CASE("Component Interface Table Source")
 
     s.setTime(0.1);
     tableReporter->report(s);
-    row = RowVector_<double>{4, 0.4};
+    row = SimTK::RowVector_<double>{4, 0.4};
     assertEqual(row.getAsRowVectorView(), report.getRowAtIndex(1));
 
     s.setTime(0.25);
@@ -2646,7 +2641,7 @@ TEST_CASE("Component Interface Table Source")
 
     s.setTime(0.4);
     tableReporter->report(s);
-    row = RowVector_<double>{4, 1.6};
+    row = SimTK::RowVector_<double>{4, 1.6};
     assertEqual(row.getAsRowVectorView(), report.getRowAtIndex(3));
 
     s.setTime(0.5);
@@ -2655,7 +2650,7 @@ TEST_CASE("Component Interface Table Source")
 
     s.setTime(0.6);
     tableReporter->report(s);
-    row = RowVector_<double>{4, 2.4};
+    row = SimTK::RowVector_<double>{4, 2.4};
     assertEqual(row.getAsRowVectorView(), report.getRowAtIndex(5));
 
     s.setTime(0.75);
@@ -2675,14 +2670,14 @@ TEST_CASE("Component Interface TableReporter Usage")
         reporter->set_report_time_interval(0.1);
         model.addComponent(reporter);
 
-        MultibodySystem system;
+        SimTK::MultibodySystem system;
         model.buildUpSystem(system);
 
         {
             SimTK::State s = system.realizeTopology();
-            RungeKuttaFeldbergIntegrator integ(system);
+            SimTK::RungeKuttaFeldbergIntegrator integ(system);
             integ.setAccuracy(1.0e-3);
-            TimeStepper ts(system, integ);
+            SimTK::TimeStepper ts(system, integ);
             ts.initialize(s);
             ts.stepTo(1.0);
             const auto& table = reporter->getTable();
@@ -2703,9 +2698,9 @@ TEST_CASE("Component Interface TableReporter Usage")
 
         {
             SimTK::State s = system.realizeTopology();
-            RungeKuttaFeldbergIntegrator integ(system);
+            SimTK::RungeKuttaFeldbergIntegrator integ(system);
             integ.setAccuracy(1.0e-3);
-            TimeStepper ts(system, integ);
+            SimTK::TimeStepper ts(system, integ);
             ts.initialize(s);
             ts.stepTo(1.0);
             const auto& table = reporter->getTable();
@@ -2784,7 +2779,7 @@ TEST_CASE("Component Interface List Input Connectee Serialization Behavior")
         // to hold onto stale references to the outputs' channels.
         world.finalizeFromProperties();
         world.connect();
-        MultibodySystem system;
+        SimTK::MultibodySystem system;
         world.buildUpSystem(system);
 
         // Grab the connectee paths.
@@ -2792,8 +2787,8 @@ TEST_CASE("Component Interface List Input Connectee Serialization Behavior")
         SimTK_TEST(getConnecteePaths(input) == expectedConnecteePaths);
 
         // Get the value of the input at some given time.
-        State s = system.realizeTopology();
-        system.realize(s, Stage::Model);
+        SimTK::State s = system.realizeTopology();
+        system.realize(s, SimTK::Stage::Model);
         s.setTime(0.3);
         expectedInputValues = Input<double>::downcast(input).getVector(s);
         SimTK_TEST(expectedInputValues.size() == 3);
@@ -2819,10 +2814,10 @@ TEST_CASE("Component Interface List Input Connectee Serialization Behavior")
         SimTK_TEST(input.getAlias(2) == "berry"); // specified.
 
         // Check that the value of the input is the same as before.
-        MultibodySystem system;
+        SimTK::MultibodySystem system;
         world.buildUpSystem(system);
-        State s = system.realizeTopology();
-        system.realize(s, Stage::Model);
+        SimTK::State s = system.realizeTopology();
+        system.realize(s, SimTK::Stage::Model);
         s.setTime(0.3);
         auto actualInputValues = Input<double>::downcast(input).getVector(s);
 
@@ -2830,7 +2825,7 @@ TEST_CASE("Component Interface List Input Connectee Serialization Behavior")
     }
 }
 
-TEST_CASE("Component Interface Single Value Input Connectee Serialization Behavior")
+TEST_CASE("Component Interface Single SimTK::Value Input Connectee Serialization Behavior")
 {
     // Test normal behavior of single-value input (de)serialization.
     // -------------------------------------------------------------
@@ -2873,12 +2868,12 @@ TEST_CASE("Component Interface Single Value Input Connectee Serialization Behavi
         // to hold onto stale references to the outputs' channels.
         world.finalizeFromProperties();
         world.connect();
-        MultibodySystem system;
+        SimTK::MultibodySystem system;
         world.buildUpSystem(system);
 
         // Get the value of the input at some given time.
-        State s = system.realizeTopology();
-        system.realize(s, Stage::Model);
+        SimTK::State s = system.realizeTopology();
+        system.realize(s, SimTK::Stage::Model);
         s.setTime(0.3);
         const auto& input1 = foo->getInput("input1");
         expectedInput1Value = Input<double>::downcast(input1).getValue(s);
@@ -2933,10 +2928,10 @@ TEST_CASE("Component Interface Single Value Input Connectee Serialization Behavi
         SimTK_TEST(fiberLength.getAlias(0) == "desert");
 
         // Check that the value of the input is the same as before.
-        MultibodySystem system;
+        SimTK::MultibodySystem system;
         world.buildUpSystem(system);
-        State s = system.realizeTopology();
-        system.realize(s, Stage::Model);
+        SimTK::State s = system.realizeTopology();
+        system.realize(s, SimTK::Stage::Model);
         s.setTime(0.3);
 
         SimTK_TEST_EQ(Input<double>::downcast(input1).getValue(s),
@@ -3075,7 +3070,7 @@ TEST_CASE("Component Interface Aliases and Labels Behavior")
     SimTK_TEST(foo->getInput("listInput1").getLabel(1) == "thud");
 }
 
-TEST_CASE("Component Interface Get Absolute Path String Speed")
+TEST_CASE("Component Interface Get Absolute Path SimTK::String Speed")
 {
     std::clock_t constructStartTime = std::clock();
 
@@ -3235,8 +3230,8 @@ TEST_CASE("Component Interface CacheVariable<T> Behavior")
     // should work after `Component::realizeTopology` has been called
     {
         SimTK::MultibodySystem sys;
-        SimbodyMatterSubsystem matter{sys};
-        GeneralForceSubsystem forces{sys};
+        SimTK::SimbodyMatterSubsystem matter{sys};
+        SimTK::GeneralForceSubsystem forces{sys};
 
         ComponentWithCacheVariable c{};
         c.finalizeFromProperties();
@@ -3310,8 +3305,8 @@ TEST_CASE("Component Interface CacheVariable<T> Behavior")
     // `Component::realizeTopology`)
     {
         SimTK::MultibodySystem sys;
-        SimbodyMatterSubsystem matter{sys};
-        GeneralForceSubsystem forces{sys};
+        SimTK::SimbodyMatterSubsystem matter{sys};
+        SimTK::GeneralForceSubsystem forces{sys};
 
         ComponentWithCacheVariable c1{};
         c1.finalizeFromProperties();
@@ -3420,4 +3415,4 @@ const bool g_TestFixtureTypesAreRegistered = []()
     Object::registerType(Bar());
     Object::registerType(TheWorld());
     return true;
-}();
+}();
\ No newline at end of file
diff --git a/OpenSim/Common/Test/testDataTable.cpp b/OpenSim/Common/Test/testDataTable.cpp
index 7086ffcf3..f544bbcf4 100644
--- a/OpenSim/Common/Test/testDataTable.cpp
+++ b/OpenSim/Common/Test/testDataTable.cpp
@@ -30,8 +30,6 @@
 #include <OpenSim/Common/TableUtilities.h>
 #include <OpenSim/Common/STOFileAdapter.h>
 #include <OpenSim/Common/TimeSeriesTable.h>
-
-using namespace SimTK;
 using namespace OpenSim;
 using OpenSim::Exception;
 using Catch::Approx;
@@ -232,25 +230,25 @@ TEST_CASE("DataTable") {
             (DataTable_<double, double    >{})).
             numComponentsPerElement() == 1);
     ASSERT((static_cast<AbstractDataTable&&>
-            (DataTable_<double, Vec3      >{})).
+            (DataTable_<double, SimTK::Vec3      >{})).
             numComponentsPerElement() == 3);
     ASSERT((static_cast<AbstractDataTable&&>
-            (DataTable_<double, UnitVec3  >{})).
+            (DataTable_<double, SimTK::UnitVec3  >{})).
             numComponentsPerElement() == 3);
     ASSERT((static_cast<AbstractDataTable&&>
-            (DataTable_<double, Quaternion>{})).
+            (DataTable_<double, SimTK::Quaternion>{})).
             numComponentsPerElement() == 4);
     ASSERT((static_cast<AbstractDataTable&&>
-            (DataTable_<double, SpatialVec>{})).
+            (DataTable_<double, SimTK::SpatialVec>{})).
             numComponentsPerElement() == 6);
     ASSERT((static_cast<AbstractDataTable&&>
-            (DataTable_<double, Rotation>{})).
+            (DataTable_<double, SimTK::Rotation>{})).
             numComponentsPerElement() == 9);
 
     {
-        std::cout << "Test DataTable flattening constructor for Vec3."
+        std::cout << "Test DataTable flattening constructor for SimTK::Vec3."
                   << std::endl;
-        DataTable_<double, Vec3> tableVec3{};
+        DataTable_<double, SimTK::Vec3> tableVec3{};
         tableVec3.setColumnLabels({"col0", "col1", "col2"});
         tableVec3.appendRow(0.1, {{1, 1, 1}, {2, 2, 2}, {3, 3, 3}});
         tableVec3.appendRow(0.2, {{3, 3, 3}, {1, 1, 1}, {2, 2, 2}});
@@ -278,7 +276,7 @@ TEST_CASE("DataTable") {
         }
 
         {
-        std::cout << "Test feeding rows of one table to another [Vec3]."
+        std::cout << "Test feeding rows of one table to another [SimTK::Vec3]."
                   << std::endl;
         DataTableVec3 tableVec3Copy{};
         tableVec3Copy.setColumnLabels(tableVec3.getColumnLabels());
@@ -300,7 +298,7 @@ TEST_CASE("DataTable") {
         }
         }
 
-        std::cout << "Test DataTable flatten() for Vec3." << std::endl;
+        std::cout << "Test DataTable flatten() for SimTK::Vec3." << std::endl;
         auto tableFlat = tableVec3.flatten({"_x", "_y", "_z"});
         expLabels = {"col0_x", "col0_y", "col0_z",
                      "col1_x", "col1_y", "col1_z",
@@ -322,9 +320,9 @@ TEST_CASE("DataTable") {
 
         std::cout << tableFlat << std::endl;
 
-        std::cout << "Test DataTable flattening constructor for Quaternion."
+        std::cout << "Test DataTable flattening constructor for SimTK::Quaternion."
                   << std::endl;
-        DataTable_<double, Quaternion> tableQuat{};
+        DataTable_<double, SimTK::Quaternion> tableQuat{};
         tableQuat.setColumnLabels({"col0", "col1", "col2"});
         tableQuat.appendRow(0.1, {{1, 1, 1, 1}, {2, 2, 2, 2}, {3, 3, 3, 3}});
         tableQuat.appendRow(0.2, {{3, 3, 3, 3}, {1, 1, 1, 1}, {2, 2, 2, 2}});
@@ -337,9 +335,9 @@ TEST_CASE("DataTable") {
         ASSERT(tableDouble.getNumRows()             == 3);
         ASSERT(tableDouble.getNumColumns()          == 12);
 
-        std::cout << "Test DataTable flattening constructor for UnitVec3."
+        std::cout << "Test DataTable flattening constructor for SimTK::UnitVec3."
                   << std::endl;
-        DataTable_<double, Vec3> tableUnitVec3{};
+        DataTable_<double, SimTK::Vec3> tableUnitVec3{};
         tableUnitVec3.setColumnLabels({"col0", "col1", "col2"});
         tableUnitVec3.appendRow(0.1, {{1, 1, 1}, {2, 2, 2}, {3, 3, 3}});
         tableUnitVec3.appendRow(0.2, {{3, 3, 3}, {1, 1, 1}, {2, 2, 2}});
@@ -352,9 +350,9 @@ TEST_CASE("DataTable") {
         ASSERT(tableDouble.getNumRows()             == 3);
         ASSERT(tableDouble.getNumColumns()          == 9);
 
-        std::cout << "Test DataTable flattening constructor for SpatialVec."
+        std::cout << "Test DataTable flattening constructor for SimTK::SpatialVec."
                   << std::endl;
-        DataTable_<double, SpatialVec> tableSpatialVec{};
+        DataTable_<double, SimTK::SpatialVec> tableSpatialVec{};
         tableSpatialVec.setColumnLabels({"col0", "col1", "col2"});
         tableSpatialVec.appendRow(0.1, {{{1, 1, 1}, {1, 1, 1}},
                                         {{2, 2, 2}, {2, 2, 2}},
@@ -375,16 +373,16 @@ TEST_CASE("DataTable") {
 
         std::cout << tableDouble << std::endl;
 
-        std::cout << "Test DataTable flattening constructor for Rotation."
+        std::cout << "Test DataTable flattening constructor for SimTK::Rotation."
                   << std::endl;
-        DataTable_<double, Rotation> tableRotation{};
+        DataTable_<double, SimTK::Rotation> tableRotation{};
         tableRotation.setColumnLabels({"col0", "col1"});
-        tableRotation.appendRow(0.1, {Rotation(0.1, UnitVec3(1, 0, 0)),
-                                      Rotation(0.2, UnitVec3(0, 1, 0))});
-        tableRotation.appendRow(0.2, {Rotation(0.2, UnitVec3(0, 0, 1)),
-                                      Rotation(0.1, UnitVec3(0, 1, 0))});
-        tableRotation.appendRow(0.3, {Rotation(0.3, UnitVec3(0, 1, 0)),
-                                      Rotation(0.2, UnitVec3(1, 0, 0))});
+        tableRotation.appendRow(0.1, {SimTK::Rotation(0.1, SimTK::UnitVec3(1, 0, 0)),
+                                      SimTK::Rotation(0.2, SimTK::UnitVec3(0, 1, 0))});
+        tableRotation.appendRow(0.2, {SimTK::Rotation(0.2, SimTK::UnitVec3(0, 0, 1)),
+                                      SimTK::Rotation(0.1, SimTK::UnitVec3(0, 1, 0))});
+        tableRotation.appendRow(0.3, {SimTK::Rotation(0.3, SimTK::UnitVec3(0, 1, 0)),
+                                      SimTK::Rotation(0.2, SimTK::UnitVec3(1, 0, 0))});
 
         std::cout << tableRotation << std::endl;
 
@@ -396,9 +394,9 @@ TEST_CASE("DataTable") {
         std::cout << tableDouble << std::endl;
     }
     {
-        std::cout << "Test TimeSeriesTable flattening constructor for Vec3"
+        std::cout << "Test TimeSeriesTable flattening constructor for SimTK::Vec3"
                   << std::endl;
-        TimeSeriesTable_<Vec3> tableVec3{};
+        TimeSeriesTable_<SimTK::Vec3> tableVec3{};
         tableVec3.setColumnLabels({"col0", "col1", "col2"});
         tableVec3.appendRow(0.1, {{1, 1, 1}, {2, 2, 2}, {3, 3, 3}});
         tableVec3.appendRow(0.2, {{3, 3, 3}, {1, 1, 1}, {2, 2, 2}});
@@ -441,7 +439,7 @@ TEST_CASE("DataTable") {
 
         std::cout << tableDouble << std::endl;
 
-        std::cout << "Test TimeSeriesTable flatten() for Vec3." << std::endl;
+        std::cout << "Test TimeSeriesTable flatten() for SimTK::Vec3." << std::endl;
         auto tableFlat = tableVec3.flatten({"_x", "_y", "_z"});
         expLabels = {"col0_x", "col0_y", "col0_z",
                      "col1_x", "col1_y", "col1_z",
@@ -464,8 +462,8 @@ TEST_CASE("DataTable") {
         std::cout << tableFlat << std::endl;
 
         std::cout << "Test TimeSeriesTable flattening constructor for "
-                     "Quaternion" << std::endl;
-        TimeSeriesTable_<Quaternion> tableQuat{};
+                     "SimTK::Quaternion" << std::endl;
+        TimeSeriesTable_<SimTK::Quaternion> tableQuat{};
         tableQuat.setColumnLabels({"col0", "col1", "col2"});
         tableQuat.appendRow(0.1, {{1, 1, 1, 1}, {2, 2, 2, 2}, {3, 3, 3, 3}});
         tableQuat.appendRow(0.2, {{3, 3, 3, 3}, {1, 1, 1, 1}, {2, 2, 2, 2}});
@@ -491,9 +489,9 @@ TEST_CASE("DataTable") {
 
         std::cout << tableDouble << std::endl;
 
-        std::cout << "Test TimeSeriesTable flattening constructor for UnitVec3"
+        std::cout << "Test TimeSeriesTable flattening constructor for SimTK::UnitVec3"
                   << std::endl;
-        TimeSeriesTable_<Vec3> tableUnitVec3{};
+        TimeSeriesTable_<SimTK::Vec3> tableUnitVec3{};
         tableUnitVec3.setColumnLabels({"col0", "col1", "col2"});
         tableUnitVec3.appendRow(0.1, {{1, 1, 1}, {2, 2, 2}, {3, 3, 3}});
         tableUnitVec3.appendRow(0.2, {{3, 3, 3}, {1, 1, 1}, {2, 2, 2}});
@@ -509,8 +507,8 @@ TEST_CASE("DataTable") {
         std::cout << tableDouble << std::endl;
 
         std::cout << "Test TimeSeriesTable flattening constructor for "
-                     "SpatialVec" << std::endl;
-        TimeSeriesTable_<SpatialVec> tableSpatialVec{};
+                     "SimTK::SpatialVec" << std::endl;
+        TimeSeriesTable_<SimTK::SpatialVec> tableSpatialVec{};
         tableSpatialVec.setColumnLabels({"col0", "col1", "col2"});
         tableSpatialVec.appendRow(0.1, {{{1, 1, 1}, {1, 1, 1}},
                                         {{2, 2, 2}, {2, 2, 2}},
@@ -550,17 +548,17 @@ TEST_CASE("DataTable") {
         std::cout << tableDouble << std::endl;
 
         std::cout << "Test TimeSeriesTable flattening constructor for "
-                     "Rotation" << std::endl;
-        DataTable_<double, Rotation> tableRotation{};
+                     "SimTK::Rotation" << std::endl;
+        DataTable_<double, SimTK::Rotation> tableRotation{};
         tableRotation.setColumnLabels({"col0", "col1"});
-        tableRotation.appendRow(0.1, {Rotation(0.1, UnitVec3(1, 0, 0)),
-                                      Rotation(0.2, UnitVec3(0, 1, 0))});
-        tableRotation.appendRow(0.2, {Rotation(0.2, UnitVec3(0, 0, 1)),
-                                      Rotation(0.1, UnitVec3(0, 1, 0))});
-        tableRotation.appendRow(0.3, {Rotation(0.3, UnitVec3(0, 1, 0)),
-                                      Rotation(0.2, UnitVec3(1, 0, 0))});
-
-        // TODO: RowVector_<Rotation> is not supported.
+        tableRotation.appendRow(0.1, {SimTK::Rotation(0.1, SimTK::UnitVec3(1, 0, 0)),
+                                      SimTK::Rotation(0.2, SimTK::UnitVec3(0, 1, 0))});
+        tableRotation.appendRow(0.2, {SimTK::Rotation(0.2, SimTK::UnitVec3(0, 0, 1)),
+                                      SimTK::Rotation(0.1, SimTK::UnitVec3(0, 1, 0))});
+        tableRotation.appendRow(0.3, {SimTK::Rotation(0.3, SimTK::UnitVec3(0, 1, 0)),
+                                      SimTK::Rotation(0.2, SimTK::UnitVec3(1, 0, 0))});
+
+        // TODO: SimTK::RowVector_<SimTK::Rotation> is not supported.
         // const auto& avgRowRot = tableRotation.averageRow(0.1, 0.2);
         // for(int i = 0; i < 3; ++i) {
         //     OPENSIM_THROW_IF(std::abs(avgRowRot[0][0][i] - 2) > 1e-8/*eps*/,
@@ -572,8 +570,8 @@ TEST_CASE("DataTable") {
         // for(int i = 0; i < 3; ++i)
         //     ASSERT(nearRowRot[0][0][i] == 2);
 
-        // tableRotation.updNearestRow(0.29) += Rotation(0.2, UnitVec3(0, 1, 0));
-        // tableRotation.updNearestRow(0.29) -= Rotation(0.2, UnitVec3(0, 1, 0));
+        // tableRotation.updNearestRow(0.29) += SimTK::Rotation(0.2, SimTK::UnitVec3(0, 1, 0));
+        // tableRotation.updNearestRow(0.29) -= SimTK::Rotation(0.2, SimTK::UnitVec3(0, 1, 0));
         // for(int i = 0; i < 3; ++i)
         //     ASSERT(nearRowRot[0][0][i] == 2);
 
@@ -605,7 +603,7 @@ TEST_CASE("DataTable") {
 
         std::cout << tableDouble << std::endl;
 
-        std::cout << "Test DataTable packing for Vec3 with suffix specified."
+        std::cout << "Test DataTable packing for SimTK::Vec3 with suffix specified."
                   << std::endl;
         auto tableVec3_1 = tableDouble.pack<SimTK::Vec3>({"_x", "_y", "_z"});
         std::vector<std::string> expLabels{"col0", "col1", "col2", "col3"};
@@ -616,7 +614,7 @@ TEST_CASE("DataTable") {
         ASSERT(tableVec3_1.getTableMetaData<int>("int")            == 10);
         std::cout << tableVec3_1 << std::endl;
 
-        std::cout << "Test DataTable packing for Vec3 with suffix unspecified."
+        std::cout << "Test DataTable packing for SimTK::Vec3 with suffix unspecified."
                   << std::endl;
         auto tableVec3_2 = tableDouble.pack<SimTK::Vec3>();
         ASSERT(tableVec3_2.getColumnLabels() == expLabels);
@@ -626,7 +624,7 @@ TEST_CASE("DataTable") {
         ASSERT(tableVec3_2.getTableMetaData<int>("int")            == 10);
         std::cout << tableVec3_2 << std::endl;
 
-        std::cout << "Test DataTable packing for UnitVec3." << std::endl;
+        std::cout << "Test DataTable packing for SimTK::UnitVec3." << std::endl;
         auto tableUVec3 = tableDouble.pack<SimTK::UnitVec3>();
         ASSERT(tableUVec3.getColumnLabels() == expLabels);
         ASSERT(tableUVec3.getNumRows()      == 3);
@@ -635,7 +633,7 @@ TEST_CASE("DataTable") {
         ASSERT(tableUVec3.getTableMetaData<int>("int")            == 10);
         std::cout << tableUVec3 << std::endl;
 
-        std::cout << "Test DataTable packing for Quaternion." << std::endl;
+        std::cout << "Test DataTable packing for SimTK::Quaternion." << std::endl;
         tableDouble.setColumnLabels({"col0.0", "col0.1", "col0.2", "col0.3",
                                      "col1.0", "col1.1", "col1.2", "col1.3",
                                      "col2.0", "col2.1", "col2.2", "col2.3"});
@@ -648,7 +646,7 @@ TEST_CASE("DataTable") {
         ASSERT(tableQuat.getTableMetaData<int>("int")            == 10);
         std::cout << tableQuat << std::endl;
 
-        std::cout << "Test DataTable packing for SpatialVec" << std::endl;
+        std::cout << "Test DataTable packing for SimTK::SpatialVec" << std::endl;
         tableDouble.setColumnLabels({"col0.0", "col0.1", "col0.2",
                                      "col0.3", "col0.4", "col0.5",
                                      "col1.0", "col1.1", "col1.2",
@@ -662,7 +660,7 @@ TEST_CASE("DataTable") {
         ASSERT(tableSVec.getTableMetaData<int>("int")            == 10);
         std::cout << tableSVec << std::endl;
 
-        std::cout << "Test DataTable packing for Rotation" << std::endl;
+        std::cout << "Test DataTable packing for SimTK::Rotation" << std::endl;
         DataTable_<double, double> table{};
         table.setColumnLabels({"col0_0", "col0_1", "col0_2",
                                "col0_3", "col0_4", "col0_5",
@@ -670,9 +668,9 @@ TEST_CASE("DataTable") {
                                "col1_0", "col1_1", "col1_2",
                                "col1_3", "col1_4", "col1_5",
                                "col1_6", "col1_7", "col1_8"});
-        table.appendRow(1, RowVector(18, 1));
-        table.appendRow(2, RowVector(18, 2));
-        table.appendRow(3, RowVector(18, 3));
+        table.appendRow(1, SimTK::RowVector(18, 1));
+        table.appendRow(2, SimTK::RowVector(18, 2));
+        table.appendRow(3, SimTK::RowVector(18, 3));
         table.addTableMetaData("string", std::string{"string"});
         table.addTableMetaData("int", 10);
         ASSERT(table.getColumnLabels().size() == 18);
@@ -708,15 +706,15 @@ TEST_CASE("DataTable") {
         std::cout << tableDouble << std::endl;
 
         auto tableDoubleCopy = tableDouble;
-        Vector row2{ tableDoubleCopy.getRowAtIndex(2).transpose() };
+        SimTK::Vector row2{ tableDoubleCopy.getRowAtIndex(2).transpose() };
         tableDoubleCopy.removeRowAtIndex(1);
-        Vector row1{ tableDoubleCopy.getRowAtIndex(1).transpose() };
+        SimTK::Vector row1{ tableDoubleCopy.getRowAtIndex(1).transpose() };
         ASSERT_EQUAL(row1, row2, 0.0);
         tableDoubleCopy.removeRowAtIndex(0);
-        Vector row0{ tableDoubleCopy.getRowAtIndex(0).transpose() };
+        SimTK::Vector row0{ tableDoubleCopy.getRowAtIndex(0).transpose() };
         ASSERT_EQUAL(row0, row2, 0.0);
 
-        std::cout << "Test TimeSeriesTable packing for Vec3 with suffix"
+        std::cout << "Test TimeSeriesTable packing for SimTK::Vec3 with suffix"
                      " specified."
                   << std::endl;
         TimeSeriesTable_<SimTK::Vec3> tableVec3_1 =
@@ -729,7 +727,7 @@ TEST_CASE("DataTable") {
         ASSERT(tableVec3_1.getTableMetaData<int>("int")            == 10);
         std::cout << tableVec3_1 << std::endl;
 
-        std::cout << "Test TimeSeriesTable packing for Vec3 with suffix"
+        std::cout << "Test TimeSeriesTable packing for SimTK::Vec3 with suffix"
                      " unspecified."
                   << std::endl;
         TimeSeriesTable_<SimTK::Vec3> tableVec3_2 =
@@ -741,7 +739,7 @@ TEST_CASE("DataTable") {
         ASSERT(tableVec3_2.getTableMetaData<int>("int")            == 10);
         std::cout << tableVec3_2 << std::endl;
 
-        std::cout << "Test TimeSeriesTable packing for UnitVec3." << std::endl;
+        std::cout << "Test TimeSeriesTable packing for SimTK::UnitVec3." << std::endl;
         auto tableUVec3 = tableDouble.pack<SimTK::UnitVec3>();
         ASSERT(tableUVec3.getColumnLabels() == expLabels);
         ASSERT(tableUVec3.getNumRows()      == 3);
@@ -750,7 +748,7 @@ TEST_CASE("DataTable") {
         ASSERT(tableUVec3.getTableMetaData<int>("int")            == 10);
         std::cout << tableUVec3 << std::endl;
 
-        std::cout << "Test TimeSeriesTable packing for Quaternion." << std::endl;
+        std::cout << "Test TimeSeriesTable packing for SimTK::Quaternion." << std::endl;
         tableDouble.setColumnLabels({"col0.0", "col0.1", "col0.2", "col0.3",
                                      "col1.0", "col1.1", "col1.2", "col1.3",
                                      "col2.0", "col2.1", "col2.2", "col2.3"});
@@ -764,7 +762,7 @@ TEST_CASE("DataTable") {
         ASSERT(tableQuat.getTableMetaData<int>("int")            == 10);
         std::cout << tableQuat << std::endl;
 
-        std::cout << "Test TimeSeriesTable packing for SpatialVec" << std::endl;
+        std::cout << "Test TimeSeriesTable packing for SimTK::SpatialVec" << std::endl;
         tableDouble.setColumnLabels({"col0.0", "col0.1", "col0.2",
                                      "col0.3", "col0.4", "col0.5",
                                      "col1.0", "col1.1", "col1.2",
@@ -779,7 +777,7 @@ TEST_CASE("DataTable") {
         ASSERT(tableSVec.getTableMetaData<int>("int")            == 10);
         std::cout << tableSVec << std::endl;
 
-        std::cout << "Test TimeSeriesTable packing for Rotation" << std::endl;
+        std::cout << "Test TimeSeriesTable packing for SimTK::Rotation" << std::endl;
         TimeSeriesTable_<double> table{};
         table.setColumnLabels({"col0_0", "col0_1", "col0_2",
                                "col0_3", "col0_4", "col0_5",
@@ -787,9 +785,9 @@ TEST_CASE("DataTable") {
                                "col1_0", "col1_1", "col1_2",
                                "col1_3", "col1_4", "col1_5",
                                "col1_6", "col1_7", "col1_8"});
-        table.appendRow(1, RowVector(18, 1));
-        table.appendRow(2, RowVector(18, 2));
-        table.appendRow(3, RowVector(18, 3));
+        table.appendRow(1, SimTK::RowVector(18, 1));
+        table.appendRow(2, SimTK::RowVector(18, 2));
+        table.appendRow(3, SimTK::RowVector(18, 3));
         table.addTableMetaData("string", std::string{"string"});
         table.addTableMetaData("int", 10);
         ASSERT(table.getColumnLabels().size() == 18);
@@ -1006,7 +1004,7 @@ TEST_CASE("TableUtilities::resample") {
         REQUIRE(resampled.getNumColumns() == 1);
         CHECK(resampled.getIndependentColumn()[0] == 0.5);
 
-        const VectorView view = resampled.getDependentColumnAtIndex(0);
+        const SimTK::VectorView view = resampled.getDependentColumnAtIndex(0);
         CHECK(view[0] == Approx(0.75));
     }
     {
diff --git a/OpenSim/Common/Test/testFunctions.cpp b/OpenSim/Common/Test/testFunctions.cpp
index d854c914c..563420387 100644
--- a/OpenSim/Common/Test/testFunctions.cpp
+++ b/OpenSim/Common/Test/testFunctions.cpp
@@ -35,7 +35,6 @@
 #include <OpenSim/Common/PolynomialFunction.h>
 
 using namespace OpenSim;
-using namespace SimTK;
 using Catch::Approx;
 using Catch::Matchers::ContainsSubstring;
 
@@ -60,24 +59,24 @@ TEST_CASE("SignalGenerator") {
     world.addComponent(reporter);
 
     // Build the system.
-    MultibodySystem system;
+    SimTK::MultibodySystem system;
     world.buildUpSystem(system);
-    State s = system.realizeTopology();
-    system.realize(s, Stage::Model);
+    SimTK::State s = system.realizeTopology();
+    system.realize(s, SimTK::Stage::Model);
 
     // "Simulate."
     const int numTimePoints = 5;
     for (int i = 0; i < numTimePoints; ++i) {
         s.setTime(0.1 * i);
-        system.realize(s, Stage::Report);
+        system.realize(s, SimTK::Stage::Report);
     }
 
     // Check that the SignalGenerator produced the correct values.
-    const TimeSeriesTable_<Real>& results = reporter->getTable();
+    const TimeSeriesTable_<SimTK::Real>& results = reporter->getTable();
     REQUIRE(results.getNumRows() == numTimePoints);
     for (int i = 0; i < numTimePoints; ++i) {
         const double time = 0.1 * i;
-        system.realize(s, Stage::Report);
+        system.realize(s, SimTK::Stage::Report);
         CHECK(results.getRowAtIndex(i)[0] ==
                 Approx(amplitude * std::sin(omega * time + phase) + offset));
     }
@@ -106,7 +105,7 @@ TEST_CASE("Interpolate using PiecewiseLinearFunction") {
         SimTK_TEST_EQ(newY[2], 0.25);
         SimTK_TEST(!SimTK::isNaN(newY[3]));
     }
-    SECTION("First and last Y are NaN, extrapolate") {
+    SECTION("First and last Y are SimTK::NaN, extrapolate") {
         SimTK::Vector x = createVector({0, 1, 2, 3, 4, 5});
         SimTK::Vector y = createVector({SimTK::NaN, 0, 3, 4, SimTK::NaN, SimTK::NaN});
         SimTK::Vector newY = OpenSim::interpolate(x, y, x, true, true);
diff --git a/OpenSim/Common/Test/testNCSpline.cpp b/OpenSim/Common/Test/testNCSpline.cpp
index c88da31c6..cc628b2d8 100644
--- a/OpenSim/Common/Test/testNCSpline.cpp
+++ b/OpenSim/Common/Test/testNCSpline.cpp
@@ -31,8 +31,6 @@
 #include <cstdio>
 #include <iostream>
 #include <fstream>
-
-using namespace SimTK;
 using namespace OpenSim;
 using namespace std;
 
@@ -341,8 +339,8 @@ TEST_CASE("NC Spline")
 
     //Domain vector variables
     double xmin,xmax,deltaX,deltaD;
-    xmin = Pi/4;            //Value of first knot
-    xmax = Pi/2;            //Value of the final knot
+    xmin = SimTK::Pi/4;            //SimTK::Value of first knot
+    xmax = SimTK::Pi/2;            //SimTK::Value of the final knot
 
     deltaX = (xmax-xmin)/(size-1);
     deltaD = (xmax-xmin)/(sizeD-1);
@@ -413,7 +411,7 @@ TEST_CASE("NC Spline")
             yK(i,k) = tmp(k);
 
     }
-    SimTK:: Vector yKVal = yK(0);
+    SimTK::Vector yKVal = yK(0);
 
     //Get the function y, dy, ddy at the mid points
     for(int i=0; i<size-1;i++){
@@ -441,7 +439,7 @@ TEST_CASE("NC Spline")
 
     //SimTK::SplineFitter
     SimTK::Vector sfDerivs1(xK.size());
-    SimTK::Spline_<Real> sTK = SimTK::SplineFitter<Real>::fitForSmoothingParameter(3,xK,yKVal,0.0).getSpline();
+    SimTK::Spline_<SimTK::Real> sTK = SimTK::SplineFitter<SimTK::Real>::fitForSmoothingParameter(3,xK,yKVal,0.0).getSpline();
 
     ///////////////////////////////////////////
     //3. Test the splines
@@ -450,7 +448,7 @@ TEST_CASE("NC Spline")
     testResults(0) = testNCSpline(&sTK, xK, yK(0), xM, xD, "simtk_splinefitter",true);
     //testResults(1) = testNCSpline(ncs_simtkfcn, xK, yK(0), xM, xD,"opensim_natcubspline",true);
 
-    cout << "Test Result Matrix: 0 or small numbers pass" <<endl;
+    cout << "Test Result SimTK::Matrix: 0 or small numbers pass" <<endl;
     cout << "  column 0: SimTK::SplineFitter, column 1: OpenSim::NaturalCubicSpline" <<endl;
     cout << "  row 0: Passes through knots (tol 1e-14)" << endl;
     cout << "  row 1: First derivative is continuous and smooth (tol " << deltaD << ")" << endl;
@@ -489,4 +487,4 @@ TEST_CASE("NC Spline")
 
     cout << "\n\nNOTE: NO OPENSIM SPLINE TESTED (NC SPLINE NOT AVAILABLE YET)" << endl;
     cout << "  Only the Simbody SplineFitter is being tested." << endl;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Common/Test/testSerialization.cpp b/OpenSim/Common/Test/testSerialization.cpp
index 77b3314e7..0578ebb53 100644
--- a/OpenSim/Common/Test/testSerialization.cpp
+++ b/OpenSim/Common/Test/testSerialization.cpp
@@ -44,7 +44,6 @@
 #include "SerializableObject2.h"
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 class ObjSet : public Set<SerializableObject> {
@@ -93,7 +92,7 @@ static void testPropertyOutputHelper(const double& val, const std::string& ans)
     propertyDouble->setValue(val);
     double valOut = propertyDouble->getValue();
 
-    writeUnformatted(ss, valOut);
+    SimTK::writeUnformatted(ss, valOut);
     cout << std::to_string(valOut) << " " << ss.str() << " ";
     cout << propertyDouble->toString() << endl;
 
@@ -111,7 +110,7 @@ static void testPropertyOutputHelper(const int& val, const std::string& ans)
     propertyInt->setValue(val);
     double valOut = propertyInt->getValue();
 
-    writeUnformatted(ss, valOut);
+    SimTK::writeUnformatted(ss, valOut);
     cout << std::to_string(valOut) << " " << ss.str() << " ";
     cout << propertyInt->toString() << endl;
 
@@ -127,9 +126,9 @@ template <int M> static void testPropertyOutputHelper(const SimTK::Vec<M>& val,
         Property<SimTK::Vec<M>>::TypeHelper::create("VecM", true);
 
     propertyVec->setValue(val);
-    Vec<M> valOut = propertyVec->getValue();
+    SimTK::Vec<M> valOut = propertyVec->getValue();
 
-    writeUnformatted(ss, valOut);
+    SimTK::writeUnformatted(ss, valOut);
     cout << ss.str() << "\n";
     cout << propertyVec->toString() << endl;
 
@@ -138,16 +137,16 @@ template <int M> static void testPropertyOutputHelper(const SimTK::Vec<M>& val,
 
 static void testPropertyOutputHelper(const SimTK::Vector& val, const std::string& ans)
 {
-    cout << "(Vector)" << val << ":\n";
+    cout << "(SimTK::Vector)" << val << ":\n";
     stringstream ss;
 
     Property<SimTK::Vector>* propertyVector =
-        Property<SimTK::Vector>::TypeHelper::create("Vector", true);
+        Property<SimTK::Vector>::TypeHelper::create("SimTK::Vector", true);
 
     propertyVector->setValue(val);
-    Vector valOut = propertyVector->getValue();
+    SimTK::Vector valOut = propertyVector->getValue();
 
-    writeUnformatted(ss, valOut);
+    SimTK::writeUnformatted(ss, valOut);
     cout << ss.str() << "\n";
     cout << propertyVector->toString() << endl;
 
@@ -156,16 +155,16 @@ static void testPropertyOutputHelper(const SimTK::Vector& val, const std::string
 
 static void testPropertyOutputHelper(const SimTK::Transform& val)
 {
-    cout << "(Transform)" << val << ":\n";
+    cout << "(SimTK::Transform)" << val << ":\n";
     stringstream ss;
 
     Property<SimTK::Transform>* propertyTransform =
-        Property<SimTK::Transform>::TypeHelper::create("Transform", true);
+        Property<SimTK::Transform>::TypeHelper::create("SimTK::Transform", true);
 
     propertyTransform->setValue(val);
     SimTK::Transform valOut = propertyTransform->getValue();
 
-    writeUnformatted(ss, valOut);
+    SimTK::writeUnformatted(ss, valOut);
     cout << ss.str() << "\n";
     cout << propertyTransform->toString() << endl;
 }
@@ -178,24 +177,24 @@ TEST_CASE("Object Serialization")
     stringstream sout;
     while (true) {
         SimTK::String token;
-        readUnformatted(ss, token);
+        SimTK::readUnformatted(ss, token);
         if (ss.fail()) break;
         cout << "'" << token << "'\n";
     }
     ss.clear();
     ss.seekg(0, ios::beg);
     SimTK::Array_<SimTK::String> arrTokens;
-    readUnformatted(ss, arrTokens);
+    SimTK::readUnformatted(ss, arrTokens);
     cout << arrTokens << endl;
 
-    writeUnformatted(sout, true);
+    SimTK::writeUnformatted(sout, true);
     sout << " ";
-    writeUnformatted(sout, false);
+    SimTK::writeUnformatted(sout, false);
     cout << "'" << sout.str() << "'\n";
     sout.seekg(0, ios::beg);
     while (true) {
         bool res;
-        if (!readUnformatted(sout, res))
+        if (!SimTK::readUnformatted(sout, res))
             break;
         cout << res << "\n";
     }
@@ -221,7 +220,7 @@ TEST_CASE("Object Serialization")
     testPropertyOutputHelper((int)123456789, "123456789");
     testPropertyOutputHelper((int)0, "0");
 
-    // Don't test std::to_string for Vec, Vector, and Transforms
+    // Don't test std::to_string for Vec, SimTK::Vector, and Transforms
     cout << "Input:  SimTK::writeUnformatted() Property::toString()" << endl;
 
     testPropertyOutputHelper(SimTK::Vec3(0, 0, 0), "(0 0 0)");
@@ -230,7 +229,7 @@ TEST_CASE("Object Serialization")
     testPropertyOutputHelper(SimTK::Vector(4, -1234567), 
         "(-1.23457e+06 -1.23457e+06 -1.23457e+06 -1.23457e+06)");
 
-    Vec3 p = Vec3(0.1, 0.2, 0.12345678);
+    SimTK::Vec3 p = SimTK::Vec3(0.1, 0.2, 0.12345678);
     SimTK::Rotation R = SimTK::Rotation(SimTK::Pi, SimTK::XAxis);
     // this does not check against a string because random "-0"s show up in place of "0"s
     testPropertyOutputHelper(SimTK::Transform(R, p));
@@ -327,7 +326,7 @@ TEST_CASE("Object Serialization")
     string& str2 = ((PropertyStr*) propSet2.get(6))->getValueStr();
     int cmp=str1.compare(str2);
     if (cmp!=0) {
-        throw OpenSim::Exception("String property",__FILE__,__LINE__);
+        throw OpenSim::Exception("SimTK::String property",__FILE__,__LINE__);
     }
 
     for (int i=0; i < obj1.getNumProperties(); ++i) {
@@ -379,4 +378,4 @@ TEST_CASE("Object Serialization")
     int notFound = objWithListProp.getProperty_list_SerializableObject().findIndexForName("Third");
     ASSERT(notFound == -1);
     SimTK_TEST_MUST_THROW(SerializableObject bad("obj1Bad.xml"));
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Common/Test/testSmoothSegmentedFunctionFactory.cpp b/OpenSim/Common/Test/testSmoothSegmentedFunctionFactory.cpp
index 487092939..456521481 100644
--- a/OpenSim/Common/Test/testSmoothSegmentedFunctionFactory.cpp
+++ b/OpenSim/Common/Test/testSmoothSegmentedFunctionFactory.cpp
@@ -49,9 +49,6 @@
 
 using namespace std;
 using namespace OpenSim;
-using namespace SimTK;
-
-
 /**
 This function will print cvs file of the column vector col0 and the matrix 
  data
@@ -490,7 +487,7 @@ TEST_CASE("Quintic Bezier Curve Exceptions")
         x(i)=SegmentedQuinticBezierToolkit::calcQuinticBezierCurveVal(u(i), xPts);
     }
 
-    aSplineUX[0] = SimTK::SplineFitter<Real>::
+    aSplineUX[0] = SimTK::SplineFitter<SimTK::Real>::
             fitForSmoothingParameter(3,x,u,0).getSpline();
     //Now we have a curve.
 
@@ -1122,19 +1119,19 @@ void testMonotonicity(SimTK::Matrix mcfSample)
 }
 
 /*
- 5. Tests the output when NaN is the input.
+ 5. Tests the output when SimTK::NaN is the input.
 */
 template<typename F>
 void testMuscleCurveNaNBehavior(const F& curve)
 {
-    cout << "   TEST: NaN behavior. " << endl;
+    cout << "   TEST: SimTK::NaN behavior. " << endl;
 
-    // Curve value at NaN gives NaN.
+    // Curve value at SimTK::NaN gives SimTK::NaN.
     SimTK_TEST(std::isnan(curve.calcValue(SimTK::NaN)));
     SimTK_TEST(std::isnan(curve.calcDerivative(SimTK::NaN, 1)));
     SimTK_TEST(std::isnan(curve.calcDerivative(SimTK::NaN, 2)));
 
-    cout << "    passed testing NaN behavior." << endl;
+    cout << "    passed testing SimTK::NaN behavior." << endl;
 }
 
 //______________________________________________________________________________
@@ -1210,7 +1207,7 @@ TEST_CASE("SmoothSegmentedFunctionFactory")
         testMuscleCurveC2Continuity(tendonCurve,tendonCurveSample);
     //4. Test for monotonicity where appropriate
         testMonotonicity(tendonCurveSample);
-    //5. Test NaN behavior.
+    //5. Test SimTK::NaN behavior.
         testMuscleCurveNaNBehavior(tendonCurve);
 
     //6. Testing Exceptions
@@ -1282,7 +1279,7 @@ TEST_CASE("SmoothSegmentedFunctionFactory")
     //4. Test for monotonicity where appropriate
 
         testMonotonicity(fiberFLCurveSample);
-    //5. Test NaN behavior.
+    //5. Test SimTK::NaN behavior.
         testMuscleCurveNaNBehavior(fiberFLCurve);
 
     //6. Testing Exceptions
@@ -1353,7 +1350,7 @@ TEST_CASE("SmoothSegmentedFunctionFactory")
     //4. Test for monotonicity where appropriate
 
         testMonotonicity(fiberCECurveSample);
-    //5. Test NaN behavior.
+    //5. Test SimTK::NaN behavior.
         testMuscleCurveNaNBehavior(fiberCECurve);
     //6. Testing Exceptions
         cout << endl;
@@ -1419,7 +1416,7 @@ TEST_CASE("SmoothSegmentedFunctionFactory")
         testMuscleCurveC2Continuity(fiberCEPhiCurve,fiberCEPhiCurveSample);
     //4. Test for monotonicity where appropriate
         testMonotonicity(fiberCEPhiCurveSample);
-    //5. Test NaN behavior.
+    //5. Test SimTK::NaN behavior.
         testMuscleCurveNaNBehavior(fiberCEPhiCurve);
     //6. Testing Exceptions
         cout << endl;
@@ -1494,7 +1491,7 @@ TEST_CASE("SmoothSegmentedFunctionFactory")
     //4. Test for monotonicity where appropriate
 
         testMonotonicity(fiberCECosPhiCurveSample);
-    //5. Test NaN behavior.
+    //5. Test SimTK::NaN behavior.
         testMuscleCurveNaNBehavior(fiberCECosPhiCurve);
     //6. Test exceptions
         cout << endl;
@@ -1586,7 +1583,7 @@ TEST_CASE("SmoothSegmentedFunctionFactory")
     //4. Test for monotonicity where appropriate
 
         testMonotonicity(fiberFVCurveSample);
-    //5. Test NaN behavior.
+    //5. Test SimTK::NaN behavior.
         testMuscleCurveNaNBehavior(fiberFVCurve);
     //6. Exception testing
         cout << endl;    
@@ -1699,7 +1696,7 @@ TEST_CASE("SmoothSegmentedFunctionFactory")
     //4. Test for monotonicity where appropriate
 
         testMonotonicity(fiberFVInvCurveSample);
-    //5. Test NaN behavior.
+    //5. Test SimTK::NaN behavior.
         testMuscleCurveNaNBehavior(fiberFVInvCurve);
 
     //6. Testing the exceptions
@@ -1912,5 +1909,4 @@ TEST_CASE("SmoothSegmentedFunctionFactory")
             fiberfalCurve.printMuscleCurveToCSVFile("C:/aBadPath",0,2.0));
         //fiberfalCurve.printMuscleCurveToCSVFile("C:/mjhmilla/Stanford/dev");
         cout << "    passed"<<endl;
-}
-
+}
\ No newline at end of file
diff --git a/OpenSim/Examples/ControllerExample/ControllerExample.cpp b/OpenSim/Examples/ControllerExample/ControllerExample.cpp
index 86b67a677..e24728a29 100644
--- a/OpenSim/Examples/ControllerExample/ControllerExample.cpp
+++ b/OpenSim/Examples/ControllerExample/ControllerExample.cpp
@@ -42,9 +42,6 @@ using namespace OpenSim;
 
 // This allows us to use SimTK functions, classes, etc., without having to
 // prefix the names of those things with "SimTK::".
-using namespace SimTK;
-
-
 //______________________________________________________________________________
 /**
  * The controller will try to make the model follow this position
@@ -52,7 +49,7 @@ using namespace SimTK;
  */
 double desiredModelZPosition( double t ) {
     // z(t) = 0.15 sin( pi * t )
-    return 0.15 * sin( Pi * t );
+    return 0.15 * sin( SimTK::Pi * t );
 }
 //////////////////////////////////////////////////////////////////////
 // 1) Add a function to compute the desired velocity of the model   //
@@ -65,7 +62,7 @@ double desiredModelZPosition( double t ) {
  */
 double desiredModelZAcceleration( double t ) {
     // z''(t) = -(0.15*pi^2) sin( pi * t )
-    return -0.15 * Pi * Pi * sin( Pi * t );
+    return -0.15 * SimTK::Pi * SimTK::Pi * sin( SimTK::Pi * t );
 }
 
 //______________________________________________________________________________
@@ -197,7 +194,7 @@ public:
             rightControl = rightMuscle->getMaxControl();
 
         // Thelen muscle has only one control
-        Vector muscleControl(1, leftControl);
+        SimTK::Vector muscleControl(1, leftControl);
         // Add in the controls computed for this muscle to the set of all model controls
         leftMuscle->addInControls(muscleControl, controls);
         // Specify control for other actuator (muscle) controlled by this controller
@@ -278,7 +275,7 @@ int main()
         Coordinate& zCoord = modelCoordinateSet.
             get( "blockToGround_zTranslation" );
         // Set z translation speed value.
-        zCoord.setSpeedValue( si, 0.15 * Pi );
+        zCoord.setSpeedValue( si, 0.15 * SimTK::Pi );
 
         // Define the initial muscle states.
         const Set<Muscle>& muscleSet = osimModel.getMuscles();
@@ -337,4 +334,4 @@ int main()
     // If this program executed up to this line, return 0 to
     // indicate that the intended lines of code were executed.
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Examples/ControllerExample/OutputReference/ControllerExample_Solution.cpp b/OpenSim/Examples/ControllerExample/OutputReference/ControllerExample_Solution.cpp
index c80a7f659..8ec6d4d98 100644
--- a/OpenSim/Examples/ControllerExample/OutputReference/ControllerExample_Solution.cpp
+++ b/OpenSim/Examples/ControllerExample/OutputReference/ControllerExample_Solution.cpp
@@ -42,9 +42,6 @@ using namespace OpenSim;
 
 // This allows us to use SimTK functions, classes, etc., without having to
 // prefix the names of those things with "SimTK::".
-using namespace SimTK;
-
-
 //______________________________________________________________________________
 /**
  * The controller will try to make the model follow this position
@@ -52,7 +49,7 @@ using namespace SimTK;
  */
 double desiredModelZPosition( double t ) {
     // z(t) = 0.15 sin( pi * t )
-    return 0.15 * sin( Pi * t );
+    return 0.15 * sin( SimTK::Pi * t );
 }
 
 /**
@@ -61,7 +58,7 @@ double desiredModelZPosition( double t ) {
  */
 double desiredModelZVelocity( double t ) {
     // z(t) = 0.15 sin( pi * t )
-    return 0.15 * Pi * cos( Pi * t );
+    return 0.15 * SimTK::Pi * cos( SimTK::Pi * t );
 }
 //______________________________________________________________________________
 /**
@@ -70,7 +67,7 @@ double desiredModelZVelocity( double t ) {
  */
 double desiredModelZAcceleration( double t ) {
     // z''(t) = -(0.15*pi^2) sin( pi * t )
-    return -0.15 * Pi * Pi * sin( Pi * t );
+    return -0.15 * SimTK::Pi * SimTK::Pi * sin( SimTK::Pi * t );
 }
 
 //______________________________________________________________________________
@@ -177,7 +174,7 @@ public:
         if( rightControl > 1.0 ) rightControl = 1.0;
 
         // Thelen muscle has only one control
-        Vector muscleControl(1, leftControl);
+        SimTK::Vector muscleControl(1, leftControl);
         // Add in the controls computed for this muscle to the set of all model controls
         leftMuscle->addInControls(muscleControl, controls);
         // Specify control for other actuator (muscle) controlled by this controller
@@ -246,7 +243,7 @@ int main()
         Coordinate& zCoord = modelCoordinateSet.
             get( "blockToGround_zTranslation" );
         // Set z translation speed value.
-        zCoord.setSpeedValue( si, 0.15 * Pi );
+        zCoord.setSpeedValue( si, 0.15 * SimTK::Pi );
 
         // Define the initial muscle states.
         const Set<Muscle>& muscleSet = osimModel.getMuscles();
@@ -305,4 +302,4 @@ int main()
     // If this program executed up to this line, return 0 to
     // indicate that the intended lines of code were executed.
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Examples/CustomActuatorExample/toyLeg_example.cpp b/OpenSim/Examples/CustomActuatorExample/toyLeg_example.cpp
index 3dfa51c9a..3fdb122c8 100644
--- a/OpenSim/Examples/CustomActuatorExample/toyLeg_example.cpp
+++ b/OpenSim/Examples/CustomActuatorExample/toyLeg_example.cpp
@@ -40,8 +40,6 @@
 #include "OpenSim/Common/STOFileAdapter.h"
 
 using namespace OpenSim;
-using namespace SimTK;
-
 int main()
 {
     try {
@@ -50,7 +48,7 @@ int main()
         osimModel.setName("osimModel");
         osimModel.setAuthors("Matt DeMers");
 
-        double Pi = SimTK::Pi;
+        double SimTK::Pi = SimTK::Pi;
             
         // Get the ground body.
         Ground& ground = osimModel.updGround();
@@ -59,9 +57,9 @@ int main()
         // Create linkage body.
         double linkageMass = 0.001, linkageLength = 0.5, linkageDiameter = 0.06;
         
-        Vec3 linkageMassCenter(0,linkageLength/2,0);
-        Inertia linkageInertia =
-            Inertia::cylinderAlongY(linkageDiameter/2.0, linkageLength/2.0);
+        SimTK::Vec3 linkageMassCenter(0,linkageLength/2,0);
+        SimTK::Inertia linkageInertia =
+            SimTK::Inertia::cylinderAlongY(linkageDiameter/2.0, linkageLength/2.0);
 
         OpenSim::Body* linkage1 = new OpenSim::Body("linkage1", linkageMass,
                 linkageMassCenter, linkageMass*linkageInertia);
@@ -71,7 +69,7 @@ int main()
         linkage1->attachGeometry(sphere.clone());
         Cylinder cyl(linkageDiameter/2, linkageLength/2);
         Frame* cyl1Frame = new PhysicalOffsetFrame(*linkage1, 
-            Transform(Vec3(0.0, linkageLength / 2.0, 0.0)));
+            SimTK::Transform(SimTK::Vec3(0.0, linkageLength / 2.0, 0.0)));
         cyl1Frame->setName("Cyl1_frame");
         cyl1Frame->attachGeometry(cyl.clone());
         osimModel.addComponent(cyl1Frame);
@@ -81,15 +79,15 @@ int main()
                 linkageMassCenter, linkageMass*linkageInertia);
         linkage2->attachGeometry(sphere.clone());
         Frame* cyl2Frame = new PhysicalOffsetFrame(*linkage2,
-            Transform(Vec3(0.0, linkageLength / 2.0, 0.0)));
+            SimTK::Transform(SimTK::Vec3(0.0, linkageLength / 2.0, 0.0)));
         cyl2Frame->setName("Cyl2_frame");
         cyl2Frame->attachGeometry(cyl.clone());
         osimModel.addComponent(cyl2Frame);
 
         // Create a block to be the pelvis.
         double blockMass = 20.0, blockSideLength = 0.2;
-        Vec3 blockMassCenter(0);
-        Inertia blockInertia = blockMass*Inertia::brick(blockSideLength,
+        SimTK::Vec3 blockMassCenter(0);
+        SimTK::Inertia blockInertia = blockMass*SimTK::Inertia::brick(blockSideLength,
                 blockSideLength, blockSideLength);
         OpenSim::Body* block = new OpenSim::Body("block", blockMass,
                 blockMassCenter, blockInertia);
@@ -97,11 +95,11 @@ int main()
 
         // Create 1 degree-of-freedom pin joints between the bodies to create a
         // kinematic chain from ground through the block.
-        Vec3 orientationInGround(0);
-        Vec3 locationInGround(0);
-        Vec3 locationInParent(0.0, linkageLength, 0.0);
-        Vec3 orientationInChild(0);
-        Vec3 locationInChild(0);
+        SimTK::Vec3 orientationInGround(0);
+        SimTK::Vec3 locationInGround(0);
+        SimTK::Vec3 locationInParent(0.0, linkageLength, 0.0);
+        SimTK::Vec3 orientationInChild(0);
+        SimTK::Vec3 locationInChild(0);
 
         PinJoint* ankle = new PinJoint("ankle",
                 ground, locationInGround, orientationInGround,
@@ -136,14 +134,14 @@ int main()
         osimModel.addJoint(hip);
         // Define constraints on the model
         // Add a point on line constraint to limit the block to vertical motion
-        Vec3 lineDirection(0,1,0), pointOnLine(0,0,0), pointOnBlock(0);
+        SimTK::Vec3 lineDirection(0,1,0), pointOnLine(0,0,0), pointOnBlock(0);
         PointOnLineConstraint *lineConstraint =
             new PointOnLineConstraint(ground, lineDirection, pointOnLine,
                     *block, pointOnBlock);
         osimModel.addConstraint(lineConstraint);
 
         // Add PistonActuator between the first linkage and the block
-        Vec3 pointOnBodies(0);
+        SimTK::Vec3 pointOnBodies(0);
         PistonActuator* piston = new PistonActuator();
         piston->setName("piston");
         piston->setFrameA(*linkage1);
@@ -192,7 +190,7 @@ int main()
         osimModel.addController(legController);     
         
         // define the acceleration due to gravity
-        osimModel.setGravity(Vec3(0, -9.80665, 0));
+        osimModel.setGravity(SimTK::Vec3(0, -9.80665, 0));
 
         // Set to true to visualize the simulation, which can be useful for
         // debugging.
@@ -202,7 +200,7 @@ int main()
         SimTK::State& si = osimModel.initSystem();
         
         // Pin joint initial states
-        double q1_i = -Pi/4;
+        double q1_i = -SimTK::Pi/4;
         double q2_i = - 2*q1_i;
         CoordinateSet &coordinates = osimModel.updCoordinateSet();
         coordinates[0].setValue(si, q1_i, true);
@@ -253,4 +251,4 @@ int main()
 
     std::cout << "Done." << std::endl;
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Examples/ExampleLuxoMuscle/LuxoMuscle_create_and_simulate.cpp b/OpenSim/Examples/ExampleLuxoMuscle/LuxoMuscle_create_and_simulate.cpp
index 9a19d8220..c55ee4802 100644
--- a/OpenSim/Examples/ExampleLuxoMuscle/LuxoMuscle_create_and_simulate.cpp
+++ b/OpenSim/Examples/ExampleLuxoMuscle/LuxoMuscle_create_and_simulate.cpp
@@ -34,15 +34,13 @@
 #include "OpenSim/Common/STOFileAdapter.h"
 
 using namespace OpenSim;
-using namespace SimTK;
-
 //______________________________________________________________________________
 /**
  * Material and Mechanical Constants:
  */
 
 // TO DO: Find a way to set an ideal camera pose
-UnitVec3 camera_offset_direction(1,1,1);
+SimTK::UnitVec3 camera_offset_direction(1,1,1);
 double camera_offset_distance = 2; // meters
 
 
@@ -100,53 +98,53 @@ double baseHeight = 0.027225; // meters
 
 //bracket
 double bracket_location = 0.03; // meters
-Vec3 posterior_bracket_hinge_location(-0.01, -0.01, 0.0); // meters
-Vec3 anterior_bracket_hinge_location(0.01, 0.003, 0.0); // meters
-Vec3 pivot_damping(0.02);
+SimTK::Vec3 posterior_bracket_hinge_location(-0.01, -0.01, 0.0); // meters
+SimTK::Vec3 anterior_bracket_hinge_location(0.01, 0.003, 0.0); // meters
+SimTK::Vec3 pivot_damping(0.02);
 
 // leg bar
-Vec3 leg_bar_dimensions(0.006980, 0.046992, 0.006979); // meters
-Vec3 superior_bar_hinge_location(0.0,
+SimTK::Vec3 leg_bar_dimensions(0.006980, 0.046992, 0.006979); // meters
+SimTK::Vec3 superior_bar_hinge_location(0.0,
                         0.5*(leg_bar_dimensions[1] - leg_bar_dimensions[0]),
                         0.0);
-Vec3 inferior_bar_hinge_location = -1*superior_bar_hinge_location;
+SimTK::Vec3 inferior_bar_hinge_location = -1*superior_bar_hinge_location;
 
 // leg Hlink
-Vec3 leg_Hlink_dimensions(0.005211, 0.051740, 0.031919); // meters
-Vec3 superior_Hlink_hinge_location(0.0,
+SimTK::Vec3 leg_Hlink_dimensions(0.005211, 0.051740, 0.031919); // meters
+SimTK::Vec3 superior_Hlink_hinge_location(0.0,
                                    0.4*leg_Hlink_dimensions[1],
                                    0.0);
-Vec3 inferior_Hlink_hinge_location(0.0,
+SimTK::Vec3 inferior_Hlink_hinge_location(0.0,
                                    -0.45*leg_Hlink_dimensions[1],
                                    0.0);
 
 // pelvis bracket
-Vec3 pelvis_dimensions(0.027673, 0.044470, 0.009772); // meters
-Vec3 inferior_pelvis_pin_location(-0.006, -0.015, 0.0);
-Vec3 anterior_superior_pelvis_pin_location(0.0135, 0.002,0.0);
-Vec3 posterior_superior_pelvis_pin_location(-0.004, 0.022, 0.0);
+SimTK::Vec3 pelvis_dimensions(0.027673, 0.044470, 0.009772); // meters
+SimTK::Vec3 inferior_pelvis_pin_location(-0.006, -0.015, 0.0);
+SimTK::Vec3 anterior_superior_pelvis_pin_location(0.0135, 0.002,0.0);
+SimTK::Vec3 posterior_superior_pelvis_pin_location(-0.004, 0.022, 0.0);
 
 //  torso bars
-Vec3 torso_bar_dimensions(0.003599, 0.049114, 0.003599);
-Vec3 superior_torso_hinge_location(0.0,
+SimTK::Vec3 torso_bar_dimensions(0.003599, 0.049114, 0.003599);
+SimTK::Vec3 superior_torso_hinge_location(0.0,
                                    0.45*torso_bar_dimensions[1],
                                    0.0);
-Vec3 inferior_torso_hinge_location(0.0,
+SimTK::Vec3 inferior_torso_hinge_location(0.0,
                                    -0.45*torso_bar_dimensions[1],
                                    0.0);
-Vec3 back_peg_center = inferior_torso_hinge_location*0.85;
-Vec3 peg_z_offset(0.0,0.0,0.0178);
+SimTK::Vec3 back_peg_center = inferior_torso_hinge_location*0.85;
+SimTK::Vec3 peg_z_offset(0.0,0.0,0.0178);
 
 // shoulder bracket
-Vec3 shoulder_dimensions(0.024053, 0.030492, 0.013800); // meters
-Vec3 anterior_thoracic_joint_center(0.003418, -0.0163, 0.0);
-Vec3 posterior_thoracic_joint_center(-0.01240, 0.0, 0.0);
-Vec3 superior_shoulder_hinge_location(0.005,0.005,0.0);
+SimTK::Vec3 shoulder_dimensions(0.024053, 0.030492, 0.013800); // meters
+SimTK::Vec3 anterior_thoracic_joint_center(0.003418, -0.0163, 0.0);
+SimTK::Vec3 posterior_thoracic_joint_center(-0.01240, 0.0, 0.0);
+SimTK::Vec3 superior_shoulder_hinge_location(0.005,0.005,0.0);
 
 // head lamp
 double head_mass = 0.25*total_mass; // kg
-Vec3 head_dimension(0.067823, 0.078413, 0.078412);
-Vec3 cervicle_joint_center(-0.01717, -0.03506, 0.0);
+SimTK::Vec3 head_dimension(0.067823, 0.078413, 0.078412);
+SimTK::Vec3 cervicle_joint_center(-0.01717, -0.03506, 0.0);
 
 
 
@@ -158,24 +156,24 @@ double pennationAngle = 0.0;
 double knee_extensor_F0 = 100.0,
        knee_extensor_lm0 = 0.02,
        knee_extensor_lts = 0.0;
-Vec3 knee_extensor_insertion(0.0101, 0.0136, 0.0089),
+SimTK::Vec3 knee_extensor_insertion(0.0101, 0.0136, 0.0089),
      knee_extensor_origin(0.0, 0.0018, knee_extensor_insertion[2]);
 
 
 double back_extensor_F0 = 100.0,
        back_extensor_lm0 = 0.035,
        back_extensor_lts = 0.01;
-Vec3 back_extensor_origin = 0.5*peg_z_offset,
+SimTK::Vec3 back_extensor_origin = 0.5*peg_z_offset,
 back_extensor_insertion = back_peg_center + 0.5*peg_z_offset;
 
 // Frame locations for assistive device attachments
 //--------------------------------------------------
-Transform back_assist_origin_transform(back_peg_center); // in chest piece
-Transform back_assist_insertion_transform(
+SimTK::Transform back_assist_origin_transform(back_peg_center); // in chest piece
+SimTK::Transform back_assist_insertion_transform(
                                   posterior_superior_pelvis_pin_location);
 
-Transform knee_assist_origin_transform(Vec3(0)); // in posterior leg bar
-Transform knee_assist_insertion_transform(Vec3(knee_extensor_insertion[0],
+SimTK::Transform knee_assist_origin_transform(SimTK::Vec3(0)); // in posterior leg bar
+SimTK::Transform knee_assist_insertion_transform(SimTK::Vec3(knee_extensor_insertion[0],
                                                knee_extensor_insertion[1],
                                                0.0));
 
@@ -213,8 +211,8 @@ int main(int argc, char* argv[]) {
         luxo.updDisplayHints().set_show_frames(true);
         
         // Pose the model
-        State& state = luxo.initSystem();
-        std::cout << "State initialized." << std::endl;
+        SimTK::State& state = luxo.initSystem();
+        std::cout << "SimTK::State initialized." << std::endl;
         
         // Configure the 3D visualizer environment
         Visualizer* viz{};
@@ -228,10 +226,10 @@ int main(int argc, char* argv[]) {
         SimTK::Transform camera_pose(
                              camera_offset_distance*camera_offset_direction);
         camera_pose.updR().setRotationFromOneAxis(
-                              camera_offset_direction.negate(), ZAxis);
+                              camera_offset_direction.negate(), SimTK::ZAxis);
         
         //viz.setCameraTransform(camera_pose);
-        //viz.pointCameraAt(camera_look_at, Vec3(0,1,0));
+        //viz.pointCameraAt(camera_look_at, SimTK::Vec3(0,1,0));
         
         // show the model!
         if(showVisualizer)
@@ -314,8 +312,8 @@ void createLuxoJr(OpenSim::Model& model){
     
     // Create base
     //--------------
-    OpenSim::Body* base = new OpenSim::Body("base", baseMass, Vec3(0.0),
-                Inertia::cylinderAlongY(0.1, baseHeight));
+    OpenSim::Body* base = new OpenSim::Body("base", baseMass, SimTK::Vec3(0.0),
+                SimTK::Inertia::cylinderAlongY(0.1, baseHeight));
     
     // Add visible geometry
     base->attachGeometry(new Mesh("Base_meters.obj"));
@@ -324,9 +322,9 @@ void createLuxoJr(OpenSim::Model& model){
     // Define base to float relative to ground via free joint
     FreeJoint* base_ground = new FreeJoint("base_ground",
                 // parent body, location in parent body, orientation in parent
-                model.getGround(), Vec3(0.0), Vec3(0.0),
+                model.getGround(), SimTK::Vec3(0.0), SimTK::Vec3(0.0),
                 // child body, location in child body, orientation in child
-                *base, Vec3(0.0,-baseHeight/2.0,0.0),Vec3(0.0));
+                *base, SimTK::Vec3(0.0,-baseHeight/2.0,0.0),SimTK::Vec3(0.0));
     
     // add base to model
     model.addBody(base); model.addJoint(base_ground);
@@ -338,9 +336,9 @@ void createLuxoJr(OpenSim::Model& model){
     // Fix a frame to the base axis for attaching the bottom bracket
     SimTK::Transform* shift_and_rotate = new SimTK::Transform();
     //shift_and_rotate->setToZero();
-    shift_and_rotate->set(Rotation(-1*SimTK::Pi/2,
+    shift_and_rotate->set(SimTK::Rotation(-1*SimTK::Pi/2,
                                    SimTK::CoordinateAxis::XCoordinateAxis()),
-                          Vec3(0.0, bracket_location, 0.0));
+                          SimTK::Vec3(0.0, bracket_location, 0.0));
 
     auto* pivot_frame_on_base = new PhysicalOffsetFrame("pivot_frame_on_base",
             *base, *shift_and_rotate);
@@ -348,13 +346,13 @@ void createLuxoJr(OpenSim::Model& model){
     // Create bottom bracket
     //-----------------------
     OpenSim::Body* bottom_bracket = new OpenSim::Body("bottom_bracket",
-                                            bracket_mass, Vec3(0.0),
-                                            Inertia::brick(0.03, 0.03, 0.015));
+                                            bracket_mass, SimTK::Vec3(0.0),
+                                            SimTK::Inertia::brick(0.03, 0.03, 0.015));
     // add bottom bracket to model
     model.addBody(bottom_bracket);
     
     // Fix a frame to the bracket for attaching joint
-    shift_and_rotate->setP(Vec3(0.0));
+    shift_and_rotate->setP(SimTK::Vec3(0.0));
     auto* pivot_frame_on_bottom_bracket = new PhysicalOffsetFrame(
         "pivot_frame_on_bottom_bracket", *bottom_bracket, *shift_and_rotate);
     
@@ -386,18 +384,18 @@ void createLuxoJr(OpenSim::Model& model){
     //-----------------------
     OpenSim::Body* posteriorLegBar = new OpenSim::Body("posterior_leg_bar",
                                     bar_mass,
-                                    Vec3(0.0),
-                                    Inertia::brick(leg_bar_dimensions/2.0));
+                                    SimTK::Vec3(0.0),
+                                    SimTK::Inertia::brick(leg_bar_dimensions/2.0));
     
     posteriorLegBar->attachGeometry(new Mesh("Leg_meters.obj"));
 
     auto* posterior_knee_on_bottom_bracket = new PhysicalOffsetFrame(
         "posterior_knee_on_bottom_bracket",
-            *bottom_bracket, Transform(posterior_bracket_hinge_location) );
+            *bottom_bracket, SimTK::Transform(posterior_bracket_hinge_location) );
 
     auto* posterior_knee_on_posterior_bar = new PhysicalOffsetFrame(
         "posterior_knee_on_posterior_bar",
-            *posteriorLegBar, Transform(inferior_bar_hinge_location) );
+            *posteriorLegBar, SimTK::Transform(inferior_bar_hinge_location) );
 
     // Attach posterior leg to bottom bracket using another pin joint.
     // Another way to reference physical frames in a joint is by creating them
@@ -421,20 +419,20 @@ void createLuxoJr(OpenSim::Model& model){
     //----------------------------
     OpenSim::Body* leg_Hlink = new OpenSim::Body("leg_Hlink",
                                     bar_mass,
-                                    Vec3(0.0),
-                                    Inertia::brick(leg_Hlink_dimensions/2.0));
+                                    SimTK::Vec3(0.0),
+                                    SimTK::Inertia::brick(leg_Hlink_dimensions/2.0));
     
     leg_Hlink->attachGeometry(new Mesh("H_Piece_meters.obj"));
     
     
     auto* anterior_knee_on_bottom_bracket = new PhysicalOffsetFrame(
         "anterior_knee_on_bottom_bracket",
-            *bottom_bracket, Transform(anterior_bracket_hinge_location));
+            *bottom_bracket, SimTK::Transform(anterior_bracket_hinge_location));
 
     
     auto* anterior_knee_on_anterior_bar = new PhysicalOffsetFrame(
         "anterior_knee_on_anterior_bar",
-            *leg_Hlink, Transform(inferior_Hlink_hinge_location));
+            *leg_Hlink, SimTK::Transform(inferior_Hlink_hinge_location));
 
 
     // Connect anterior leg to bottom bracket via pin joint
@@ -456,8 +454,8 @@ void createLuxoJr(OpenSim::Model& model){
     //-----------------------
     OpenSim::Body* pelvisBracket = new OpenSim::Body("pelvis_bracket",
                                             bracket_mass,
-                                            Vec3(0.0),
-                                        Inertia::brick(pelvis_dimensions/2.0));
+                                            SimTK::Vec3(0.0),
+                                        SimTK::Inertia::brick(pelvis_dimensions/2.0));
     
     pelvisBracket->attachGeometry(new Mesh("Pelvis_bracket_meters.obj"));
     
@@ -467,7 +465,7 @@ void createLuxoJr(OpenSim::Model& model){
 
     auto* anterior_hip_on_Hlink = new PhysicalOffsetFrame(
         "anterior_hip_on_Hlink",
-        *leg_Hlink, Transform(superior_Hlink_hinge_location));
+        *leg_Hlink, SimTK::Transform(superior_Hlink_hinge_location));
 
     auto* anterior_hip_on_pelvis = new PhysicalOffsetFrame(
             "anterior_hip_on_pelvis",
@@ -495,7 +493,7 @@ void createLuxoJr(OpenSim::Model& model){
         new OpenSim::PointOnLineConstraint();
     
     posteriorHip->connectSocket_line_body(*pelvisBracket);
-    posteriorHip->setLineDirection(Vec3(0.0,0.0,1.0));
+    posteriorHip->setLineDirection(SimTK::Vec3(0.0,0.0,1.0));
     posteriorHip->setPointOnLine(inferior_pelvis_pin_location);
     posteriorHip->connectSocket_follower_body(*posteriorLegBar);
     posteriorHip->setPointOnFollower(superior_bar_hinge_location);
@@ -506,18 +504,18 @@ void createLuxoJr(OpenSim::Model& model){
     // Create chest piece
     //-----------------------
     OpenSim::Body* chest = new OpenSim::Body("chest_bar", bar_mass,
-                                     Vec3(0.0),
-                                     Inertia::brick(torso_bar_dimensions/2.0));
+                                     SimTK::Vec3(0.0),
+                                     SimTK::Inertia::brick(torso_bar_dimensions/2.0));
     
     chest->attachGeometry(new Mesh("Anterior_torso_bar.obj"));
 
     auto* anterior_torso_hinge_on_pelvis = new PhysicalOffsetFrame(
         "anterior_torso_hinge_on_pelvis",
-        *pelvisBracket, Transform(anterior_superior_pelvis_pin_location) );
+        *pelvisBracket, SimTK::Transform(anterior_superior_pelvis_pin_location) );
 
     auto* anterior_torso_hinge_on_chest = new PhysicalOffsetFrame(
         "anterior_torso_hinge_on_chest",
-        *chest, Transform(inferior_torso_hinge_location) );
+        *chest, SimTK::Transform(inferior_torso_hinge_location) );
     
     // Attach chest piece to pelvice with pin joint
     OpenSim::PinJoint* anteriorTorsoHinge = new OpenSim::PinJoint(
@@ -536,18 +534,18 @@ void createLuxoJr(OpenSim::Model& model){
     // Create chest piece
     //-----------------------
     OpenSim::Body* back = new OpenSim::Body("back_bar", bar_mass,
-                                     Vec3(0.0),
-                                     Inertia::brick(torso_bar_dimensions/2.0));
+                                     SimTK::Vec3(0.0),
+                                     SimTK::Inertia::brick(torso_bar_dimensions/2.0));
     
     back->attachGeometry(new Mesh("Posterior_torso_bar.obj"));
 
     auto* posterior_torso_hinge_on_pelvis = new PhysicalOffsetFrame(
         "posterior_torso_hinge_on_pelvis",
-        *pelvisBracket, Transform(posterior_superior_pelvis_pin_location) );
+        *pelvisBracket, SimTK::Transform(posterior_superior_pelvis_pin_location) );
 
     auto* posterior_torso_hinge_on_back = new PhysicalOffsetFrame(
         "posterior_torso_hinge_on_back",
-        *back, Transform(back_peg_center) );
+        *back, SimTK::Transform(back_peg_center) );
     
     // Attach chest piece to pelvis with pin joint
     OpenSim::PinJoint* posteriorTorsoHinge = new OpenSim::PinJoint(
@@ -569,8 +567,8 @@ void createLuxoJr(OpenSim::Model& model){
     //-----------------------
     OpenSim::Body* shoulderBracket = new OpenSim::Body("shoulder_bracket",
                                      bracket_mass,
-                                     Vec3(0.0),
-                                     Inertia::brick(shoulder_dimensions/2.0));
+                                     SimTK::Vec3(0.0),
+                                     SimTK::Inertia::brick(shoulder_dimensions/2.0));
 
     shoulderBracket->attachGeometry(new Mesh("Shoulder_meters.obj"));
     // add anterior leg to model
@@ -578,11 +576,11 @@ void createLuxoJr(OpenSim::Model& model){
 
     auto* anterior_thoracic_joint_on_chest = new PhysicalOffsetFrame(
         "anterior_thoracic_joint_on_chest",
-        *chest, Transform(superior_torso_hinge_location) );
+        *chest, SimTK::Transform(superior_torso_hinge_location) );
 
     auto* anterior_thoracic_joint_on_shoulder = new PhysicalOffsetFrame(
         "anterior_thoracic_joint_on_shoulder",
-        *shoulderBracket, Transform(anterior_thoracic_joint_center));
+        *shoulderBracket, SimTK::Transform(anterior_thoracic_joint_center));
     
     // Connect pelvis to Hlink via pin joint
     OpenSim::PinJoint* anteriorThoracicJoint =
@@ -607,7 +605,7 @@ void createLuxoJr(OpenSim::Model& model){
         new OpenSim::PointOnLineConstraint();
     
     posteriorShoulder->connectSocket_line_body(*shoulderBracket);
-    posteriorShoulder->setLineDirection(Vec3(0.0,0.0,1.0));
+    posteriorShoulder->setLineDirection(SimTK::Vec3(0.0,0.0,1.0));
     posteriorShoulder->setPointOnLine(posterior_thoracic_joint_center);
     posteriorShoulder->connectSocket_follower_body(*back);
     posteriorShoulder->setPointOnFollower(superior_torso_hinge_location);
@@ -616,8 +614,8 @@ void createLuxoJr(OpenSim::Model& model){
     model.addConstraint(posteriorShoulder);
 
     // Create and add luxo head
-    OpenSim::Body* head = new OpenSim::Body("head", head_mass, Vec3(0),
-            Inertia::cylinderAlongX(0.5*head_dimension[1], head_dimension[1]));
+    OpenSim::Body* head = new OpenSim::Body("head", head_mass, SimTK::Vec3(0),
+            SimTK::Inertia::cylinderAlongX(0.5*head_dimension[1], head_dimension[1]));
 
     head->attachGeometry(new Mesh("luxo_head_meters.obj"));
     head->attachGeometry(new Mesh("Bulb_meters.obj"));
@@ -625,11 +623,11 @@ void createLuxoJr(OpenSim::Model& model){
 
     auto* cervical_joint_on_shoulder = new PhysicalOffsetFrame(
         "cervical_joint_on_shoulder",
-        *shoulderBracket, Transform(superior_shoulder_hinge_location) );
+        *shoulderBracket, SimTK::Transform(superior_shoulder_hinge_location) );
 
     auto* cervical_joint_on_head = new PhysicalOffsetFrame(
         "cervical_joint_on_head",
-        *head, Transform(cervicle_joint_center));
+        *head, SimTK::Transform(cervicle_joint_center));
 
     // attach to shoulder via pin joint
     OpenSim::PinJoint* cervicalJoint = new OpenSim::PinJoint("cervical_joint",
@@ -845,4 +843,4 @@ void createLuxoJr(OpenSim::Model& model){
                 SimTK::Vec3(0.001, 0.001, 0.001));
     }
     
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Examples/ExampleMain/OutputReference/TugOfWar_Complete.cpp b/OpenSim/Examples/ExampleMain/OutputReference/TugOfWar_Complete.cpp
index 0e5f5fb6f..3b6e56eab 100644
--- a/OpenSim/Examples/ExampleMain/OutputReference/TugOfWar_Complete.cpp
+++ b/OpenSim/Examples/ExampleMain/OutputReference/TugOfWar_Complete.cpp
@@ -37,7 +37,6 @@
 #include <ctime>    // for clock()
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 //______________________________________________________________________________
@@ -75,19 +74,19 @@ int main()
         Ground& ground = osimModel.updGround();
         // Create Frames to attach Geometry to
         // Left brick
-        OpenSim::PhysicalFrame* leftAnchorFrame = new PhysicalOffsetFrame(ground, Transform(Vec3(0, 0.05, 0.35)));
+        OpenSim::PhysicalFrame* leftAnchorFrame = new PhysicalOffsetFrame(ground, SimTK::Transform(SimTK::Vec3(0, 0.05, 0.35)));
         leftAnchorFrame->setName("LeftAnchor");
         osimModel.addComponent(leftAnchorFrame);
         // Right brick
-        OpenSim::PhysicalFrame* rightAnchorFrame = new PhysicalOffsetFrame(ground, Transform(Vec3(0, 0.05, -0.35)));
+        OpenSim::PhysicalFrame* rightAnchorFrame = new PhysicalOffsetFrame(ground, SimTK::Transform(SimTK::Vec3(0, 0.05, -0.35)));
         rightAnchorFrame->setName("RightAnchor");
         osimModel.addComponent(rightAnchorFrame);
         // Cylinder
-        OpenSim::PhysicalFrame* cylFrame = new PhysicalOffsetFrame(ground, Transform(Vec3(-.2, 0.0, 0.)));
+        OpenSim::PhysicalFrame* cylFrame = new PhysicalOffsetFrame(ground, SimTK::Transform(SimTK::Vec3(-.2, 0.0, 0.)));
         cylFrame->setName("CylAnchor");
         osimModel.addComponent(cylFrame);
         // Ellipsoid
-        OpenSim::PhysicalFrame* ellipsoidFrame = new PhysicalOffsetFrame(ground, Transform(Vec3(-.6, 0.6, 0.)));
+        OpenSim::PhysicalFrame* ellipsoidFrame = new PhysicalOffsetFrame(ground, SimTK::Transform(SimTK::Vec3(-.6, 0.6, 0.)));
         ellipsoidFrame->setName("EllipsoidAnchor");
         osimModel.addComponent(ellipsoidFrame);
 
@@ -106,8 +105,8 @@ int main()
         // transform anchors to be placed at the two extremes of the sliding block (to come)
 
         // scale the anchors
-        leftAnchorGeometry->set_scale_factors(Vec3(5, 1, 1));
-        rightAnchorGeometry->set_scale_factors(Vec3(5, 1, 1));
+        leftAnchorGeometry->set_scale_factors(SimTK::Vec3(5, 1, 1));
+        rightAnchorGeometry->set_scale_factors(SimTK::Vec3(5, 1, 1));
         // position the anchors
         leftAnchorFrame->attachGeometry(leftAnchorGeometry);
         rightAnchorFrame->attachGeometry(rightAnchorGeometry);
@@ -121,9 +120,9 @@ int main()
         ellipsoidFrame->attachGeometry(ellipsoidGeometry);
         
         // BLOCK BODY
-        Vec3 blockMassCenter(0);
-        Inertia blockInertia = 
-            blockMass*Inertia::brick(blockSideLength, blockSideLength, blockSideLength);
+        SimTK::Vec3 blockMassCenter(0);
+        SimTK::Inertia blockInertia = 
+            blockMass*SimTK::Inertia::brick(blockSideLength, blockSideLength, blockSideLength);
 
         // Create a new block body with the specified properties
         OpenSim::Body *block = new OpenSim::Body("block", blockMass, blockMassCenter, blockInertia);
@@ -137,7 +136,7 @@ int main()
         // FREE JOINT
 
         // Create a new free joint with 6 degrees-of-freedom (coordinates) between the block and ground frames
-        Vec3 locationInParent(0, blockSideLength/2, 0), orientationInParent(0), locationInBody(0), orientationInBody(0);
+        SimTK::Vec3 locationInParent(0, blockSideLength/2, 0), orientationInParent(0), locationInBody(0), orientationInBody(0);
         FreeJoint *blockToGround = new FreeJoint("blockToGround", ground, locationInParent, orientationInParent, *block, locationInBody, orientationInBody);
         
         // Set the angle and position ranges for the free (6-degree-of-freedom)
@@ -153,7 +152,7 @@ int main()
 
         // GRAVITY
         // Obtain the default acceleration due to gravity
-        Vec3 gravity = osimModel.getGravity();
+        SimTK::Vec3 gravity = osimModel.getGravity();
 
         // Define non-zero default states for the free joint
         blockToGround->updCoordinate(FreeJoint::Coord::TranslationX)
@@ -178,8 +177,8 @@ int main()
         /////////////////////////////////////////////
         // DEFINE CONSTRAINTS IMPOSED ON THE MODEL //
         /////////////////////////////////////////////
-        Vec3 pointOnGround(0, blockSideLength/2 ,0);
-        Vec3 pointOnBlock(0, 0, 0);
+        SimTK::Vec3 pointOnGround(0, blockSideLength/2 ,0);
+        SimTK::Vec3 pointOnBlock(0, 0, 0);
 
         // Create a new constant distance constraint
         ConstantDistanceConstraint *constDist = 
@@ -201,11 +200,11 @@ int main()
 
         // Specify the paths for the two muscles
         // Path for muscle 1
-        muscle1->addNewPathPoint("muscle1-point1", ground, Vec3(0.0,0.05,-0.35));
-        muscle1->addNewPathPoint("muscle1-point2", *block, Vec3(0.0,0.0,-0.05));
+        muscle1->addNewPathPoint("muscle1-point1", ground, SimTK::Vec3(0.0,0.05,-0.35));
+        muscle1->addNewPathPoint("muscle1-point2", *block, SimTK::Vec3(0.0,0.0,-0.05));
         // Path for muscle 2
-        muscle2->addNewPathPoint("muscle2-point1", ground, Vec3(0.0,0.05,0.35));
-        muscle2->addNewPathPoint("muscle2-point2", *block, Vec3(0.0,0.0,0.05));
+        muscle2->addNewPathPoint("muscle2-point1", ground, SimTK::Vec3(0.0,0.05,0.35));
+        muscle2->addNewPathPoint("muscle2-point2", *block, SimTK::Vec3(0.0,0.0,0.05));
 
         // Add the two muscles (as forces) to the model
         osimModel.addForce(muscle1);
@@ -304,7 +303,7 @@ int main()
         constDist->setIsEnforced(si, true);
 
         cout << "Start height = "<< h_start << endl;
-        osimModel.getMultibodySystem().realize(si, Stage::Velocity);
+        osimModel.getMultibodySystem().realize(si, SimTK::Stage::Velocity);
 
         // Compute initial conditions for muscles
         osimModel.equilibrateMuscles(si);
@@ -356,4 +355,4 @@ int main()
     cout << "OpenSim example completed successfully." << endl;
 
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Examples/ExampleMain/TugOfWar1_CreateModel.cpp b/OpenSim/Examples/ExampleMain/TugOfWar1_CreateModel.cpp
index 31a0c34b6..b897e86b1 100644
--- a/OpenSim/Examples/ExampleMain/TugOfWar1_CreateModel.cpp
+++ b/OpenSim/Examples/ExampleMain/TugOfWar1_CreateModel.cpp
@@ -35,8 +35,6 @@
 #include <OpenSim/OpenSim.h>
 
 using namespace OpenSim;
-using namespace SimTK;
-
 //______________________________________________________________________________
 /**
  * First exercise: create a model that does nothing. 
@@ -67,4 +65,4 @@ int main()
     std::cout << "OpenSim example completed successfully.\n";
     std::cin.get();
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Examples/MuscleExample/mainFatigue.cpp b/OpenSim/Examples/MuscleExample/mainFatigue.cpp
index 563b02270..98c063d89 100644
--- a/OpenSim/Examples/MuscleExample/mainFatigue.cpp
+++ b/OpenSim/Examples/MuscleExample/mainFatigue.cpp
@@ -35,8 +35,6 @@
 #include "OpenSim/Common/STOFileAdapter.h"
 
 using namespace OpenSim;
-using namespace SimTK;
-
 //_____________________________________________________________________________
 /**
  * Run a simulation of a sliding block being pulled by two muscle 
@@ -74,8 +72,8 @@ int main()
 
         // Specify properties of a 20 kg, 10cm length block body
         double blockMass = 20.0, blockSideLength = 0.1;
-        Vec3 blockMassCenter(0);
-        Inertia blockInertia = blockMass*Inertia::brick(blockSideLength, 
+        SimTK::Vec3 blockMassCenter(0);
+        SimTK::Inertia blockInertia = blockMass*SimTK::Inertia::brick(blockSideLength, 
             blockSideLength, blockSideLength);
 
         // Create a new block body with the specified properties
@@ -90,8 +88,8 @@ int main()
         // Create a new free joint with 6 degrees-of-freedom (coordinates) 
         // between the block and ground bodies
         double halfLength = blockSideLength/2.0;
-        Vec3 locationInParent(0, halfLength, 0), orientationInParent(0);
-        Vec3 locationInBody(0, halfLength, 0), orientationInBody(0);
+        SimTK::Vec3 locationInParent(0, halfLength, 0), orientationInParent(0);
+        SimTK::Vec3 locationInBody(0, halfLength, 0), orientationInBody(0);
         FreeJoint *blockToGround = new FreeJoint("blockToGround", ground, 
             locationInParent, orientationInParent, 
             *block, locationInBody, orientationInBody);
@@ -134,14 +132,14 @@ int main()
 
         // Define the path of the muscles
         fatigable->addNewPathPoint("fatigable-point1", ground, 
-            Vec3(0.0, halfLength, -0.35));
+            SimTK::Vec3(0.0, halfLength, -0.35));
         fatigable->addNewPathPoint("fatigable-point2", *block, 
-            Vec3(0.0, halfLength, -halfLength));
+            SimTK::Vec3(0.0, halfLength, -halfLength));
 
         original->addNewPathPoint("original-point1", ground, 
-            Vec3(0.0, halfLength, 0.35));
+            SimTK::Vec3(0.0, halfLength, 0.35));
         original->addNewPathPoint("original-point2", *block, 
-            Vec3(0.0, halfLength, halfLength));
+            SimTK::Vec3(0.0, halfLength, halfLength));
 
         // Define the default states for the two muscles
         // Activation
@@ -260,4 +258,4 @@ int main()
 
     std::cout << "OpenSim example completed successfully.\n";
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Examples/OptimizationExample_Arm26/OptimizationExample.cpp b/OpenSim/Examples/OptimizationExample_Arm26/OptimizationExample.cpp
index fdb98316e..81c08ec9e 100644
--- a/OpenSim/Examples/OptimizationExample_Arm26/OptimizationExample.cpp
+++ b/OpenSim/Examples/OptimizationExample_Arm26/OptimizationExample.cpp
@@ -35,7 +35,6 @@
 #include <ctime>  // clock(), clock_t, CLOCKS_PER_SEC
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 // Global variables to define integration time window, optimizer step count,
@@ -44,22 +43,22 @@ int stepCount = 0;
 const double initialTime = 0.0;
 const double finalTime = 0.25;
 const double desired_accuracy = 1.0e-5;
-double bestSoFar = Infinity;
+double bestSoFar = SimTK::Infinity;
 
 class ExampleOptimizationSystem : public OptimizerSystem {
 public:
     /* Constructor class. Parameters passed are accessed in the objectiveFunc() class. */
-    ExampleOptimizationSystem(int numParameters, State& s, Model& aModel): 
+    ExampleOptimizationSystem(int numParameters, SimTK::State& s, Model& aModel): 
         OptimizerSystem(numParameters), 
         si(s),
         osimModel(aModel)
     {}
                 
-    int objectiveFunc(const Vector &newControls,
-        bool new_coefficients, Real& f) const override {
+    int objectiveFunc(const SimTK::Vector &newControls,
+        bool new_coefficients, SimTK::Real& f) const override {
 
         // make a copy of the initial states
-        State s = si;
+        SimTK::State s = si;
 
         // Update the control values
         osimModel.updDefaultControls() = newControls;
@@ -69,7 +68,7 @@ public:
         manager.setIntegratorAccuracy(desired_accuracy);
         s.setTime(initialTime);
 
-        osimModel.getMultibodySystem().realize(s, Stage::Acceleration);
+        osimModel.getMultibodySystem().realize(s, SimTK::Stage::Acceleration);
 
         manager.initialize(s);
         s = manager.integrate(finalTime);
@@ -80,9 +79,9 @@ public:
         *  and multiply it by -1.
         */
         const auto& hand = osimModel.getBodySet().get("r_ulna_radius_hand");
-        osimModel.getMultibodySystem().realize(s, Stage::Velocity);
-        Vec3 massCenter = hand.getMassCenter();
-        Vec3 velocity = hand.findStationVelocityInGround(s, massCenter);
+        osimModel.getMultibodySystem().realize(s, SimTK::Stage::Velocity);
+        SimTK::Vec3 massCenter = hand.getMassCenter();
+        SimTK::Vec3 velocity = hand.findStationVelocityInGround(s, massCenter);
         f = -velocity[0];
         stepCount++;
         
@@ -99,9 +98,9 @@ public:
    }    
 
 private:
-    State& si;
+    SimTK::State& si;
     Model& osimModel;
-    SimTK::ReferencePtr<RungeKuttaMersonIntegrator> p_integrator;
+    SimTK::ReferencePtr<SimTK::RungeKuttaMersonIntegrator> p_integrator;
 
  };
 
@@ -124,7 +123,7 @@ int main()
         Model osimModel("Arm26_Optimize.osim");
         
         // Initialize the system and get the state representing the state system
-        State& si = osimModel.initSystem();
+        SimTK::State& si = osimModel.initSystem();
 
         // Initialize the starting shoulder angle.
         const CoordinateSet& coords = osimModel.getCoordinateSet();
@@ -145,16 +144,16 @@ int main()
         
         // Initialize the optimizer system we've defined.
         ExampleOptimizationSystem sys(numControls, si, osimModel);
-        Real f = NaN;
+        SimTK::Real f = SimTK::NaN;
         
         /* Define initial values and bounds for the controls to optimize */
-        Vector controls(numControls, 0.02);
+        SimTK::Vector controls(numControls, 0.02);
         controls[3] = 0.99;
         controls[4] = 0.99;
         controls[5] = 0.99;
 
-        Vector lower_bounds(numControls, 0.01);
-        Vector upper_bounds(numControls, 0.99);
+        SimTK::Vector lower_bounds(numControls, 0.01);
+        SimTK::Vector upper_bounds(numControls, 0.99);
 
         sys.setParameterLimits( lower_bounds, upper_bounds );
         
@@ -198,7 +197,7 @@ int main()
 
         // Integrate from initial time to final time.
         si.setTime(initialTime);
-        osimModel.getMultibodySystem().realize(si, Stage::Acceleration);
+        osimModel.getMultibodySystem().realize(si, SimTK::Stage::Acceleration);
         manager.initialize(si);
         si = manager.integrate(finalTime);
 
@@ -214,4 +213,4 @@ int main()
     
     // End of main() routine.
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Examples/OptimizationExample_Arm26/OutputReference/OptimizationExample.cpp b/OpenSim/Examples/OptimizationExample_Arm26/OutputReference/OptimizationExample.cpp
index 1ca4a986f..b61d88a6f 100644
--- a/OpenSim/Examples/OptimizationExample_Arm26/OutputReference/OptimizationExample.cpp
+++ b/OpenSim/Examples/OptimizationExample_Arm26/OutputReference/OptimizationExample.cpp
@@ -35,7 +35,6 @@
 #include <ctime>  // clock(), clock_t, CLOCKS_PER_SEC
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 // Global variables to define integration time window, optimizer step count,
@@ -43,26 +42,26 @@ using namespace std;
 int stepCount = 0;
 double initialTime = 0.0;
 double finalTime = 0.25;
-double bestSoFar = Infinity;
+double bestSoFar = SimTK::Infinity;
 
 class ExampleOptimizationSystem : public OptimizerSystem {
    public:
 
        /* Constructor class. Parameters passed are accessed in the objectiveFunc() class. */
-       ExampleOptimizationSystem(int numParameters, State& s, Model& aModel): 
+       ExampleOptimizationSystem(int numParameters, SimTK::State& s, Model& aModel): 
              numControls(numParameters), OptimizerSystem(numParameters), si(s), osimModel(aModel){}
                 
-    int objectiveFunc(  const Vector &newControls, bool new_coefficients, Real& f ) const {
+    int objectiveFunc(  const SimTK::Vector &newControls, bool new_coefficients, SimTK::Real& f ) const {
 
         // make a copy of out initial states
-        State s = si;
+        SimTK::State s = si;
 
         // Update the control values
         //newControls.dump("New Controls In:");
         osimModel.updDefaultControls() = newControls;
 
         // Create the integrator for the simulation.
-        RungeKuttaMersonIntegrator integrator(osimModel.getMultibodySystem());
+        SimTK::RungeKuttaMersonIntegrator integrator(osimModel.getMultibodySystem());
         integrator.setAccuracy(1.0e-6);
 
         // Create a manager to run the simulation
@@ -72,7 +71,7 @@ class ExampleOptimizationSystem : public OptimizerSystem {
         manager.setInitialTime(initialTime);
         manager.setFinalTime(finalTime);
 
-        osimModel.getMultibodySystem().realize(s, Stage::Acceleration);
+        osimModel.getMultibodySystem().realize(s, SimTK::Stage::Acceleration);
 
         //osimModel.getControls(s).dump("Model Controls:");
 
@@ -83,10 +82,10 @@ class ExampleOptimizationSystem : public OptimizerSystem {
         *  forearm/hand mass center, so to maximize, compute velocity 
         *  and multiply it by -1.
         */
-        Vec3 massCenter;
-        Vec3 velocity;
+        SimTK::Vec3 massCenter;
+        SimTK::Vec3 velocity;
         osimModel.getBodySet().get("r_ulna_radius_hand").getMassCenter(massCenter);
-        osimModel.getMultibodySystem().realize(s, Stage::Velocity);
+        osimModel.getMultibodySystem().realize(s, SimTK::Stage::Velocity);
         osimModel.getSimbodyEngine().getVelocity(s, osimModel.getBodySet().get("r_ulna_radius_hand"), massCenter, velocity);
         
         f = -velocity[0];
@@ -113,7 +112,7 @@ class ExampleOptimizationSystem : public OptimizerSystem {
 
 private:
     int numControls;
-    State& si;
+    SimTK::State& si;
     Model& osimModel;
  };
 
@@ -132,7 +131,7 @@ int main()
         Model osimModel("Arm26_Optimize.osim");
         
         // Initialize the system and get the state representing the state system
-        State& si = osimModel.initSystem();
+        SimTK::State& si = osimModel.initSystem();
 
         // initialize the starting shoulder angle
         const CoordinateSet& coords = osimModel.getCoordinateSet();
@@ -152,12 +151,12 @@ int main()
         
         // Initialize the optimizer system we've defined.
         ExampleOptimizationSystem sys(numControls, si, osimModel);
-        Real f = NaN;
+        SimTK::Real f = SimTK::NaN;
         
         /* Define initial values and bounds for the controls to optimize */
-        Vector controls(numControls, 0.01);
-        Vector lower_bounds(numControls, 0.01);
-        Vector upper_bounds(numControls, 0.99);
+        SimTK::Vector controls(numControls, 0.01);
+        SimTK::Vector lower_bounds(numControls, 0.01);
+        SimTK::Vector upper_bounds(numControls, 0.99);
 
         sys.setParameterLimits( lower_bounds, upper_bounds );
         
@@ -203,4 +202,4 @@ int main()
     
     // End of main() routine.
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Examples/Plugins/BodyDragExample/BodyDragForce.cpp b/OpenSim/Examples/Plugins/BodyDragExample/BodyDragForce.cpp
index bdd6b8cd5..5eadd0afd 100644
--- a/OpenSim/Examples/Plugins/BodyDragExample/BodyDragForce.cpp
+++ b/OpenSim/Examples/Plugins/BodyDragExample/BodyDragForce.cpp
@@ -34,7 +34,6 @@
 // STATICS
 //=============================================================================
 using namespace std;
-using namespace SimTK;
 using namespace OpenSim;
 
 //=============================================================================
@@ -99,7 +98,7 @@ void BodyDragForce::connectToModel(Model& aModel)
 
     // Look up the body and report an error if it is not found 
     if (!aModel.updBodySet().contains(get_body_name())) {
-        errorMessage = "Invalid bodyName (" + get_body_name() + ") specified in Force " + getName();
+        errorMessage = "Invalid bodyName (" + get_body_name() + ") specified in SimTK::Force " + getName();
         throw (Exception(errorMessage.c_str()));
     }
 }
@@ -118,7 +117,7 @@ void BodyDragForce::implProduceForces(
     SimTK::Vec3 bodyCoMPosBody, bodyCoMPosGround, bodyCoMVelGround, bodyCoMVelGroundRaisedPower, dragForceGround, dragForceBody, oppVelSign;
     BodySet &bs = _model->updBodySet();                                     // get body set
     const Ground &ground = _model->getGround(); // get ground body
-    Body &aBody = bs.get(get_body_name());                                      // get the body to apply the force to
+    SimTK::Body &aBody = bs.get(get_body_name());                                      // get the body to apply the force to
 
     // get CoM position of body in the BODY coordinate system
     bodyCoMPosBody = aBody.getMassCenter();
@@ -202,7 +201,7 @@ OpenSim::Array<double> BodyDragForce::getRecordValues(const SimTK::State& s) con
     SimTK::Vec3 bodyCoMPosBody, bodyCoMPosGround, bodyCoMVelGround, bodyCoMVelGroundRaisedPower, dragForceGround, dragForceBody, oppVelSign;
     BodySet &bs = _model->updBodySet();                                     // get body set
     const Ground &ground = _model->getGround();              // get ground body
-    Body &aBody = bs.get(get_body_name());                                      // get the body in which the force is applied
+    SimTK::Body &aBody = bs.get(get_body_name());                                      // get the body in which the force is applied
 
     // get CoM position of body in the BODY coordinate system
     bodyCoMPosBody = aBody.getMassCenter();
@@ -222,4 +221,4 @@ OpenSim::Array<double> BodyDragForce::getRecordValues(const SimTK::State& s) con
     }
 
     return values;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Examples/Plugins/CoupledBushingForceExample/CoupledBushingForce.cpp b/OpenSim/Examples/Plugins/CoupledBushingForceExample/CoupledBushingForce.cpp
index 0294e14e6..23d3dd541 100644
--- a/OpenSim/Examples/Plugins/CoupledBushingForceExample/CoupledBushingForce.cpp
+++ b/OpenSim/Examples/Plugins/CoupledBushingForceExample/CoupledBushingForce.cpp
@@ -33,7 +33,6 @@
 // STATICS
 //=============================================================================
 using namespace std;
-using namespace SimTK;
 using namespace OpenSim;
 
 //=============================================================================
@@ -80,19 +79,19 @@ void CoupledBushingForce::constructProperties()
 {
     // default bushing material properties
     // 6x6 stiffness matrix
-    constructProperty_stiffness_row1(Vec6(0));
-    constructProperty_stiffness_row2(Vec6(0));
-    constructProperty_stiffness_row3(Vec6(0));
-    constructProperty_stiffness_row4(Vec6(0));
-    constructProperty_stiffness_row5(Vec6(0));
-    constructProperty_stiffness_row6(Vec6(0));
+    constructProperty_stiffness_row1(SimTK::Vec6(0));
+    constructProperty_stiffness_row2(SimTK::Vec6(0));
+    constructProperty_stiffness_row3(SimTK::Vec6(0));
+    constructProperty_stiffness_row4(SimTK::Vec6(0));
+    constructProperty_stiffness_row5(SimTK::Vec6(0));
+    constructProperty_stiffness_row6(SimTK::Vec6(0));
     // 6x6 damping matrix
-    constructProperty_damping_row1(Vec6(0));
-    constructProperty_damping_row2(Vec6(0));
-    constructProperty_damping_row3(Vec6(0));
-    constructProperty_damping_row4(Vec6(0));
-    constructProperty_damping_row5(Vec6(0));
-    constructProperty_damping_row6(Vec6(0));
+    constructProperty_damping_row1(SimTK::Vec6(0));
+    constructProperty_damping_row2(SimTK::Vec6(0));
+    constructProperty_damping_row3(SimTK::Vec6(0));
+    constructProperty_damping_row4(SimTK::Vec6(0));
+    constructProperty_damping_row5(SimTK::Vec6(0));
+    constructProperty_damping_row6(SimTK::Vec6(0));
 }
 
 void CoupledBushingForce::extendFinalizeFromProperties()
@@ -110,14 +109,14 @@ void CoupledBushingForce::implProduceForces(
 {
     // Calculate stiffness generalized forces of bushing by first computing
     // the deviation of the two frames measured by dq
-    Vec6 fk = -_stiffnessMatrix*computeDeflection(s);
+    SimTK::Vec6 fk = -_stiffnessMatrix*computeDeflection(s);
 
     // velocity dependent force according to the speed of frame2
     // relative to frame1 
-    Vec6 fv = -_dampingMatrix * computeDeflectionRate(s);
+    SimTK::Vec6 fv = -_dampingMatrix * computeDeflectionRate(s);
 
     // total bushing force in the internal basis of the deflection (dq) 
-    Vec6 f = fk + fv;
+    SimTK::Vec6 f = fk + fv;
 
     // convert the internal forces to into spatial forces and emit them
     // into the `ForceConsumer`
@@ -128,7 +127,7 @@ void CoupledBushingForce::implProduceForces(
     from the rest position and the stiffness */
 double CoupledBushingForce::computePotentialEnergy(const SimTK::State& s) const
 {
-    Vec6 dq = computeDeflection(s);
+    SimTK::Vec6 dq = computeDeflection(s);
     // Energy stored in the linear bushing
     double U = 0.5*(~dq*_stiffnessMatrix*dq);
     return U;
@@ -150,7 +149,7 @@ OpenSim::Array<std::string> CoupledBushingForce::getRecordLabels() const
     const PhysicalFrame& frame1 = getConnectee<PhysicalFrame>("frame1");
     const PhysicalFrame& frame2 = getConnectee<PhysicalFrame>("frame2");
 
-    // Forces applied to underlying MobilizedBody which is a base PhysicalFrame
+    // Forces applied to underlying SimTK::MobilizedBody which is a base PhysicalFrame
     std::string base1Name = frame1.findBaseFrame().getName();
     std::string base2Name = frame2.findBaseFrame().getName();
 
@@ -237,4 +236,4 @@ void CoupledBushingForce::updatePropertiesFromMatrices()
     upd_damping_row4() = _dampingMatrix(3);
     upd_damping_row5() = _dampingMatrix(4);
     upd_damping_row6() = _dampingMatrix(5);
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Examples/SimpleOptimizationExample/SimpleOptimizationExample.cpp b/OpenSim/Examples/SimpleOptimizationExample/SimpleOptimizationExample.cpp
index 2a3d1b3b0..9d49295a4 100644
--- a/OpenSim/Examples/SimpleOptimizationExample/SimpleOptimizationExample.cpp
+++ b/OpenSim/Examples/SimpleOptimizationExample/SimpleOptimizationExample.cpp
@@ -32,27 +32,26 @@
 #include <ctime>  // clock(), clock_t, CLOCKS_PER_SEC
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 // step count for troubleshooting
 int stepCount = 0;
 
-double bestSoFar = Infinity;
+double bestSoFar = SimTK::Infinity;
 
 class ExampleOptimizationSystem : public OptimizerSystem {
    public:
 
        /* Constructor class. Parameters passed are accessed in the objectiveFunc() class. */
-       ExampleOptimizationSystem(int numParameters, State& s, Model& aModel): 
+       ExampleOptimizationSystem(int numParameters, SimTK::State& s, Model& aModel): 
              OptimizerSystem(numParameters), 
              si(s),
              osimModel(aModel){}
                 
-    int objectiveFunc(  const Vector &newControls, bool new_coefficients, Real& f ) const override {
+    int objectiveFunc(  const SimTK::Vector &newControls, bool new_coefficients, SimTK::Real& f ) const override {
 
         // make a copy of out initial states
-        State s = si;
+        SimTK::State s = si;
 
         // Update the coordinate value of r_elbow_flex
         OpenSim::Coordinate& elbowFlexCoord = osimModel.updCoordinateSet().get("r_elbow_flex");
@@ -84,7 +83,7 @@ class ExampleOptimizationSystem : public OptimizerSystem {
    }    
 
 private:
-    State& si;
+    SimTK::State& si;
     Model& osimModel;
  };
 
@@ -103,7 +102,7 @@ int main()
         Model osimModel("Arm26_Optimize.osim");
         
         // Initialize the system and get the state representing the state system
-        State& si = osimModel.initSystem();
+        SimTK::State& si = osimModel.initSystem();
 
         // initialize the starting shoulder angle
         const CoordinateSet& coords = osimModel.getCoordinateSet();
@@ -118,19 +117,19 @@ int main()
         }
         OpenSim::Coordinate& elbowFlexCoord = osimModel.updCoordinateSet().get("r_elbow_flex");
         elbowFlexCoord.setValue(si, 1.0);
-        //osimModel.getMultibodySystem().realize(si, Stage::Velocity);
+        //osimModel.getMultibodySystem().realize(si, SimTK::Stage::Velocity);
         // Make sure the muscles states are in equilibrium
         osimModel.equilibrateMuscles(si);
         
         // Initialize the optimizer system we've defined.
         ExampleOptimizationSystem sys(1, si, osimModel);
-        // Real f = NaN;
+        // SimTK::Real f = SimTK::NaN;
         
         /* Define initial values and bounds for the controls to optimize */
 
-        Vector controls(1, 1.0); // 1 radian for default value
-        Vector lower_bounds(1, elbowFlexCoord.getRangeMin());
-        Vector upper_bounds(1, elbowFlexCoord.getRangeMax());
+        SimTK::Vector controls(1, 1.0); // 1 radian for default value
+        SimTK::Vector lower_bounds(1, elbowFlexCoord.getRangeMin());
+        SimTK::Vector upper_bounds(1, elbowFlexCoord.getRangeMax());
 
         sys.setParameterLimits( lower_bounds, upper_bounds );
         
@@ -159,4 +158,4 @@ int main()
     
     // End of main() routine.
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Examples/checkEnvironment/checkEnvironment.cpp b/OpenSim/Examples/checkEnvironment/checkEnvironment.cpp
index 025bca7c4..78b99db48 100644
--- a/OpenSim/Examples/checkEnvironment/checkEnvironment.cpp
+++ b/OpenSim/Examples/checkEnvironment/checkEnvironment.cpp
@@ -30,8 +30,6 @@
 #include <OpenSim/OpenSim.h>
 
 using namespace OpenSim;
-using namespace SimTK;
-
 //______________________________________________________________________________
 /**
  * Create a model that does nothing. 
@@ -62,8 +60,8 @@ int main()
 
         // Specify properties of a 20 kg, 0.1 m^3 block body
         double blockMass = 20.0, blockSideLength = 0.1;
-        Vec3 blockMassCenter(0);
-        Inertia blockInertia = blockMass*Inertia::brick(blockSideLength, blockSideLength, blockSideLength);
+        SimTK::Vec3 blockMassCenter(0);
+        SimTK::Inertia blockInertia = blockMass*SimTK::Inertia::brick(blockSideLength, blockSideLength, blockSideLength);
 
         // Create a new block body with the specified properties
         OpenSim::Body *block = new OpenSim::Body("block", blockMass, blockMassCenter, blockInertia);
@@ -74,7 +72,7 @@ int main()
         // FREE JOINT
 
         // Create a new free joint with 6 degrees-of-freedom (coordinates) between the block and ground frames
-        Vec3 locationInParent(0, blockSideLength/2, 0), orientationInParent(0), locationInBody(0), orientationInBody(0);
+        SimTK::Vec3 locationInParent(0, blockSideLength/2, 0), orientationInParent(0), locationInBody(0), orientationInBody(0);
         FreeJoint *blockToGround = new FreeJoint("blockToGround", ground, locationInParent, orientationInParent, *block, locationInBody, orientationInBody);
         
         // Set the angle and position ranges for the free (6-degree-of-freedom)
@@ -106,8 +104,8 @@ int main()
 
         // Specify properties of a constant distance constraint to limit the block's motion
         double distance = 0.2;
-        Vec3 pointOnGround(0, blockSideLength/2 ,0);
-        Vec3 pointOnBlock(0, 0, 0);
+        SimTK::Vec3 pointOnGround(0, blockSideLength/2 ,0);
+        SimTK::Vec3 pointOnBlock(0, 0, 0);
 
         // Create a new constant distance constraint
         ConstantDistanceConstraint *constDist = new ConstantDistanceConstraint(ground, 
@@ -122,7 +120,7 @@ int main()
 
         // GRAVITY
         // Obtain the default acceleration due to gravity
-        Vec3 gravity = osimModel.getGravity();
+        SimTK::Vec3 gravity = osimModel.getGravity();
     
 
         // MUSCLE FORCES
@@ -133,11 +131,11 @@ int main()
 
         // Specify the paths for the two muscles
         // Path for muscle 1
-        muscle1->addNewPathPoint("muscle1-point1", ground, Vec3(0.0,0.05,-0.35));
-        muscle1->addNewPathPoint("muscle1-point2", *block, Vec3(0.0,0.0,-0.05));
+        muscle1->addNewPathPoint("muscle1-point1", ground, SimTK::Vec3(0.0,0.05,-0.35));
+        muscle1->addNewPathPoint("muscle1-point2", *block, SimTK::Vec3(0.0,0.0,-0.05));
         // Path for muscle 2
-        muscle2->addNewPathPoint("muscle2-point1", ground, Vec3(0.0,0.05,0.35));
-        muscle2->addNewPathPoint("muscle2-point2", *block, Vec3(0.0,0.0,0.05));
+        muscle2->addNewPathPoint("muscle2-point1", ground, SimTK::Vec3(0.0,0.05,0.35));
+        muscle2->addNewPathPoint("muscle2-point2", *block, SimTK::Vec3(0.0,0.0,0.05));
 
         // Add the two muscles (as forces) to the model
         osimModel.addForce(muscle1);
@@ -222,7 +220,7 @@ int main()
         
         std::cout << "Start height = "<< h_start << std::endl;
 
-        osimModel.getMultibodySystem().realize(si, Stage::Velocity);
+        osimModel.getMultibodySystem().realize(si, SimTK::Stage::Velocity);
 
         // Compute initial conditions for muscles
         osimModel.equilibrateMuscles(si);
@@ -260,4 +258,4 @@ int main()
     std::cout << "OpenSim environment test completed successfully. You should see a block attached to two muscles visualized in a separate window." << std::endl;
 
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Sandbox/Moco/sandboxSimTKMotion.cpp b/OpenSim/Sandbox/Moco/sandboxSimTKMotion.cpp
index fca29641a..d6d9c231b 100644
--- a/OpenSim/Sandbox/Moco/sandboxSimTKMotion.cpp
+++ b/OpenSim/Sandbox/Moco/sandboxSimTKMotion.cpp
@@ -17,110 +17,108 @@
  * -------------------------------------------------------------------------- */
 
 #include "Simbody.h"
-
-using namespace SimTK;
 using std::cout;
 using std::endl;
 
 class MyReporter : public PeriodicEventReporter {
 public:
-    MyReporter(const MultibodySystem& system, Real interval)
+    MyReporter(const SimTK::MultibodySystem& system, SimTK::Real interval)
             : PeriodicEventReporter(interval), system(system) {}
 
     // Show x-y position of the pendulum weight as a function of time.
-    void handleEvent(const State& state) const override {
-        system.realize(state, Stage::Acceleration);
-        Vector mm;
-        Vector mf;
+    void handleEvent(const SimTK::State& state) const override {
+        system.realize(state, SimTK::Stage::Acceleration);
+        SimTK::Vector mm;
+        SimTK::Vector mf;
         mm = system.getMatterSubsystem().getMotionMultipliers(state);
         system.getMatterSubsystem().findMotionForces(state, mf);
         std::cout << state.getTime() << "\t" << mm << "\t" << mf << std::endl;
     }
 
 private:
-    const MultibodySystem& system;
+    const SimTK::MultibodySystem& system;
 };
 
 class MyMotionImplementation : public Motion::Custom::Implementation {
-    Motion::Level getLevel(const State&) const override {
+    Motion::Level getLevel(const SimTK::State&) const override {
         return Motion::Level::Position;
     }
 
 public:
     void calcPrescribedPosition(
-            const State& s, int nq, Real* q) const override {
+            const SimTK::State& s, int nq, SimTK::Real* q) const override {
         const auto& t = s.getTime();
         for (int i = 0; i < nq; ++i) { q[i] = t * t; }
     }
     void calcPrescribedPositionDot(
-            const State& s, int nq, Real* qdot) const override {
+            const SimTK::State& s, int nq, SimTK::Real* qdot) const override {
         const auto& t = s.getTime();
         for (int i = 0; i < nq; ++i) { qdot[i] = 2 * t; }
     }
     void calcPrescribedPositionDotDot(
-            const State& s, int nq, Real* qdotdot) const override {
+            const SimTK::State& s, int nq, SimTK::Real* qdotdot) const override {
         for (int i = 0; i < nq; ++i) { qdotdot[i] = 2; }
     }
 };
 
 class MyMotion : public Motion::Custom {
 public:
-    MyMotion(MobilizedBody& mobod)
+    MyMotion(SimTK::MobilizedBody& mobod)
             : Motion::Custom(mobod, new MyMotionImplementation()) {}
 };
 
 class SplineMotionImplementation : public Motion::Custom::Implementation {
-    Motion::Level getLevel(const State&) const override {
+    Motion::Level getLevel(const SimTK::State&) const override {
         return Motion::Level::Position;
     }
 
 public:
     void calcPrescribedPosition(
-            const State& s, int nq, Real* q) const override {
+            const SimTK::State& s, int nq, SimTK::Real* q) const override {
         const auto& t = s.getTime();
     }
     void calcPrescribedPositionDot(
-            const State& s, int nq, Real* qdot) const override {
+            const SimTK::State& s, int nq, SimTK::Real* qdot) const override {
         const auto& t = s.getTime();
         for (int i = 0; i < nq; ++i) { qdot[i] = 2 * t; }
     }
     void calcPrescribedPositionDotDot(
-            const State& s, int nq, Real* qdotdot) const override {
+            const SimTK::State& s, int nq, SimTK::Real* qdotdot) const override {
         for (int i = 0; i < nq; ++i) { qdotdot[i] = 2; }
     }
 };
 
 class SplineMotion : public Motion::Custom {
 public:
-    SplineMotion(MobilizedBody& mobod)
+    SplineMotion(SimTK::MobilizedBody& mobod)
             : Motion::Custom(mobod, new MyMotionImplementation()) {}
 };
 
 class PrescribedAccelerationMotionImplementation
         : public Motion::Custom::Implementation {
-    Motion::Level getLevel(const State&) const override {
+    Motion::Level getLevel(const SimTK::State&) const override {
         return Motion::Level::Acceleration;
     }
 
 public:
     void calcPrescribedPosition(
-            const State& s, int nq, Real* q) const override {
+            const SimTK::State& s, int nq, SimTK::Real* q) const override {
         const auto& t = s.getTime();
         for (int i = 0; i < nq; ++i) { q[i] = t * t; }
     }
     void calcPrescribedPositionDot(
-            const State& s, int nq, Real* qdot) const override {
+            const SimTK::State& s, int nq, SimTK::Real* qdot) const override {
         const auto& t = s.getTime();
         for (int i = 0; i < nq; ++i) { qdot[i] = 2 * t; }
     }
     void calcPrescribedPositionDotDot(
-            const State& s, int nq, Real* qdotdot) const override {
+            const SimTK::State& s, int nq, SimTK::Real* qdotdot) const override {
         for (int i = 0; i < nq; ++i) { qdotdot[i] = 2; }
     }
 };
 
 class PrescribedAccelerationMotion : public Motion::Custom {
-    PrescribedAccelerationMotion(MobilizedBody& mobod)
+    PrescribedAccelerationMotion(SimTK::MobilizedBody& mobod)
             : Motion::Custom(mobod,
                       new PrescribedAccelerationMotionImplementation()) {}
 };
@@ -128,23 +126,23 @@ class PrescribedAccelerationMotion : public Motion::Custom {
 int main() {
     // Much of this is copied from Simbody's ExamplePendulum.cpp.
     // Create the system, with subsystems for the bodies and some forces.
-    MultibodySystem system;
-    SimbodyMatterSubsystem matter(system);
-    GeneralForceSubsystem forces(system);
+    SimTK::MultibodySystem system;
+    SimTK::SimbodyMatterSubsystem matter(system);
+    SimTK::GeneralForceSubsystem forces(system);
 
     // Add gravity as a force element.
-    Force::UniformGravity gravity(forces, matter, Vec3(0, Real(-9.8), 0));
+    SimTK::Force::UniformGravity gravity(forces, matter, SimTK::Vec3(0, SimTK::Real(-9.8), 0));
     // Create the body and some artwork for it.
-    Body::Rigid pendulumBody(MassProperties(1.0, Vec3(0), Inertia(1)));
+    SimTK::Body::Rigid pendulumBody(SimTK::MassProperties(1.0, SimTK::Vec3(0), SimTK::Inertia(1)));
     pendulumBody.addDecoration(
-            Transform(), DecorativeSphere(Real(0.1)).setColor(Red));
+            SimTK::Transform(), DecorativeSphere(SimTK::Real(0.1)).setColor(Red));
 
     // Add an instance of the body to the multibody system by connecting
     // it to Ground via a pin mobilizer.
-    MobilizedBody::Pin pendulum1(matter.updGround(), Transform(Vec3(0, -1, 0)),
-            pendulumBody, Transform(Vec3(0, 1, 0)));
-    MobilizedBody::Pin pendulum1b(pendulum1, Transform(Vec3(0, -1, 0)),
-            pendulumBody, Transform(Vec3(0, 1, 0)));
+    SimTK::MobilizedBody::Pin pendulum1(matter.updGround(), SimTK::Transform(SimTK::Vec3(0, -1, 0)),
+            pendulumBody, SimTK::Transform(SimTK::Vec3(0, 1, 0)));
+    SimTK::MobilizedBody::Pin pendulum1b(pendulum1, SimTK::Transform(SimTK::Vec3(0, -1, 0)),
+            pendulumBody, SimTK::Transform(SimTK::Vec3(0, 1, 0)));
 
     // Motion::Sinusoid motion(pendulum1, Motion::Level::Position, 1.0, 2.0, 0);
     MyMotion myMotion(pendulum1b);
@@ -152,14 +150,14 @@ int main() {
     // Visualize with default options; ask for a report every 1/30 of a second
     // to match the Visualizer's default 30 frames per second rate.
     Visualizer viz(system);
-    system.addEventReporter(new Visualizer::Reporter(viz, Real(1. / 30)));
+    system.addEventReporter(new Visualizer::Reporter(viz, SimTK::Real(1. / 30)));
 
     system.addEventReporter(new MyReporter(system, 0.01));
 
     // Initialize the system and state.
 
     system.realizeTopology();
-    State state = system.getDefaultState();
+    SimTK::State state = system.getDefaultState();
 
     system.realize(state);
 
@@ -171,12 +169,12 @@ int main() {
     cout << "Hit ENTER to run a short simulation ...";
     getchar();
 
-    RungeKuttaMersonIntegrator integ(system);
-    TimeStepper ts(system, integ);
+    SimTK::RungeKuttaMersonIntegrator integ(system);
+    SimTK::TimeStepper ts(system, integ);
     ts.initialize(state);
     ts.stepTo(30.0);
     state = integ.getState();
     system.realize(state);
 
     return EXIT_SUCCESS;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Sandbox/TaskSpace/TaskBasedController.cpp b/OpenSim/Sandbox/TaskSpace/TaskBasedController.cpp
index 7d7a135f5..e4e3be0b6 100644
--- a/OpenSim/Sandbox/TaskSpace/TaskBasedController.cpp
+++ b/OpenSim/Sandbox/TaskSpace/TaskBasedController.cpp
@@ -24,16 +24,14 @@
 #include "TaskBasedController.h"
 
 using namespace OpenSim;
-using namespace SimTK;
-
 TaskBasedController::TaskBasedController(TaskSpace& taskSpace,
-    std::string endEffectorBody, Vec3 endEffectorBodyOffset)
+    std::string endEffectorBody, SimTK::Vec3 endEffectorBodyOffset)
     : m_taskSpace(taskSpace),
     m_endEffectorBody(endEffectorBody),
     m_endEffectorBodyOffset(endEffectorBodyOffset)
 {
     m_isInitialized = false;
-    m_desiredAcc = Vec3(0, 0, 0);
+    m_desiredAcc = SimTK::Vec3(0, 0, 0);
 }
 
 TaskBasedController::~TaskBasedController()
@@ -41,13 +39,13 @@ TaskBasedController::~TaskBasedController()
 
 }
 
-void TaskBasedController::setAcceleration(Vec3 acc)
+void TaskBasedController::setAcceleration(SimTK::Vec3 acc)
 {
     m_desiredAcc = acc;
 }
 
-void TaskBasedController::computeForce(const State& s,
-    Vector_<SpatialVec>& bodyForces, Vector& generalizedForces) const
+void TaskBasedController::computeForce(const SimTK::State& s,
+    SimTK::Vector_<SimTK::SpatialVec>& bodyForces, SimTK::Vector& generalizedForces) const
 {
     if (!m_isInitialized)
     {
@@ -60,7 +58,6 @@ void TaskBasedController::computeForce(const State& s,
     _model->realizeVelocity(s);
 
     generalizedForces +=
-        m_taskSpace->calcInverseDynamics(s, Vector(m_desiredAcc)) +
+        m_taskSpace->calcInverseDynamics(s, SimTK::Vector(m_desiredAcc)) +
         m_taskSpace->calcGravityCompensation(s);;
-}
-
+}
\ No newline at end of file
diff --git a/OpenSim/Sandbox/TaskSpace/TaskSpace.cpp b/OpenSim/Sandbox/TaskSpace/TaskSpace.cpp
index 375bd2a8a..bf893e380 100644
--- a/OpenSim/Sandbox/TaskSpace/TaskSpace.cpp
+++ b/OpenSim/Sandbox/TaskSpace/TaskSpace.cpp
@@ -23,14 +23,12 @@
 
 #include <Simbody.h>
 #include "TaskSpace.h"
-
-using namespace SimTK;
 using namespace OpenSim;
 
 //==============================================================================
 // Jacobian
 //==============================================================================
-void TaskSpace::Jacobian::updateCache(const State& s, Matrix& cache) const
+void TaskSpace::Jacobian::updateCache(const SimTK::State& s, SimTK::Matrix& cache) const
 {
     m_tspace->getMatterSubsystem().calcStationJacobian(
             s,
@@ -44,15 +42,15 @@ const TaskSpace::JacobianTranspose& TaskSpace::Jacobian::transpose() const
     return m_tspace->getJacobianTranspose();
 }
 
-Vector TaskSpace::Jacobian::multiplyByJ(const State& s, const Vector& u) const
+SimTK::Vector TaskSpace::Jacobian::multiplyByJ(const SimTK::State& s, const SimTK::Vector& u) const
 {
-    Vector_<Vec3> Ju;
+    SimTK::Vector_<SimTK::Vec3> Ju;
     m_tspace->getMatterSubsystem().multiplyByStationJacobian(s,
             m_tspace->getMobilizedBodyIndices(), m_tspace->getStations(),
             u, Ju);
 
-    // Convert to a Vector.
-    Vector out(3 * Ju.size());
+    // Convert to a SimTK::Vector.
+    SimTK::Vector out(3 * Ju.size());
     for (int i = 0; i < Ju.size(); ++i) {
         out[3 * i] = Ju[i][0];
         out[3 * i + 1] = Ju[i][1];
@@ -66,7 +64,7 @@ Vector TaskSpace::Jacobian::multiplyByJ(const State& s, const Vector& u) const
 //==============================================================================
 // JacobianTranspose
 //==============================================================================
-void TaskSpace::JacobianTranspose::updateCache(const State& s, Matrix& cache) const
+void TaskSpace::JacobianTranspose::updateCache(const SimTK::State& s, SimTK::Matrix& cache) const
 {
     cache = transpose().getValue(s).transpose();
 }
@@ -76,10 +74,10 @@ const TaskSpace::Jacobian& TaskSpace::JacobianTranspose::transpose() const
     return m_tspace->getJacobian();
 }
 
-Vector TaskSpace::JacobianTranspose::multiplyByJT(const State& s,
-    const Vector_<Vec3>& f_GP) const
+SimTK::Vector TaskSpace::JacobianTranspose::multiplyByJT(const SimTK::State& s,
+    const SimTK::Vector_<SimTK::Vec3>& f_GP) const
 {
-    Vector f;
+    SimTK::Vector f;
     m_tspace->getMatterSubsystem().multiplyByStationJacobianTranspose(
             s,
             m_tspace->getMobilizedBodyIndices(),
@@ -89,8 +87,8 @@ Vector TaskSpace::JacobianTranspose::multiplyByJT(const State& s,
     return f;
 }
 
-Vector TaskSpace::JacobianTranspose::multiplyByJT(const State& s,
-    const Vector& f_GP) const
+SimTK::Vector TaskSpace::JacobianTranspose::multiplyByJT(const SimTK::State& s,
+    const SimTK::Vector& f_GP) const
 {
     unsigned int nIn = f_GP.size();
     SimTK_APIARGCHECK1_ALWAYS(nIn % 3 == 0,
@@ -99,58 +97,58 @@ Vector TaskSpace::JacobianTranspose::multiplyByJT(const State& s,
 
     unsigned int nOut = nIn / 3;
 
-    // Create the Vector_<Vec3>.
+    // Create the SimTK::Vector_<SimTK::Vec3>.
     // TODO debug, or look for methods that already do this.
-    Vector_<Vec3> my_f_GP(nOut);
+    SimTK::Vector_<SimTK::Vec3> my_f_GP(nOut);
     for (unsigned int i = 0; i < nOut; ++i)
     {
         // getAs is just a recast; doesn't copy.
-        my_f_GP[i] = Vec3::getAs(&f_GP[3 * i]);
+        my_f_GP[i] = SimTK::Vec3::getAs(&f_GP[3 * i]);
     }
 
     // Perform the multiplication.
     return multiplyByJT(s, my_f_GP);
 }
 
-Vector TaskSpace::JacobianTranspose::multiplyByJT(const State& s,
-    const Vec3& f_GP) const
+SimTK::Vector TaskSpace::JacobianTranspose::multiplyByJT(const SimTK::State& s,
+    const SimTK::Vec3& f_GP) const
 {
-   return multiplyByJT(s, Vector_<Vec3>(1, f_GP));
+   return multiplyByJT(s, SimTK::Vector_<SimTK::Vec3>(1, f_GP));
 }
 
-Matrix TaskSpace::JacobianTranspose::multiplyByJT(const State& s,
-    const Matrix& f_GP) const
+SimTK::Matrix TaskSpace::JacobianTranspose::multiplyByJT(const SimTK::State& s,
+    const SimTK::Matrix& f_GP) const
 {
     unsigned int nrow = s.getNU();
     unsigned int ncol = f_GP.ncol();
 
-    Matrix out(nrow, ncol);
+    SimTK::Matrix out(nrow, ncol);
     for (unsigned int j = 0; j < ncol; ++j)
     {
         // TODO is this cast inefficient? Is it copying?
-        out(j) = multiplyByJT(s, Vector(f_GP(j)));
+        out(j) = multiplyByJT(s, SimTK::Vector(f_GP(j)));
     }
 
     return out;
 }
 
-Matrix TaskSpace::JacobianTranspose::multiplyByJT(
-    const State& s, const TaskSpace::Inertia& Lambda) const
+SimTK::Matrix TaskSpace::JacobianTranspose::multiplyByJT(
+    const SimTK::State& s, const TaskSpace::Inertia& Lambda) const
 {
     // TOOD could be more efficient.
     return multiplyByJT(s, Lambda.getValue(s));
 }
 
-Matrix TaskSpace::JacobianTranspose::multiplyByJT(const State& s,
+SimTK::Matrix TaskSpace::JacobianTranspose::multiplyByJT(const SimTK::State& s,
     const TaskSpace::DynamicallyConsistentJacobianInverseTranspose& JBarT) const
 {
     return multiplyByJT(s, JBarT.getValue(s));
 }
 
 //==============================================================================
-// Inertia
+// SimTK::Inertia
 //==============================================================================
-void TaskSpace::Inertia::updateCache(const State& s, Matrix& cache) const
+void TaskSpace::Inertia::updateCache(const SimTK::State& s, SimTK::Matrix& cache) const
 {
     FactorLU inertiaInverse(m_tspace->getInertiaInverse().getValue(s));
     inertiaInverse.inverse(cache);
@@ -161,35 +159,35 @@ const TaskSpace::InertiaInverse& TaskSpace::Inertia::inverse() const
     return m_tspace->getInertiaInverse();
 }
 
-Vector TaskSpace::Inertia::multiplyByLambda(const State& s, const Vector& a) const
+SimTK::Vector TaskSpace::Inertia::multiplyByLambda(const SimTK::State& s, const SimTK::Vector& a) const
 {
     return getValue(s) * a;
 }
 
-Vector TaskSpace::Inertia::multiplyByLambda(const State& s, const Vec3& a) const
+SimTK::Vector TaskSpace::Inertia::multiplyByLambda(const SimTK::State& s, const SimTK::Vec3& a) const
 {
-    return multiplyByLambda(s, Vector(a));
+    return multiplyByLambda(s, SimTK::Vector(a));
 }
 
 //==============================================================================
 // InertiaInverse
 //==============================================================================
-void TaskSpace::InertiaInverse::updateCache(const State& s, Matrix& cache) const
+void TaskSpace::InertiaInverse::updateCache(const SimTK::State& s, SimTK::Matrix& cache) const
 {
-    const SimbodyMatterSubsystem& matter = m_tspace->getMatterSubsystem();
+    const SimTK::SimbodyMatterSubsystem& matter = m_tspace->getMatterSubsystem();
 
     const JacobianTranspose& JT = m_tspace->JT();
-    // TODO const Matrix& JT = m_tspace.JT().value();
-    const Matrix& J = m_tspace->J().getValue(s);
+    // TODO const SimTK::Matrix& JT = m_tspace.JT().value();
+    const SimTK::Matrix& J = m_tspace->J().getValue(s);
     /* TODO
     // TODO cache the result.
 
     unsigned int nst = m_tspace.getNumScalarTasks();
     unsigned int nu = m_tspace.getState().getNU();
 
-    Matrix J = m_tspace.getJacobian().value();
+    SimTK::Matrix J = m_tspace.getJacobian().value();
 
-    Matrix MInvJt(nu, nst);
+    SimTK::Matrix MInvJt(nu, nst);
 
     for (unsigned int j = 0; j < nst; ++j)
     {
@@ -203,17 +201,17 @@ void TaskSpace::InertiaInverse::updateCache(const State& s, Matrix& cache) const
     unsigned int nst = m_tspace->getNumScalarTasks();
     unsigned int nu = s.getNU();
 
-    Matrix& inertiaInverse = cache;
+    SimTK::Matrix& inertiaInverse = cache;
     inertiaInverse.resize(nst, nst);
 
     // Create temporary variables.
-    Vector Jtcol(nu);
-    Vector MInvJtcol(nu);
-    Vector_<Vec3> JMInvJt_j(nt);
+    SimTK::Vector Jtcol(nu);
+    SimTK::Vector MInvJtcol(nu);
+    SimTK::Vector_<SimTK::Vec3> JMInvJt_j(nt);
 
     // f_GP is used to pluck out one column at a time of Jt. Exactly one
     // element at a time of f_GP will be 1, the rest are 0.
-    Vector f_GP(nst, Real(0));
+    SimTK::Vector f_GP(nst, SimTK::Real(0));
 
     for (unsigned int j = 0; j < nst; ++j)
     {
@@ -244,20 +242,20 @@ const TaskSpace::Inertia& TaskSpace::InertiaInverse::inverse() const
 //==============================================================================
 // DynamicallyConsistentJacobianInverse
 //==============================================================================
-void TaskSpace::DynamicallyConsistentJacobianInverse::updateCache(const State& s,
-    Matrix& cache)
+void TaskSpace::DynamicallyConsistentJacobianInverse::updateCache(const SimTK::State& s,
+    SimTK::Matrix& cache)
     const
 {
     const JacobianTranspose& JT = m_tspace->getJacobianTranspose();
-    const Inertia& Lambda = m_tspace->getInertia();
+    const SimTK::Inertia& Lambda = m_tspace->getInertia();
 
     // TODO inefficient?
-    Matrix JtLambda = JT.multiplyByJT(s, Lambda);
+    SimTK::Matrix JtLambda = JT.multiplyByJT(s, Lambda);
 
     unsigned int nst = m_tspace->getNumScalarTasks();
     unsigned int nu = s.getNU();
 
-    Matrix& Jbar = cache;
+    SimTK::Matrix& Jbar = cache;
     Jbar.resize(nu, nst);
 
     for (unsigned int j = 0; j < nst; ++j)
@@ -273,27 +271,27 @@ TaskSpace::DynamicallyConsistentJacobianInverse::transpose() const
     return m_tspace->getDynamicallyConsistentJacobianInverseTranspose();
 }
 
-Vector TaskSpace::DynamicallyConsistentJacobianInverse::multiplyByJBar(
-    const State& s, const Vector& vec) const
+SimTK::Vector TaskSpace::DynamicallyConsistentJacobianInverse::multiplyByJBar(
+    const SimTK::State& s, const SimTK::Vector& vec) const
 {
     const JacobianTranspose& JT = m_tspace->getJacobianTranspose();
-    const Inertia& Lambda = m_tspace->getInertia();
+    const SimTK::Inertia& Lambda = m_tspace->getInertia();
 
     // TODO where is this even used? TODO test this.
 
-    Vector JBarvec;
+    SimTK::Vector JBarvec;
     m_tspace->getMatterSubsystem().multiplyByMInv(s,
             JT.multiplyByJT(s, Lambda.multiplyByLambda(s, vec)), JBarvec);
     return  JBarvec;
 }
 
-Matrix TaskSpace::DynamicallyConsistentJacobianInverse::multiplyByJBar(
-    const State& s, const Matrix& mat) const
+SimTK::Matrix TaskSpace::DynamicallyConsistentJacobianInverse::multiplyByJBar(
+    const SimTK::State& s, const SimTK::Matrix& mat) const
 {
     unsigned int nrow = s.getNU();
     unsigned int ncol = mat.ncol();
 
-    Matrix out(nrow, ncol);
+    SimTK::Matrix out(nrow, ncol);
     for (unsigned int j = 0; j < ncol; ++j)
     {
         out(j) = multiplyByJBar(s, mat(j).getAsVector());
@@ -307,7 +305,7 @@ Matrix TaskSpace::DynamicallyConsistentJacobianInverse::multiplyByJBar(
 // DynamicallyConsistentJacobianInverseTranspose
 //==============================================================================
 void TaskSpace::DynamicallyConsistentJacobianInverseTranspose::updateCache(
-    const State& s, Matrix& cache) const
+    const SimTK::State& s, SimTK::Matrix& cache) const
 {
     cache = transpose().getValue(s).transpose();
 }
@@ -318,8 +316,8 @@ TaskSpace::DynamicallyConsistentJacobianInverseTranspose::transpose() const
     return m_tspace->getDynamicallyConsistentJacobianInverse();
 }
 
-Vector TaskSpace::DynamicallyConsistentJacobianInverseTranspose::multiplyByJBarT(
-    const State& s, const Vector& g) const
+SimTK::Vector TaskSpace::DynamicallyConsistentJacobianInverseTranspose::multiplyByJBarT(
+    const SimTK::State& s, const SimTK::Vector& g) const
 {
     // TODO inefficient. can we have an MInvT operator??
     return getValue(s) * g;
@@ -329,14 +327,14 @@ Vector TaskSpace::DynamicallyConsistentJacobianInverseTranspose::multiplyByJBarT
 //==============================================================================
 // InertialForces
 //==============================================================================
-void TaskSpace::InertialForces::updateCache(const State& s, Vector& cache) const
+void TaskSpace::InertialForces::updateCache(const SimTK::State& s, SimTK::Vector& cache) const
 {
-    Vector jointSpaceInertialForces;
+    SimTK::Vector jointSpaceInertialForces;
     m_tspace->getMatterSubsystem().calcResidualForceIgnoringConstraints(
-            s, Vector(0), Vector_<SpatialVec>(0), Vector(0),
+            s, SimTK::Vector(0), SimTK::Vector_<SimTK::SpatialVec>(0), SimTK::Vector(0),
             jointSpaceInertialForces);
 
-    Vector JDotu;
+    SimTK::Vector JDotu;
     m_tspace->getMatterSubsystem().calcBiasForStationJacobian(
             s,
             m_tspace->getMobilizedBodyIndices(), m_tspace->getStations(),
@@ -344,8 +342,8 @@ void TaskSpace::InertialForces::updateCache(const State& s, Vector& cache) const
 
     const DynamicallyConsistentJacobianInverseTranspose& JBarT =
         m_tspace->JBarT();
-    const Vector& b = jointSpaceInertialForces;
-    const Inertia& Lambda = m_tspace->Lambda();
+    const SimTK::Vector& b = jointSpaceInertialForces;
+    const SimTK::Inertia& Lambda = m_tspace->Lambda();
 
     cache = JBarT.multiplyByJBarT(s, b) - Lambda.multiplyByLambda(s, JDotu);
 }
@@ -354,16 +352,16 @@ void TaskSpace::InertialForces::updateCache(const State& s, Vector& cache) const
 //==============================================================================
 // Gravity
 //==============================================================================
-void TaskSpace::Gravity::updateCache(const State& s, Vector& cache) const
+void TaskSpace::Gravity::updateCache(const SimTK::State& s, SimTK::Vector& cache) const
 {
     cache = m_tspace->JBarT().multiplyByJBarT(s, systemGravity(s));
 }
 
 
-Vector TaskSpace::Gravity::systemGravity(const State& s) const
+SimTK::Vector TaskSpace::Gravity::systemGravity(const SimTK::State& s) const
 {
     // TODO where does this go? Make a separate class?
-    Vector g;
+    SimTK::Vector g;
     m_tspace->getMatterSubsystem().multiplyBySystemJacobianTranspose(
         s,
         m_tspace->getGravityForce().getBodyForces(s),
@@ -377,7 +375,7 @@ Vector TaskSpace::Gravity::systemGravity(const State& s) const
 //==============================================================================
 // NullspaceProjection
 //==============================================================================
-void TaskSpace::NullspaceProjection::updateCache(const State& s, Matrix& cache)
+void TaskSpace::NullspaceProjection::updateCache(const SimTK::State& s, SimTK::Matrix& cache)
 const
 {
     cache = transpose().getValue(s).transpose();
@@ -389,8 +387,8 @@ TaskSpace::NullspaceProjection::transpose() const
     return m_tspace->getNullspaceProjectionTranspose();
 }
 
-Vector TaskSpace::NullspaceProjection::multiplyByN(const State& s,
-    const Vector& vec) const
+SimTK::Vector TaskSpace::NullspaceProjection::multiplyByN(const SimTK::State& s,
+    const SimTK::Vector& vec) const
 {
     return vec - m_tspace->JBar().multiplyByJBar(s,
         m_tspace->J().multiplyByJ(s, vec));
@@ -400,8 +398,8 @@ Vector TaskSpace::NullspaceProjection::multiplyByN(const State& s,
 //==============================================================================
 // NullspaceProjectionTranspose
 //==============================================================================
-void TaskSpace::NullspaceProjectionTranspose::updateCache(const State& s,
-    Matrix& cache) const
+void TaskSpace::NullspaceProjectionTranspose::updateCache(const SimTK::State& s,
+    SimTK::Matrix& cache) const
 {
     cache = 1 - m_tspace->JT().multiplyByJT(s, m_tspace->JBarT());
 }
@@ -412,8 +410,8 @@ TaskSpace::NullspaceProjectionTranspose::transpose() const
     return m_tspace->getNullspaceProjection();
 }
 
-Vector TaskSpace::NullspaceProjectionTranspose::multiplyByNT(const State& s,
-    const Vector& vec) const
+SimTK::Vector TaskSpace::NullspaceProjectionTranspose::multiplyByNT(const SimTK::State& s,
+    const SimTK::Vector& vec) const
 {
     return vec - m_tspace->JT().multiplyByJT(s,
         m_tspace->JBarT().multiplyByJBarT(s, vec));
@@ -424,10 +422,10 @@ Vector TaskSpace::NullspaceProjectionTranspose::multiplyByNT(const State& s,
 // TaskSpace
 //==============================================================================
 // TODO account for applied forces? velocities?
-Vector TaskSpace::calcInverseDynamics(const State& s,
-    const Vector& taskAccelerations) const
+SimTK::Vector TaskSpace::calcInverseDynamics(const SimTK::State& s,
+    const SimTK::Vector& taskAccelerations) const
 {
-    Vector ftasl = JT().multiplyByJT(s,
+    SimTK::Vector ftasl = JT().multiplyByJT(s,
         Lambda().multiplyByLambda(s, taskAccelerations) +
         mu().getValue(s) +
         p().getValue(s));
@@ -435,7 +433,7 @@ Vector TaskSpace::calcInverseDynamics(const State& s,
     return ftasl;
 }
 
-Vector TaskSpace::calcGravityCompensation(const State& s) const
+SimTK::Vector TaskSpace::calcGravityCompensation(const SimTK::State& s) const
 {
     return NT().multiplyByNT(s, g(s));
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Sandbox/TaskSpace/TaskSpace.h b/OpenSim/Sandbox/TaskSpace/TaskSpace.h
index 86f9b8e0a..5a182c827 100644
--- a/OpenSim/Sandbox/TaskSpace/TaskSpace.h
+++ b/OpenSim/Sandbox/TaskSpace/TaskSpace.h
@@ -31,9 +31,6 @@
 
 #include <OpenSim/Simulation/Model/ModelComponent.h>
 #include <OpenSim/Simulation/Model/Model.h>
-
-using namespace SimTK;
-
 namespace OpenSim
 {
     /**
@@ -90,7 +87,7 @@ public: \
     *
     * <h3>Usage</h3>
     *
-    * We expect you to use this class within a Force::Custom::Implementation, but
+    * We expect you to use this class within a SimTK::Force::Custom::Implementation, but
     * this is not the only option. However, this class can only be used within a
     * class that has a realizeTopology method. Here are the necessary steps for
     * making use of this class:
@@ -123,10 +120,10 @@ public: \
         {
         }
 
-        /** The SimbodyMatterSubsystem that this TaskSpace object uses
+        /** The SimTK::SimbodyMatterSubsystem that this TaskSpace object uses
         * to compute its quantities.
         */
-        const SimbodyMatterSubsystem& getMatterSubsystem() const
+        const SimTK::SimbodyMatterSubsystem& getMatterSubsystem() const
         {
             return _model->getMatterSubsystem();
         }
@@ -150,7 +147,7 @@ public: \
         * @param[in] body The index of the body on which the point is fixed.
         * @param[in] station The point of the body, expressed in the body frame.
         */
-        void addStationTask(MobilizedBodyIndex body, Vec3 station)
+        void addStationTask(SimTK::MobilizedBodyIndex body, SimTK::Vec3 station)
         {
             m_indices.push_back(body);
             m_stations.push_back(station);
@@ -177,10 +174,10 @@ public: \
         /** Obtain the location and velocity, in the ground frame and expressed
         * in the ground frame, of the station for a given station task.
         */
-        void findStationLocationAndVelocityInGround(const State& s,
+        void findStationLocationAndVelocityInGround(const SimTK::State& s,
             StationTaskIndex index,
-            const Vec3& stationLocationInBody,
-            Vec3& locationInGround, Vec3& velocityInGround) const
+            const SimTK::Vec3& stationLocationInBody,
+            SimTK::Vec3& locationInGround, SimTK::Vec3& velocityInGround) const
         {
             getMatterSubsystem().getMobilizedBody(m_indices[index])
                 .findStationLocationAndVelocityInGround(s,
@@ -195,14 +192,14 @@ public: \
         * is specified as task-space accelerations, this provides the task-space
         * forces that achieve those accelerations.
         */
-        Vector calcInverseDynamics(const State& s,
-            const Vector& taskAccelerations) const;
+        SimTK::Vector calcInverseDynamics(const SimTK::State& s,
+            const SimTK::Vector& taskAccelerations) const;
 
-        Vector calcGravityCompensation(const State& s) const;
+        SimTK::Vector calcGravityCompensation(const SimTK::State& s) const;
 
         /** The joint-space gravity forces (nu x 1).
         */
-        Vector g(const State& s) const
+        SimTK::Vector g(const SimTK::State& s) const
         {
             return getGravity().systemGravity(s);
         }
@@ -240,12 +237,12 @@ public: \
 
     private:
 
-        const Array_<MobilizedBodyIndex>& getMobilizedBodyIndices() const
+        const SimTK::Array_<SimTK::MobilizedBodyIndex>& getMobilizedBodyIndices() const
         {
             return m_indices;
         }
 
-        const Array_<Vec3>& getStations() const
+        const SimTK::Array_<SimTK::Vec3>& getStations() const
         {
             return m_stations;
         }
@@ -255,8 +252,8 @@ public: \
         //==========================================================================
 
         // For station tasks
-        Array_<MobilizedBodyIndex> m_indices;
-        Array_<Vec3> m_stations;
+        SimTK::Array_<SimTK::MobilizedBodyIndex> m_indices;
+        SimTK::Array_<SimTK::Vec3> m_stations;
 
     public:
 
@@ -264,18 +261,18 @@ public: \
         // nested classes
         //==========================================================================
 
-        /** An abstract class for common task-space Matrix or Vector quantities.
+        /** An abstract class for common task-space SimTK::Matrix or SimTK::Vector quantities.
         *
         * All task-space quantities must be capable of providing their explicit
-        * value. After this value is computed, it is cached in the State for
+        * value. After this value is computed, it is cached in the SimTK::State for
         * efficiency. These classes may optionally provide operators that allow
         * for more efficient computations.
         *
         * The template parameter T is the type of the task-space quantity
-        * (e.g., Matrix). The parameter S is used when allocating the cache entry;
+        * (e.g., SimTK::Matrix). The parameter S is used when allocating the cache entry;
         * it is the earliest stage at which the cache entry can be provided.
         */
-        template <typename T, Stage::Level S = Stage::Position>
+        template <typename T, SimTK::Stage::Level S = SimTK::Stage::Position>
         class TaskSpaceQuantity : public Component
         {
         public:
@@ -288,7 +285,7 @@ public: \
             /** Obtain this quantity explicitly. If possible, use operators
             * instead of this method.
             */
-            const T& getValue(const State& s) const
+            const T& getValue(const SimTK::State& s) const
             {
                 if (!isCacheVariableValid(s, m_cacheName))
                 {
@@ -308,7 +305,7 @@ public: \
 
         protected:
 
-            ReferencePtr<TaskSpace> m_tspace;
+            SimTK::ReferencePtr<TaskSpace> m_tspace;
 
             void extendAddToSystem(SimTK::MultibodySystem& system) const override
             {
@@ -320,11 +317,11 @@ public: \
 
             std::string m_cacheName;
 
-            virtual void updateCache(const State& s, T& cache) const = 0;
+            virtual void updateCache(const SimTK::State& s, T& cache) const = 0;
 
             // The earliest stage at which this quantity can be calculated. This
             // is used for creating lazy cache entries.
-            static Stage getEarliestStage()
+            static SimTK::Stage getEarliestStage()
             {
                 return S;
             }
@@ -332,20 +329,20 @@ public: \
 
         // Forward declarations.
         class JacobianTranspose;
-        class Inertia;
+        class SimTK::Inertia;
         class DynamicallyConsistentJacobianInverseTranspose;
         class InertiaInverse;
         class NullspaceProjectionTranspose;
 
         /** Relates task-space velocities to generalized speeds; (nst x nu).
         */
-        class Jacobian : public TaskSpaceQuantity<Matrix>
+        class Jacobian : public TaskSpaceQuantity<SimTK::Matrix>
         {
-            OpenSim_DECLARE_CONCRETE_OBJECT(Jacobian, TaskSpaceQuantity<Matrix>);
+            OpenSim_DECLARE_CONCRETE_OBJECT(Jacobian, TaskSpaceQuantity<SimTK::Matrix>);
         public:
 
             Jacobian()
-                : TaskSpaceQuantity<Matrix>("jacobian")
+                : TaskSpaceQuantity<SimTK::Matrix>("jacobian")
             {
             }
 
@@ -353,26 +350,26 @@ public: \
 
             /// Using this operator is likely more efficient than obtaining this
             /// matrix explicitly and performing the multiplication on your own.
-            Vector multiplyByJ(const State& s, const Vector& u) const;
+            SimTK::Vector multiplyByJ(const SimTK::State& s, const SimTK::Vector& u) const;
 
-            // TODO Matrix_<Vec3> operator*(const Matrix& u) const;
-            // TODO Matrix operator*(const Matrix& u) const;
-            // TODO Matrix operator*(const NullspaceProjection& N) const;
+            // TODO Matrix_<SimTK::Vec3> operator*(const SimTK::Matrix& u) const;
+            // TODO SimTK::Matrix operator*(const SimTK::Matrix& u) const;
+            // TODO SimTK::Matrix operator*(const NullspaceProjection& N) const;
         private:
 
-            void updateCache(const State& s, Matrix& cache) const override;
+            void updateCache(const SimTK::State& s, SimTK::Matrix& cache) const override;
         };
 
         /** Used to compute task-space forces; (nu x nst).
         */
-        class JacobianTranspose : public TaskSpaceQuantity<Matrix>
+        class JacobianTranspose : public TaskSpaceQuantity<SimTK::Matrix>
         {
             OpenSim_DECLARE_CONCRETE_OBJECT(JacobianTranspose,
-                TaskSpaceQuantity<Matrix>);
+                TaskSpaceQuantity<SimTK::Matrix>);
         public:
 
             JacobianTranspose()
-                : TaskSpaceQuantity<Matrix>("jacobianTranspose")
+                : TaskSpaceQuantity<SimTK::Matrix>("jacobianTranspose")
             {
             }
 
@@ -383,84 +380,84 @@ public: \
                 return transpose();
             }
 
-            Vector multiplyByJT(const State& s, const Vector_<Vec3>& f_GP) const;
+            SimTK::Vector multiplyByJT(const SimTK::State& s, const SimTK::Vector_<SimTK::Vec3>& f_GP) const;
 
-            Vector multiplyByJT(const State& s, const Vector& f_GP) const;
+            SimTK::Vector multiplyByJT(const SimTK::State& s, const SimTK::Vector& f_GP) const;
 
-            Vector multiplyByJT(const State& s, const Vec3& f_GP) const;
+            SimTK::Vector multiplyByJT(const SimTK::State& s, const SimTK::Vec3& f_GP) const;
 
-            // TODO Matrix operator*(const Matrix_<Vec3>& f_GP) const;
+            // TODO SimTK::Matrix operator*(const Matrix_<SimTK::Vec3>& f_GP) const;
 
-            Matrix multiplyByJT(const State& s, const Matrix& f_GP) const;
+            SimTK::Matrix multiplyByJT(const SimTK::State& s, const SimTK::Matrix& f_GP) const;
 
-            Matrix multiplyByJT(const State& s, const TaskSpace::Inertia& Lambda) const;
+            SimTK::Matrix multiplyByJT(const SimTK::State& s, const TaskSpace::Inertia& Lambda) const;
 
-            Matrix multiplyByJT(const State& s,
+            SimTK::Matrix multiplyByJT(const SimTK::State& s,
                 const TaskSpace::DynamicallyConsistentJacobianInverseTranspose&
                 JBarT) const;
 
         private:
 
-            void updateCache(const State& s, Matrix& cache) const override;
+            void updateCache(const SimTK::State& s, SimTK::Matrix& cache) const override;
         };
 
         /** Task-space inertia matrix; \f$ \Lambda = (J A^{-1} J^T)^{-1} \f$
         * (nst x nst).
         */
-        class Inertia : public TaskSpaceQuantity<Matrix>
+        class SimTK::Inertia : public TaskSpaceQuantity<SimTK::Matrix>
         {
-            OpenSim_DECLARE_CONCRETE_OBJECT(Inertia, TaskSpaceQuantity<Matrix>);
+            OpenSim_DECLARE_CONCRETE_OBJECT(SimTK::Inertia, TaskSpaceQuantity<SimTK::Matrix>);
         public:
 
-            Inertia()
-                : TaskSpaceQuantity<Matrix>("inertia")
+            SimTK::Inertia()
+                : TaskSpaceQuantity<SimTK::Matrix>("inertia")
             {
             }
 
             const InertiaInverse& inverse() const;
 
-            Vector multiplyByLambda(const State& s, const Vector& a) const;
+            SimTK::Vector multiplyByLambda(const SimTK::State& s, const SimTK::Vector& a) const;
 
-            Vector multiplyByLambda(const State& s, const Vec3& a) const;
+            SimTK::Vector multiplyByLambda(const SimTK::State& s, const SimTK::Vec3& a) const;
 
         private:
 
-            void updateCache(const State& s, Matrix& cache) const override;
+            void updateCache(const SimTK::State& s, SimTK::Matrix& cache) const override;
         };
 
         /** Inverse of task-space inertia matrix;
         * \f$ \Lambda^{-1} = J M^{-1} J^T \f$ (nst x nst).
         *
-        * This is only needed for computing the Inertia matrix.
+        * This is only needed for computing the SimTK::Inertia matrix.
         */
-        class InertiaInverse : public TaskSpaceQuantity<Matrix>
+        class InertiaInverse : public TaskSpaceQuantity<SimTK::Matrix>
         {
-            OpenSim_DECLARE_CONCRETE_OBJECT(InertiaInverse, TaskSpaceQuantity<Matrix>);
+            OpenSim_DECLARE_CONCRETE_OBJECT(InertiaInverse, TaskSpaceQuantity<SimTK::Matrix>);
         public:
 
             InertiaInverse()
-                : TaskSpaceQuantity<Matrix>("inertiaInverse")
+                : TaskSpaceQuantity<SimTK::Matrix>("inertiaInverse")
             {
             }
 
-            const Inertia& inverse() const;
+            const SimTK::Inertia& inverse() const;
 
         private:
 
-            void updateCache(const State& s, Matrix& cache) const override;
+            void updateCache(const SimTK::State& s, SimTK::Matrix& cache) const override;
         };
 
         /** Mass-matrix weighted generalized inverse;
         * \f$ \bar{J} = A^{-1} J^T \Lambda \f$ (nu x nst).
         */
-        class DynamicallyConsistentJacobianInverse : public TaskSpaceQuantity<Matrix>
+        class DynamicallyConsistentJacobianInverse : public TaskSpaceQuantity<SimTK::Matrix>
         {
             OpenSim_DECLARE_CONCRETE_OBJECT(DynamicallyConsistentJacobianInverse,
-                TaskSpaceQuantity<Matrix>);
+                TaskSpaceQuantity<SimTK::Matrix>);
         public:
 
             DynamicallyConsistentJacobianInverse()
-                : TaskSpaceQuantity<Matrix>("jacobianInverse")
+                : TaskSpaceQuantity<SimTK::Matrix>("jacobianInverse")
             {
             }
 
@@ -471,26 +468,26 @@ public: \
                 return transpose();
             }
 
-            Vector multiplyByJBar(const State& s, const Vector& vec) const;
+            SimTK::Vector multiplyByJBar(const SimTK::State& s, const SimTK::Vector& vec) const;
 
-            Matrix multiplyByJBar(const State& s, const Matrix& mat) const;
+            SimTK::Matrix multiplyByJBar(const SimTK::State& s, const SimTK::Matrix& mat) const;
 
         private:
 
-            void updateCache(const State& s, Matrix& cache) const override;
+            void updateCache(const SimTK::State& s, SimTK::Matrix& cache) const override;
         };
 
         /** (nst x nu).
         */
         class DynamicallyConsistentJacobianInverseTranspose :
-            public TaskSpaceQuantity<Matrix>
+            public TaskSpaceQuantity<SimTK::Matrix>
         {
             OpenSim_DECLARE_CONCRETE_OBJECT(DynamicallyConsistentJacobianInverseTranspose,
-                TaskSpaceQuantity<Matrix>);
+                TaskSpaceQuantity<SimTK::Matrix>);
         public:
 
             DynamicallyConsistentJacobianInverseTranspose()
-                : TaskSpaceQuantity<Matrix>("jacobianInverseTranspoase")
+                : TaskSpaceQuantity<SimTK::Matrix>("jacobianInverseTranspoase")
             {
             }
 
@@ -502,71 +499,71 @@ public: \
                 return transpose();
             }
 
-            Vector multiplyByJBarT(const State& s, const Vector& g) const;
+            SimTK::Vector multiplyByJBarT(const SimTK::State& s, const SimTK::Vector& g) const;
 
         private:
 
-            void updateCache(const State& s, Matrix& cache) const override;
+            void updateCache(const SimTK::State& s, SimTK::Matrix& cache) const override;
         };
 
         /** Includes Coriolis forces and the like;
         * \f$ \mu = \bar{J}^T b - \Lambda \dot{J} u \f$ (nst x 1).
         */
-        class InertialForces : public TaskSpaceQuantity<Vector, Stage::Velocity>
+        class InertialForces : public TaskSpaceQuantity<SimTK::Vector, SimTK::Stage::Velocity>
         {
             OpenSim_DECLARE_CONCRETE_OBJECT(InertialForces,
-                TaskSpaceQuantity<Vector>);//problem with stage
+                TaskSpaceQuantity<SimTK::Vector>);//problem with stage
         public:
 
             InertialForces()
-                : TaskSpaceQuantity<Vector, Stage::Velocity>("inertialForce")
+                : TaskSpaceQuantity<SimTK::Vector, SimTK::Stage::Velocity>("inertialForce")
             {
             }
 
         private:
 
-            void updateCache(const State& s, Vector& cache) const override;
+            void updateCache(const SimTK::State& s, SimTK::Vector& cache) const override;
         };
 
         /** The task-space forces arising from gravity;
         * \f$ p = \bar{J}^T g \f$ (nst x 1).
         */
-        class Gravity : public TaskSpaceQuantity<Vector>
+        class Gravity : public TaskSpaceQuantity<SimTK::Vector>
         {
-            OpenSim_DECLARE_CONCRETE_OBJECT(Gravity, TaskSpaceQuantity<Vector>);
+            OpenSim_DECLARE_CONCRETE_OBJECT(Gravity, TaskSpaceQuantity<SimTK::Vector>);
         public:
 
             Gravity()
-                : TaskSpaceQuantity<Vector>("gravityForce")
+                : TaskSpaceQuantity<SimTK::Vector>("gravityForce")
             {
             }
 
             /** The joint-space gravity forces (nu x 1).
             */
-            Vector systemGravity(const State& s) const;
+            SimTK::Vector systemGravity(const SimTK::State& s) const;
 
             /** A shorthand for the joint-space gravity forces (nu x 1).
             */
-            Vector g(const State& s) const
+            SimTK::Vector g(const SimTK::State& s) const
             {
                 return systemGravity(s);
             }
 
         private:
 
-            void updateCache(const State& s, Vector& cache) const override;
+            void updateCache(const SimTK::State& s, SimTK::Vector& cache) const override;
         };
 
         /** Used to prioritize tasks; \f$ N = I - \bar{J} J \f$ (nu x nu).
         */
-        class NullspaceProjection : public TaskSpaceQuantity<Matrix>
+        class NullspaceProjection : public TaskSpaceQuantity<SimTK::Matrix>
         {
             OpenSim_DECLARE_CONCRETE_OBJECT(NullspaceProjection,
-                TaskSpaceQuantity<Matrix>);
+                TaskSpaceQuantity<SimTK::Matrix>);
         public:
 
             NullspaceProjection()
-                : TaskSpaceQuantity<Matrix>("nullspace")
+                : TaskSpaceQuantity<SimTK::Matrix>("nullspace")
             {
             }
 
@@ -577,23 +574,23 @@ public: \
                 return transpose();
             }
 
-            Vector multiplyByN(const State& s, const Vector& vec) const;
+            SimTK::Vector multiplyByN(const SimTK::State& s, const SimTK::Vector& vec) const;
 
         private:
 
-            void updateCache(const State& s, Matrix& cache) const override;
+            void updateCache(const SimTK::State& s, SimTK::Matrix& cache) const override;
         };
 
         /** (nu x nu).
         */
-        class NullspaceProjectionTranspose : public TaskSpaceQuantity<Matrix>
+        class NullspaceProjectionTranspose : public TaskSpaceQuantity<SimTK::Matrix>
         {
             OpenSim_DECLARE_CONCRETE_OBJECT(NullspaceProjectionTranspose,
-                TaskSpaceQuantity<Matrix>);
+                TaskSpaceQuantity<SimTK::Matrix>);
         public:
 
             NullspaceProjectionTranspose()
-                : TaskSpaceQuantity<Matrix>("nullspaceTranspose")
+                : TaskSpaceQuantity<SimTK::Matrix>("nullspaceTranspose")
             {
             }
 
@@ -604,18 +601,18 @@ public: \
             {
                 return transpose();
             }
-            Vector multiplyByNT(const State& s, const Vector& vec) const;
+            SimTK::Vector multiplyByNT(const SimTK::State& s, const SimTK::Vector& vec) const;
 
         private:
 
-            void updateCache(const State& s, Matrix& cache) const override;
+            void updateCache(const SimTK::State& s, SimTK::Matrix& cache) const override;
         };
 
         /// @name Access to TaskSpaceQuantity's.
         /// @{
         TASKSPACEQUANTITY_MEMBERS(Jacobian, jacobian, J);
         TASKSPACEQUANTITY_MEMBERS(JacobianTranspose, jacobianTranspose, JT);
-        TASKSPACEQUANTITY_MEMBERS(Inertia, inertia, Lambda);
+        TASKSPACEQUANTITY_MEMBERS(SimTK::Inertia, inertia, Lambda);
         TASKSPACEQUANTITY_MEMBERS(InertiaInverse, inertiaInverse, LambdaInv);
         TASKSPACEQUANTITY_MEMBERS(DynamicallyConsistentJacobianInverse, jacobianInverse, JBar);
         TASKSPACEQUANTITY_MEMBERS(DynamicallyConsistentJacobianInverseTranspose, jacobianInverseTranspose, JBarT);
@@ -627,4 +624,4 @@ public: \
     };
 } // end namespace
 
-#endif // TASK_SPACE_H
+#endif // TASK_SPACE_H
\ No newline at end of file
diff --git a/OpenSim/Sandbox/TaskSpace/futureTaskSpace.cpp b/OpenSim/Sandbox/TaskSpace/futureTaskSpace.cpp
index c0e3be050..632152a3f 100644
--- a/OpenSim/Sandbox/TaskSpace/futureTaskSpace.cpp
+++ b/OpenSim/Sandbox/TaskSpace/futureTaskSpace.cpp
@@ -40,9 +40,7 @@ the gravity compensation is considered.
 #include "TaskSpace.h"
 
 using namespace OpenSim;
-using namespace SimTK;
-
-void switchMuscles(Model& model, State& state, bool appliesForce);
+void switchMuscles(Model& model, SimTK::State& state, bool appliesForce);
 void testTaskSpace();
 
 //#define PAUSE
@@ -78,7 +76,7 @@ int main()
     return 0;
 }
 
-void switchMuscles(Model& model, State& state, bool appliesForce)
+void switchMuscles(Model& model, SimTK::State& state, bool appliesForce)
 {
     for (int i = 0; i < model.updMuscles().getSize(); i++)
     {
@@ -91,7 +89,7 @@ void testTaskSpace()
     Model model("futureTaskSpace.osim");
 
     std::string indexBodyName = "hand_r";
-    Vec3 indexOffset(0.05, -0.14, 0.011);
+    SimTK::Vec3 indexOffset(0.05, -0.14, 0.011);
 
     Kinematics* kinematics = new Kinematics(&model);
     model.addAnalysis(kinematics);
@@ -105,7 +103,7 @@ void testTaskSpace()
     model.addForce(forceController);
 
     model.buildSystem();
-    State& s = model.initializeState();
+    SimTK::State& s = model.initializeState();
     switchMuscles(model, s, false);
 
     double dt = 0.01;
@@ -127,7 +125,7 @@ void testTaskSpace()
 
         manager.integrate(s, i*dt);
 
-        forceController->setAcceleration(Vec3(0, 10, 0));
+        forceController->setAcceleration(SimTK::Vec3(0, 10, 0));
     }
 
     //store results
diff --git a/OpenSim/Sandbox/UsefulComponents/futureComponents.cpp b/OpenSim/Sandbox/UsefulComponents/futureComponents.cpp
index 9b44115fa..28102f1bf 100644
--- a/OpenSim/Sandbox/UsefulComponents/futureComponents.cpp
+++ b/OpenSim/Sandbox/UsefulComponents/futureComponents.cpp
@@ -4,12 +4,11 @@
 #include "FunctionComponentSocket.h"
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 //#define PAUSE 1
 
-double testFunction(const State& s)
+double testFunction(const SimTK::State& s)
 {
     return s.getTime();
 }
@@ -28,9 +27,9 @@ void test()
     rep->updInput("inputs").connect(fun->getOutput("output"));
     model.addComponent(rep);
 
-    State& s = model.initSystem();
+    SimTK::State& s = model.initSystem();
 
-    RungeKuttaMersonIntegrator integrator(model.getSystem());
+    SimTK::RungeKuttaMersonIntegrator integrator(model.getSystem());
     Manager manager(model, integrator);
     integrator.setMaximumStepSize(0.1);
     s.setTime(0.0);
@@ -65,4 +64,4 @@ int main()
 #endif
 
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Sandbox/futureIKListOutputs.cpp b/OpenSim/Sandbox/futureIKListOutputs.cpp
index c8ff907af..c2fdb2d55 100644
--- a/OpenSim/Sandbox/futureIKListOutputs.cpp
+++ b/OpenSim/Sandbox/futureIKListOutputs.cpp
@@ -2,8 +2,6 @@
 #include <OpenSim/OpenSim.h>
 
 using namespace OpenSim;
-using namespace SimTK;
-
 // This example only deals with "list outputs" in which each output is a
 // single value of type T. The key notion here is that outputs can contain
 // any number of channels.
@@ -20,15 +18,15 @@ class JointCenter : public ModelComponent {
 public:
     // TODO to a list input, vector and list outputs look the same.
     // TODO so make these into list inputs again.
-    OpenSim_DECLARE_LIST_INPUT(seg1_markers, Vec3, SimTK::Stage::Time,
+    OpenSim_DECLARE_LIST_INPUT(seg1_markers, SimTK::Vec3, SimTK::Stage::Time,
         "Markers on segment 1.");
-    OpenSim_DECLARE_LIST_INPUT(seg2_markers, Vec3, SimTK::Stage::Time,
+    OpenSim_DECLARE_LIST_INPUT(seg2_markers, SimTK::Vec3, SimTK::Stage::Time,
         "Markers on segment 2.");
-    OpenSim_DECLARE_OUTPUT(joint_center, Vec3, getJointCenter,
+    OpenSim_DECLARE_OUTPUT(joint_center, SimTK::Vec3, getJointCenter,
                            SimTK::Stage::Time);
-    Vec3 getJointCenter(const SimTK::State& s) const {
-        const auto& seg1 = getInput<Vec3>("seg1_markers").getVector(s);
-        const auto& seg2 = getInput<Vec3>("seg2_markers").getVector(s);
+    SimTK::Vec3 getJointCenter(const SimTK::State& s) const {
+        const auto& seg1 = getInput<SimTK::Vec3>("seg1_markers").getVector(s);
+        const auto& seg2 = getInput<SimTK::Vec3>("seg2_markers").getVector(s);
         
         // I'm just doing an arbitrary calculation with both vectors.
         return 0.5 * (seg1.sum() + seg2.sum());
@@ -83,7 +81,7 @@ public:
         // This means that requested time is an exact match.
         if (iabove == -1) {
             // TODO this is all probably very inefficient, but I had trouble
-            // converting a RowVector_<T> to a Vector_<T>.
+            // converting a SimTK::RowVector_<T> to a SimTK::Vector_<T>.
             SimTK::Vector_<T> transposed(rowBelow.size());
             for (int i = 0; i < rowBelow.size(); ++i) transposed[i] = rowBelow[i];
             return transposed;
@@ -96,7 +94,7 @@ public:
         const auto& result = rowBelow + fraction * delta;
         
         // TODO this is all probably very inefficient, but I had trouble
-        // converting a RowVector_<T> to a Vector_<T>.
+        // converting a SimTK::RowVector_<T> to a SimTK::Vector_<T>.
         SimTK::Vector_<T> transposed(result.size());
         // TODO transposed.copyAssign(result.transpose());
         for (int i = 0; i < result.size(); ++i) transposed[i] = result[i];
@@ -160,7 +158,7 @@ typedef DataSource_<SimTK::Vec3> DataSourceVec3;
 
 // TODO InverseKinematics shouldn't really produce a coordinates output;
 // it's more of a states solver--it should be editing the coordinate values
-// in the State. So, this example is really mostly for demonstration.
+// in the SimTK::State. So, this example is really mostly for demonstration.
 // TODO It actually would work really well as a task space controller.
 class InverseKinematics : public ModelComponent {
     OpenSim_DECLARE_CONCRETE_OBJECT(InverseKinematics, ModelComponent);
@@ -168,17 +166,17 @@ public:
     // TODO connector to a model.
     
     // TODO convert these to vectors.
-    OpenSim_DECLARE_LIST_OUTPUT(model_marker_pos, Vec3, getModelMarkerPosition,
+    OpenSim_DECLARE_LIST_OUTPUT(model_marker_pos, SimTK::Vec3, getModelMarkerPosition,
         SimTK::Stage::Position);
     OpenSim_DECLARE_LIST_OUTPUT(coords, double, getSolution,
         SimTK::Stage::Position);
-    OpenSim_DECLARE_LIST_INPUT(targets, Vec3, SimTK::Stage::Position,
+    OpenSim_DECLARE_LIST_INPUT(targets, SimTK::Vec3, SimTK::Stage::Position,
         "The target (experimental) marker positions. Input aliases must "
         "be the name of the model marker to pair with each target.");
     // TODO OpenSim_DECLARE_LIST_INPUT(marker_weights, double, SimTK::Stage::Position,
     // TODO     "Weights for each marker specified in targets.");
     
-    Vec3 getModelMarkerPosition(const SimTK::State& s, const std::string& name) const {
+    SimTK::Vec3 getModelMarkerPosition(const SimTK::State& s, const std::string& name) const {
         solve(s); // TODO cache the result in some way.
         const auto& markerSet = getModel().getMarkerSet();
         const auto& ground = getModel().getGround();
@@ -193,7 +191,7 @@ public:
     
     void solve(const SimTK::State& s) const {
         // These target markers could have come from mixed sources.
-        const auto& targets = getInput<Vec3>("targets").getVector(s);
+        const auto& targets = getInput<SimTK::Vec3>("targets").getVector(s);
         // To pretend like we're doing something useful, we'll multiply by
         // the station Jacobian transpose.
         // TODO
@@ -213,7 +211,7 @@ public:
         // that work.
         const_cast<Self*>(this)->_onBodyB.clear();
         const_cast<Self*>(this)->_stationPinB.clear();
-        const auto& input = getInput<Vec3>("targets");
+        const auto& input = getInput<SimTK::Vec3>("targets");
         for (int ichan = 0; ichan < input.getNumConnectees(); ++ichan) {
             const auto& markerName = input.getAlias(ichan);
             const auto& marker = getModel().getMarkerSet().get(markerName);
@@ -240,12 +238,12 @@ private:
     SimTK::Array_<SimTK::Vec3> _stationPinB;
 };
 
-typedef ConsoleReporter_<Vector_<Vec3>> ConsoleReporterVectorVec3;
+typedef ConsoleReporter_<SimTK::Vector_<SimTK::Vec3>> ConsoleReporterVectorVec3;
 
-void integrate(const System& system, Integrator& integrator,
-        const State& initialState,
-        Real finalTime) {
-    TimeStepper ts(system, integrator);
+void integrate(const SimTK::System& system, SimTK::Integrator& integrator,
+        const SimTK::State& initialState,
+        SimTK::Real finalTime) {
+    SimTK::TimeStepper ts(system, integrator);
     ts.initialize(initialState);
     ts.setReportAllSignificantStates(true);
     integrator.setReturnEveryInternalStep(true); 
@@ -256,17 +254,17 @@ void integrate(const System& system, Integrator& integrator,
 }
 
 void createModel(Model& model) {
-    auto* pelvis = new OpenSim::Body("pelvis", 1.0, Vec3(0), Inertia(1));
+    auto* pelvis = new OpenSim::Body("pelvis", 1.0, SimTK::Vec3(0), SimTK::Inertia(1));
     model.addBody(pelvis);
-    auto* femur = new OpenSim::Body("femur", 1.0, Vec3(0), Inertia(1));
+    auto* femur = new OpenSim::Body("femur", 1.0, SimTK::Vec3(0), SimTK::Inertia(1));
     model.addBody(femur);
     auto* hog = new PinJoint("hog",
-                             model.getGround(), Vec3(0), Vec3(0),
-                             *pelvis,           Vec3(0, 1, 0), Vec3(0));
+                             model.getGround(), SimTK::Vec3(0), SimTK::Vec3(0),
+                             *pelvis,           SimTK::Vec3(0, 1, 0), SimTK::Vec3(0));
     model.addJoint(hog);
     auto* hip = new PinJoint("hip",
-                             *pelvis, Vec3(0), Vec3(0),
-                             *femur,  Vec3(0, 1, 0), Vec3(0));
+                             *pelvis, SimTK::Vec3(0), SimTK::Vec3(0),
+                             *femur,  SimTK::Vec3(0, 1, 0), SimTK::Vec3(0));
     model.addJoint(hip);
     hog->updCoordinate().setDefaultValue(0.5 * SimTK::Pi);
     
@@ -295,17 +293,17 @@ void createModel(Model& model) {
     model.addMarker(hjc);
 }
 
-void fabricateExperimentalMarkers(TimeSeriesTable_<Vec3>& table) {
+void fabricateExperimentalMarkers(TimeSeriesTable_<SimTK::Vec3>& table) {
     table.setColumnLabels({"asis", "psis", "med_knee", "lat_knee", "thigh"});
     
-    TimeSeriesTable_<Vec3>::RowVector row(5, Vec3(0.0));
-    row[1] = Vec3(0, 0, 0); row[2] = Vec3(1, 0, 0); row[3] = Vec3(2, 0, 0);
-    row[4] = Vec3(3, 0, 0);
-    table.appendRow(0.0, row); row += Vec3(0, 1, 0);
-    table.appendRow(0.25, row); row += Vec3(1, 0, 0);
-    table.appendRow(0.50, row); row += Vec3(0, 0, 1);
-    table.appendRow(0.75, row); row += Vec3(2, 0, 0);
-    table.appendRow(1.0, row); row += Vec3(0, 3, 0);
+    TimeSeriesTable_<SimTK::Vec3>::RowVector row(5, SimTK::Vec3(0.0));
+    row[1] = SimTK::Vec3(0, 0, 0); row[2] = SimTK::Vec3(1, 0, 0); row[3] = SimTK::Vec3(2, 0, 0);
+    row[4] = SimTK::Vec3(3, 0, 0);
+    table.appendRow(0.0, row); row += SimTK::Vec3(0, 1, 0);
+    table.appendRow(0.25, row); row += SimTK::Vec3(1, 0, 0);
+    table.appendRow(0.50, row); row += SimTK::Vec3(0, 0, 1);
+    table.appendRow(0.75, row); row += SimTK::Vec3(2, 0, 0);
+    table.appendRow(1.0, row); row += SimTK::Vec3(0, 3, 0);
     table.appendRow(1.1, row);
 }
 
@@ -385,14 +383,14 @@ void testFutureIKListOutputs() {
     ik->updInput("targets").connect(exp->getOutput("col"));
     // Must provide an alias for this output since we need a way to figure out
     // which marker it corresponds to. The InverseKinematics component uses
-    // aliases to pair target Vec3's with model markers.
+    // aliases to pair target SimTK::Vec3's with model markers.
     ik->updInput("targets").connect(hjc->getOutput("joint_center"), "hjc");
     
     // Connect up the reporters.
     expRep->updInput("inputs").connect(exp->getOutput("col").getChannel("asis"));
     expRep->updInput("inputs").connect(exp->getOutput("col").getChannel("psis"));
     expRep->updInput("inputs").connect(hjc->getOutput("joint_center"));
-    // This outputs a Vector_<Vec3>.
+    // This outputs a SimTK::Vector_<SimTK::Vec3>.
     vecRep->updInput("inputs").connect(exp->getOutput("all"));
     
     modelMarkers->updInput("inputs").connect(ik->getOutput("model_marker_pos"));
@@ -406,7 +404,7 @@ void testFutureIKListOutputs() {
     SimTK::State& s = model.initSystem();
     
     // TODO replace with a driver / time step advancer.
-    RungeKuttaMersonIntegrator integrator(model.getSystem());
+    SimTK::RungeKuttaMersonIntegrator integrator(model.getSystem());
     integrator.setFixedStepSize(0.1);
     integrate(model.getSystem(), integrator, s, 1.0);
 }
@@ -415,7 +413,4 @@ int main() {
     // TODO SimTK_START_TEST("futureIKListOutputs");
         SimTK_SUBTEST(testFutureIKListOutputs);
     //SimTK_END_TEST();
-}
-
-
-
+}
\ No newline at end of file
diff --git a/OpenSim/Sandbox/futureMarkerPreview.cpp b/OpenSim/Sandbox/futureMarkerPreview.cpp
index 5dffc4d61..e0000c5a6 100644
--- a/OpenSim/Sandbox/futureMarkerPreview.cpp
+++ b/OpenSim/Sandbox/futureMarkerPreview.cpp
@@ -5,8 +5,6 @@
 #include <OpenSim/Simulation/Model/Point.h>
 
 using namespace OpenSim;
-using namespace SimTK;
-
 //==============================================================================
 //                               ExperimentalMarker
 //==============================================================================
@@ -20,7 +18,7 @@ and not physically attached to the musculoskeletal model. It is assumed that its
 value is its location with respect to the lab (Ground) frame.
 
 The location in Ground value of an ExperimentalMarker is obtained from its
-Input<Vec3>("location_in_ground").
+Input<SimTK::Vec3>("location_in_ground").
 
 @authors Ajay Seth
 **/
@@ -58,11 +56,11 @@ private:
     }
 
     SimTK::Vec3 calcVelocityInGround(const SimTK::State& s) const override {
-        return SimTK::Vec3(NaN);
+        return SimTK::Vec3(SimTK::NaN);
     }
 
     SimTK::Vec3 calcAccelerationInGround(const SimTK::State& s) const override {
-        return SimTK::Vec3(NaN);
+        return SimTK::Vec3(SimTK::NaN);
     }
 
     void generateDecorations(bool fixed, const ModelDisplayHints& hints,
@@ -133,7 +131,4 @@ int main() {
     previewMarkerData("futureMarkerPreviewData.trc");
 
 return 0;
-}
-
-
-
+}
\ No newline at end of file
diff --git a/OpenSim/Sandbox/futureMuscleMetabolicsResponse.cpp b/OpenSim/Sandbox/futureMuscleMetabolicsResponse.cpp
index 845db86db..5ae1e1fc0 100644
--- a/OpenSim/Sandbox/futureMuscleMetabolicsResponse.cpp
+++ b/OpenSim/Sandbox/futureMuscleMetabolicsResponse.cpp
@@ -2,8 +2,6 @@
 #include <OpenSim/Common/Reporter.h>
 
 using namespace OpenSim;
-using namespace SimTK;
-
 class ComplexResponse : public ModelComponent {
     OpenSim_DECLARE_CONCRETE_OBJECT(ComplexResponse, ModelComponent);
 public:
@@ -17,7 +15,7 @@ public:
     ComplexResponse() {
         constructProperties();
     }
-    double getTerm1(const State& s) const {
+    double getTerm1(const SimTK::State& s) const {
         if (!isCacheVariableValid(s, "term_1")) {
             const auto& coord = getConnectee<Coordinate>("coord");
             const auto value = coord.getValue(s);
@@ -25,7 +23,7 @@ public:
         }
         return getCacheVariableValue<double>(s, "term_1");
     }
-    double getTerm2(const State& s) const {
+    double getTerm2(const SimTK::State& s) const {
         if (!isCacheVariableValid(s, "term_2")) {
             const auto& coord = getConnectee<Coordinate>("coord");
             const auto speed = coord.getSpeedValue(s);
@@ -33,7 +31,7 @@ public:
         }
         return getCacheVariableValue<double>(s, "term_2");
     }
-    double getSum(const State& s) const {
+    double getSum(const SimTK::State& s) const {
         if (!isCacheVariableValid(s, "sum")) {
             setCacheVariableValue(s, "sum", getTerm1(s) + getTerm2(s));
         }
@@ -43,7 +41,7 @@ private:
     void constructProperties() {
         constructProperty_strength(3.0);
     }
-    void extendAddToSystem(MultibodySystem& system) const override {
+    void extendAddToSystem(SimTK::MultibodySystem& system) const override {
         Super::extendAddToSystem(system);
         addCacheVariable<double>("term_1",
                 0.0, SimTK::Stage::Velocity);
@@ -74,7 +72,7 @@ public:
 
 
 
-    double getTotalSum(const State& s) const {
+    double getTotalSum(const SimTK::State& s) const {
         const double basalRate(1.0);
         double totalSum = basalRate;
         for (const auto& response : getComponentList<ComplexResponse>()) {
@@ -83,7 +81,7 @@ public:
         return totalSum;
     }
 
-    double getTotalTerm1(const State& s) const {
+    double getTotalTerm1(const SimTK::State& s) const {
         double totalTerm1=0;
         for (const auto& response : getComponentList<ComplexResponse>()) {
             totalTerm1 += response.getOutputValue<double>(s, "term_1");
@@ -91,7 +89,7 @@ public:
         return totalTerm1;
     }
 
-    double getTotalTerm2(const State& s) const {
+    double getTotalTerm2(const SimTK::State& s) const {
         double totalTerm2=0;
         for (const auto& response : getComponentList<ComplexResponse>()) {
             totalTerm2 += response.getOutputValue<double>(s, "term_2");
@@ -110,10 +108,10 @@ private:
     }
 };
 
-void integrate(const System& system, Integrator& integrator,
-        const State& initialState,
-        Real finalTime) {
-    TimeStepper ts(system, integrator);
+void integrate(const SimTK::System& system, SimTK::Integrator& integrator,
+        const SimTK::State& initialState,
+        SimTK::Real finalTime) {
+    SimTK::TimeStepper ts(system, integrator);
     ts.initialize(initialState);
     ts.setReportAllSignificantStates(true);
     integrator.setReturnEveryInternalStep(true); 
@@ -127,15 +125,15 @@ void testComplexResponse() {
     Model model;
     
     // Bodies and joints.
-    auto b1 = new OpenSim::Body("b1", 1, Vec3(0), Inertia(0));
-    auto b2 = new OpenSim::Body("b2", 1, Vec3(0), Inertia(0));
-    auto b3 = new OpenSim::Body("b3", 1, Vec3(0), Inertia(0));
-    auto j1 = new PinJoint("j1", model.getGround(), Vec3(0), Vec3(0),
-            *b1, Vec3(0, 1, 0), Vec3(0));
-    auto j2 = new PinJoint("j2", *b1, Vec3(0), Vec3(0),
-               *b2, Vec3(0, 1, 0), Vec3(0));
-    auto j3 = new PinJoint("j3", *b2, Vec3(0), Vec3(0),
-               *b3, Vec3(0, 1, 0), Vec3(0));
+    auto b1 = new OpenSim::Body("b1", 1, SimTK::Vec3(0), SimTK::Inertia(0));
+    auto b2 = new OpenSim::Body("b2", 1, SimTK::Vec3(0), SimTK::Inertia(0));
+    auto b3 = new OpenSim::Body("b3", 1, SimTK::Vec3(0), SimTK::Inertia(0));
+    auto j1 = new PinJoint("j1", model.getGround(), SimTK::Vec3(0), SimTK::Vec3(0),
+            *b1, SimTK::Vec3(0, 1, 0), SimTK::Vec3(0));
+    auto j2 = new PinJoint("j2", *b1, SimTK::Vec3(0), SimTK::Vec3(0),
+               *b2, SimTK::Vec3(0, 1, 0), SimTK::Vec3(0));
+    auto j3 = new PinJoint("j3", *b2, SimTK::Vec3(0), SimTK::Vec3(0),
+               *b3, SimTK::Vec3(0, 1, 0), SimTK::Vec3(0));
 
     // Aggregate calculator.
     auto aggregate = new AggregateResponse();
@@ -177,11 +175,11 @@ void testComplexResponse() {
  
     model.addComponent(reporter);
 
-    State& state = model.initSystem();
+    SimTK::State& state = model.initSystem();
 
-    model.updCoordinateSet().get("j1_coord_0").setValue(state, 0.5 * Pi);
+    model.updCoordinateSet().get("j1_coord_0").setValue(state, 0.5 * SimTK::Pi);
 
-    RungeKuttaMersonIntegrator integrator(model.getSystem());
+    SimTK::RungeKuttaMersonIntegrator integrator(model.getSystem());
     integrate(model.getSystem(), integrator, state, 1);
 }
 
@@ -189,4 +187,4 @@ int main() {
     // TODO SimTK_START_TEST("futureMuscleMetabolicsResponse");
         SimTK_SUBTEST(testComplexResponse);
     //SimTK_END_TEST();
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Sandbox/futureOutputVectorsAndChannels.cpp b/OpenSim/Sandbox/futureOutputVectorsAndChannels.cpp
index bc4514c9e..9ab0ed6ef 100644
--- a/OpenSim/Sandbox/futureOutputVectorsAndChannels.cpp
+++ b/OpenSim/Sandbox/futureOutputVectorsAndChannels.cpp
@@ -1,8 +1,6 @@
 #include <OpenSim/OpenSim.h>
 
 using namespace OpenSim;
-using namespace SimTK;
-
 class Sugar : public ModelComponent {
     OpenSim_DECLARE_CONCRETE_OBJECT(Sugar, ModelComponent);
 public:
@@ -17,7 +15,7 @@ class DataSource_ : public ModelComponent {
 public:
     OpenSim_DECLARE_LIST_OUTPUT(col, T, getColumnAtTime,
                                 SimTK::Stage::Time);
-// OpenSim_DECLARE_OUTPUT(all, Vector<T>, getRow, SimTK::Stage::Instance);
+// OpenSim_DECLARE_OUTPUT(all, SimTK::Vector<T>, getRow, SimTK::Stage::Instance);
     
     T getColumnAtTime(const SimTK::State& s, const std::string& label) const {
         return interpolate(s.getTime(), label);
@@ -81,10 +79,10 @@ private:
 
 typedef DataSource_<double> DataSource;
 
-void integrate(const System& system, Integrator& integrator,
-        const State& initialState,
-        Real finalTime) {
-    TimeStepper ts(system, integrator);
+void integrate(const SimTK::System& system, SimTK::Integrator& integrator,
+        const SimTK::State& initialState,
+        SimTK::Real finalTime) {
+    SimTK::TimeStepper ts(system, integrator);
     ts.initialize(initialState);
     ts.setReportAllSignificantStates(true);
     integrator.setReturnEveryInternalStep(true); 
@@ -146,7 +144,7 @@ void testOutputVectorsAndChannels() {
     rep->updInput("inputs").connect(src->getOutput("col"));
     rep->updInput("inputs").connect(sugar->getOutput("fructose"));
     
-    RungeKuttaMersonIntegrator integrator(model.getSystem());
+    SimTK::RungeKuttaMersonIntegrator integrator(model.getSystem());
     integrator.setFixedStepSize(0.1);
     integrate(model.getSystem(), integrator, s, 1.0);
     
@@ -156,8 +154,4 @@ int main() {
     // TODO SimTK_START_TEST("futureOutputVectorsAndChannels");
         SimTK_SUBTEST(testOutputVectorsAndChannels);
     //SimTK_END_TEST();
-}
-
-
-
-
+}
\ No newline at end of file
diff --git a/OpenSim/Sandbox/futureRigidContact.cpp b/OpenSim/Sandbox/futureRigidContact.cpp
index 2189e794d..d88e4ff6f 100644
--- a/OpenSim/Sandbox/futureRigidContact.cpp
+++ b/OpenSim/Sandbox/futureRigidContact.cpp
@@ -6,7 +6,7 @@ I like that the two are pretty much exactly the same. I wonder if it makes sense
 though to _not_ have rigid contact and compliant contact be interchangeable
 (i.e. have the same interface). One is a force element while the other is a
 constraint. For example, I don't know how RigidContactForce would implement
-`Force::calcForce()`.  Or maybe they can have the same interface but not both be
+`SimTK::Force::calcForce()`.  Or maybe they can have the same interface but not both be
 forces.
 
 Would we also have a RigidCoordinateLimitForce to go along with
@@ -87,8 +87,6 @@ redundancy and confusion.
 #define USE_RIGID_CONTACT
 
 using namespace OpenSim;
-using namespace SimTK;
-
 int main()
 {
     // Physical parameters.
@@ -110,22 +108,22 @@ int main()
     // Create model with gravity.
     auto osimModel = Model();
     osimModel.setName("BallDrop");
-    osimModel.setGravity(Vec3(0, -9.81, 0));
+    osimModel.setGravity(SimTK::Vec3(0, -9.81, 0));
 
     // Create unconstrained ball.
-    auto ball = new OpenSim::Body("ball", mass, Vec3(0),
+    auto ball = new OpenSim::Body("ball", mass, SimTK::Vec3(0),
                                   mass*SimTK::Inertia::sphere(0.1));
-    ball->scale(Vec3(radius), false);
+    ball->scale(SimTK::Vec3(radius), false);
     auto freeJoint = new FreeJoint("freeJoint", osimModel.getGround(), *ball);
     osimModel.addBody(ball);
     osimModel.addJoint(freeJoint);
 
     // Define contact geometry.
     auto ground = osimModel.updGround();
-    auto groundContact = new ContactHalfSpace(Vec3(0), Vec3(0, 0, -0.5*SimTK_PI),
+    auto groundContact = new ContactHalfSpace(SimTK::Vec3(0), SimTK::Vec3(0, 0, -0.5*SimTK_PI),
                                               ground, "groundContact");
     osimModel.addContactGeometry(groundContact);
-    auto ballContact = new ContactSphere(radius, Vec3(0), *ball, "ballContact");
+    auto ballContact = new ContactSphere(radius, SimTK::Vec3(0), *ball, "ballContact");
     osimModel.addContactGeometry(ballContact);
 
     // Define contact forces.
@@ -170,4 +168,4 @@ int main()
     // TODO: Check the results.
 
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Sandbox/futureStatesTrajectoryUsage.cpp b/OpenSim/Sandbox/futureStatesTrajectoryUsage.cpp
index 24e3902e8..e91734892 100644
--- a/OpenSim/Sandbox/futureStatesTrajectoryUsage.cpp
+++ b/OpenSim/Sandbox/futureStatesTrajectoryUsage.cpp
@@ -1,9 +1,7 @@
 #include <OpenSim/OpenSim.h>
 
 using namespace OpenSim;
-using namespace SimTK;
-
-StatesTrajectory simulate(const Model& model, const State& initState,
+StatesTrajectory simulate(const Model& model, const SimTK::State& initState,
         double finalTime) {
 
     StatesTrajectory states;
@@ -46,4 +44,4 @@ int main() {
     auto table = states.exportToTable(model);
 
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Sandbox/sandboxIKVectorOutputs.cpp b/OpenSim/Sandbox/sandboxIKVectorOutputs.cpp
index 53b0c13c2..be315c8f1 100644
--- a/OpenSim/Sandbox/sandboxIKVectorOutputs.cpp
+++ b/OpenSim/Sandbox/sandboxIKVectorOutputs.cpp
@@ -3,8 +3,6 @@
 #include <OpenSim/OpenSim.h>
 
 using namespace OpenSim;
-using namespace SimTK;
-
 // This example attempts to describe the use-case for vector outputs:
 // outputs that are of type SimTK::Vector_<T> and contain a label for each
 // element of the vector. Tools that return a vector of calculations are
@@ -22,20 +20,20 @@ class JointCenter : public ModelComponent {
 public:
     // TODO to a list input, vector and list outputs look the same.
     // TODO so make these into list inputs again.
-    OpenSim_DECLARE_LIST_INPUT(seg1_markers, Vec3, SimTK::Stage::Time,
+    OpenSim_DECLARE_LIST_INPUT(seg1_markers, SimTK::Vec3, SimTK::Stage::Time,
         "Markers on segment 1.");
-    OpenSim_DECLARE_LIST_INPUT(seg2_markers, Vec3, SimTK::Stage::Time,
+    OpenSim_DECLARE_LIST_INPUT(seg2_markers, SimTK::Vec3, SimTK::Stage::Time,
         "Markers on segment 2.");
     // TODOv
-    //OpenSim_DECLARE_VECTOR_INPUT(seg1_markers, Vec3, SimTK::Stage::Time,
+    //OpenSim_DECLARE_VECTOR_INPUT(seg1_markers, SimTK::Vec3, SimTK::Stage::Time,
     //    "Markers on segment 1.");
-    //OpenSim_DECLARE_VECTOR_INPUT(seg2_markers, Vec3, SimTK::Stage::Time,
+    //OpenSim_DECLARE_VECTOR_INPUT(seg2_markers, SimTK::Vec3, SimTK::Stage::Time,
     //    "Markers on segment 2.");
-    OpenSim_DECLARE_OUTPUT(joint_center, Vec3, getJointCenter,
+    OpenSim_DECLARE_OUTPUT(joint_center, SimTK::Vec3, getJointCenter,
                            SimTK::Stage::Time);
-    Vec3 getJointCenter(const SimTK::State& s) const {
-        const auto& seg1 = getInput<Vec3>("seg1_markers").getVector(s);
-        const auto& seg2 = getInput<Vec3>("seg2_markers").getVector(s);
+    SimTK::Vec3 getJointCenter(const SimTK::State& s) const {
+        const auto& seg1 = getInput<SimTK::Vec3>("seg1_markers").getVector(s);
+        const auto& seg2 = getInput<SimTK::Vec3>("seg2_markers").getVector(s);
         
         // I'm just doing an arbitrary calculation with both vectors.
         return 0.5 * (seg1.sum() + seg2.sum());
@@ -49,7 +47,7 @@ class DataSource_ : public ModelComponent {
 public:
     OpenSim_DECLARE_LIST_OUTPUT(col, T, getColumnAtTime,
                                 SimTK::Stage::Time);
-    OpenSim_DECLARE_LIST_OUTPUT(all, Vector_<T>, getAllColumnsAtTime,
+    OpenSim_DECLARE_LIST_OUTPUT(all, SimTK::Vector_<T>, getAllColumnsAtTime,
                                 SimTK::Stage::Time);
     // TODOv
     //OpenSim_DECLARE_VECTOR_OUTPUT(all, T, getAllColumnsAtTime,
@@ -94,7 +92,7 @@ public:
         // This means that requested time is an exact match.
         if (iabove == -1) {
             // TODO this is all probably very inefficient, but I had trouble
-            // converting a RowVector_<T> to a Vector_<T>.
+            // converting a SimTK::RowVector_<T> to a SimTK::Vector_<T>.
             SimTK::Vector_<T> transposed(rowBelow.size());
             for (int i = 0; i < rowBelow.size(); ++i) transposed[i] = rowBelow[i];
             return transposed;
@@ -107,7 +105,7 @@ public:
         const auto& result = rowBelow + fraction * delta;
         
         // TODO this is all probably very inefficient, but I had trouble
-        // converting a RowVector_<T> to a Vector_<T>.
+        // converting a SimTK::RowVector_<T> to a SimTK::Vector_<T>.
         SimTK::Vector_<T> transposed(result.size());
         // TODO transposed.copyAssign(result.transpose());
         for (int i = 0; i < result.size(); ++i) transposed[i] = result[i];
@@ -171,7 +169,7 @@ typedef DataSource_<SimTK::Vec3> DataSourceVec3;
 
 // TODO InverseKinematics shouldn't really produce a coordinates output;
 // it's more of a states solver--it should be editing the coordinate values
-// in the State. So, this example is really mostly for demonstration.
+// in the SimTK::State. So, this example is really mostly for demonstration.
 // TODO It actually would work really well as a task space controller.
 class InverseKinematics : public ModelComponent {
     OpenSim_DECLARE_CONCRETE_OBJECT(InverseKinematics, ModelComponent);
@@ -179,21 +177,21 @@ public:
     // TODO socket to a model.
     
     // TODO convert these to vectors.
-    OpenSim_DECLARE_VECTOR_OUTPUT(model_marker_pos, Vec3, getModelMarkerPositions,
+    OpenSim_DECLARE_VECTOR_OUTPUT(model_marker_pos, SimTK::Vec3, getModelMarkerPositions,
         SimTK::Stage::Position);
     OpenSim_DECLARE_VECTOR_OUTPUT(coords, double, getSolution,
         SimTK::Stage::Position);
-    OpenSim_DECLARE_VECTOR_INPUT(targets, Vec3, SimTK::Stage::Position,
+    OpenSim_DECLARE_VECTOR_INPUT(targets, SimTK::Vec3, SimTK::Stage::Position,
         "The target (experimental) marker positions. Input annotations must "
         "be the name of the model marker to pair with each target.");
     // TODO OpenSim_DECLARE_LIST_INPUT(marker_weights, double, SimTK::Stage::Position,
     // TODO     "Weights for each marker specified in targets.");
     
-    SimTK::Vector_<Vec3> getModelMarkerPositions(const SimTK::State& s) const {
+    SimTK::Vector_<SimTK::Vec3> getModelMarkerPositions(const SimTK::State& s) const {
         solve(s); // TODO cache the result in some way.
         const auto& markerSet = getModel().getMarkerSet();
         const auto& ground = getModel().getGround();
-        SimTK::Vector_<Vec3> v(markerset.getSize());
+        SimTK::Vector_<SimTK::Vec3> v(markerset.getSize());
         for (int imark = 0; imark < markerSet.getSize(); ++imark) {
             v[imark] = markerSet()[imark].findLocationInFrame(s, ground);
         }
@@ -231,7 +229,7 @@ public:
     
     void solve(const SimTK::State& s) const {
         // These target markers could have come from mixed sources.
-        const auto& targets = getInput<Vec3>("targets").getVector(s);
+        const auto& targets = getInput<SimTK::Vec3>("targets").getVector(s);
         // To pretend like we're doing something useful, we'll multiply by
         // the station jacobian transpose.
         // TODO
@@ -251,7 +249,7 @@ public:
         // that work.
         const_cast<Self*>(this)->_onBodyB.clear();
         const_cast<Self*>(this)->_stationPinB.clear();
-        const auto& input = getInput<Vec3>("targets");
+        const auto& input = getInput<SimTK::Vec3>("targets");
         for (int ichan = 0; ichan < input.getNumConnectees(); ++ichan) {
             const auto& markerName = input.getAnnotation(ichan);
             const auto& marker = getModel().getMarkerSet().get(markerName);
@@ -289,7 +287,7 @@ public:
     OpenSim_DECLARE_PROPERTY(enabled, bool, "Should this report results?");
     OpenSim_DECLARE_LIST_INPUT(input, T, SimTK::Stage::Acceleration, "");
 private:
-    void extendRealizeReport(const State& state) const override {
+    void extendRealizeReport(const SimTK::State& state) const override {
         if (!get_enabled()) return;
         const auto& input = getInput<T>("input");
         
@@ -324,13 +322,13 @@ private:
 };
 
 typedef ConsoleReporter_<double> ConsoleReporter;
-typedef ConsoleReporter_<Vec3> ConsoleReporterVec3;
-typedef ConsoleReporter_<Vector_<Vec3>> ConsoleReporterVectorVec3;
+typedef ConsoleReporter_<SimTK::Vec3> ConsoleReporterVec3;
+typedef ConsoleReporter_<SimTK::Vector_<SimTK::Vec3>> ConsoleReporterVectorVec3;
 
-void integrate(const System& system, Integrator& integrator,
-        const State& initialState,
-        Real finalTime) {
-    TimeStepper ts(system, integrator);
+void integrate(const SimTK::System& system, SimTK::Integrator& integrator,
+        const SimTK::State& initialState,
+        SimTK::Real finalTime) {
+    SimTK::TimeStepper ts(system, integrator);
     ts.initialize(initialState);
     ts.setReportAllSignificantStates(true);
     integrator.setReturnEveryInternalStep(true); 
@@ -341,17 +339,17 @@ void integrate(const System& system, Integrator& integrator,
 }
 
 void createModel(Model& model) {
-    auto* pelvis = new OpenSim::Body("pelvis", 1.0, Vec3(0), Inertia(1));
+    auto* pelvis = new OpenSim::Body("pelvis", 1.0, SimTK::Vec3(0), SimTK::Inertia(1));
     model.addBody(pelvis);
-    auto* femur = new OpenSim::Body("femur", 1.0, Vec3(0), Inertia(1));
+    auto* femur = new OpenSim::Body("femur", 1.0, SimTK::Vec3(0), SimTK::Inertia(1));
     model.addBody(femur);
     auto* hog = new PinJoint("hog",
-                             model.getGround(), Vec3(0), Vec3(0),
-                             *pelvis,           Vec3(0, 1, 0), Vec3(0));
+                             model.getGround(), SimTK::Vec3(0), SimTK::Vec3(0),
+                             *pelvis,           SimTK::Vec3(0, 1, 0), SimTK::Vec3(0));
     model.addJoint(hog);
     auto* hip = new PinJoint("hip",
-                             *pelvis, Vec3(0), Vec3(0),
-                             *femur,  Vec3(0, 1, 0), Vec3(0));
+                             *pelvis, SimTK::Vec3(0), SimTK::Vec3(0),
+                             *femur,  SimTK::Vec3(0, 1, 0), SimTK::Vec3(0));
     model.addJoint(hip);
     hog->getCoordinateSet().get(0).setDefaultValue(0.5 * SimTK::Pi);
     
@@ -380,17 +378,17 @@ void createModel(Model& model) {
     model.addMarker(hjc);
 }
 
-void fabricateExperimentalMarkers(TimeSeriesTable_<Vec3>& table) {
+void fabricateExperimentalMarkers(TimeSeriesTable_<SimTK::Vec3>& table) {
     table.setColumnLabels({"asis", "psis", "med_knee", "lat_knee", "thigh"});
     
-    TimeSeriesTable_<Vec3>::RowVector row(5, Vec3(0.0));
-    row[1] = Vec3(0, 0, 0); row[2] = Vec3(1, 0, 0); row[3] = Vec3(2, 0, 0);
-    row[4] = Vec3(3, 0, 0);
-    table.appendRow(0.0, row); row += Vec3(0, 1, 0);
-    table.appendRow(0.25, row); row += Vec3(1, 0, 0);
-    table.appendRow(0.50, row); row += Vec3(0, 0, 1);
-    table.appendRow(0.75, row); row += Vec3(2, 0, 0);
-    table.appendRow(1.0, row); row += Vec3(0, 3, 0);
+    TimeSeriesTable_<SimTK::Vec3>::RowVector row(5, SimTK::Vec3(0.0));
+    row[1] = SimTK::Vec3(0, 0, 0); row[2] = SimTK::Vec3(1, 0, 0); row[3] = SimTK::Vec3(2, 0, 0);
+    row[4] = SimTK::Vec3(3, 0, 0);
+    table.appendRow(0.0, row); row += SimTK::Vec3(0, 1, 0);
+    table.appendRow(0.25, row); row += SimTK::Vec3(1, 0, 0);
+    table.appendRow(0.50, row); row += SimTK::Vec3(0, 0, 1);
+    table.appendRow(0.75, row); row += SimTK::Vec3(2, 0, 0);
+    table.appendRow(1.0, row); row += SimTK::Vec3(0, 3, 0);
     table.appendRow(1.1, row);
 }
 
@@ -480,7 +478,7 @@ void testFutureIKVectorOutputs() {
     expRep->updInput("input").connect(exp->getOutput("col").getChannel("psis"));
     // Must annotate this output since we need a way to figure out which marker
     // it corresponds to. The InverseKinematics component uses annotations to
-    // pair target Vec3's with model markers.
+    // pair target SimTK::Vec3's with model markers.
     expRep->updInput("input").connect(hjc->getOutput("joint_center"));
     vecRep->updInput("input").connect(exp->getOutput("all"));
     
@@ -488,7 +486,7 @@ void testFutureIKVectorOutputs() {
     solution->updInput("input").connect(ik->getOutput("coords"));
     
     // TODO replace with a driver / time step advancer.
-    RungeKuttaMersonIntegrator integrator(model.getSystem());
+    SimTK::RungeKuttaMersonIntegrator integrator(model.getSystem());
     integrator.setFixedStepSize(0.1);
     integrate(model.getSystem(), integrator, s, 1.0);
     
@@ -498,6 +496,4 @@ int main() {
     SimTK_START_TEST("futureIKVectorOutputs");
         SimTK_SUBTEST(testFutureIKVectorOutputs);
     SimTK_END_TEST();
-}
-
-
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/CoordinateReference.cpp b/OpenSim/Simulation/CoordinateReference.cpp
index 8ab01d6c4..736351d68 100644
--- a/OpenSim/Simulation/CoordinateReference.cpp
+++ b/OpenSim/Simulation/CoordinateReference.cpp
@@ -24,8 +24,6 @@
 #include "CoordinateReference.h"
 
 using namespace std;
-using namespace SimTK;
-
 namespace OpenSim {
 
 CoordinateReference::CoordinateReference()
@@ -149,4 +147,4 @@ void CoordinateReference::setValueFunction(const OpenSim::Function& function)
     _coordinateValueFunction = function.clone();
 }
 
-} // end of namespace OpenSim
+} // end of namespace OpenSim
\ No newline at end of file
diff --git a/OpenSim/Simulation/MarkersReference.cpp b/OpenSim/Simulation/MarkersReference.cpp
index de5c01b20..46c3f626c 100644
--- a/OpenSim/Simulation/MarkersReference.cpp
+++ b/OpenSim/Simulation/MarkersReference.cpp
@@ -27,8 +27,6 @@
 #include <cmath>
 
 using namespace std;
-using namespace SimTK;
-
 namespace OpenSim {
 
 MarkersReference::MarkersReference() : Reference_<SimTK::Vec3>() {
@@ -156,7 +154,7 @@ const SimTK::Array_<std::string>& MarkersReference::getNames() const {
 }
 
 void MarkersReference::getValuesAtTime(double time,
-                                  SimTK::Array_<Vec3>& values) const {
+                                  SimTK::Array_<SimTK::Vec3>& values) const {
     const auto rowView = _markerTable.getNearestRow(time);
     values.clear();
     for(int i = 0; i < rowView.ncol(); ++i)
@@ -165,13 +163,13 @@ void MarkersReference::getValuesAtTime(double time,
 
 // void
 // MarkersReference::getSpeedValues(const SimTK::State &s,
-//                                  SimTK::Array_<Vec3> &speedValues) const {
+//                                  SimTK::Array_<SimTK::Vec3> &speedValues) const {
 //     throw Exception("MarkersReference: getSpeedValues not implemented.");
 // }
 // 
 // void
 // MarkersReference::getAccelerationValues(const SimTK::State &s,
-//                                         SimTK::Array_<Vec3> &accValues) const {
+//                                         SimTK::Array_<SimTK::Vec3> &accValues) const {
 //     throw Exception("MarkersReference: getAccelerationValues not implemented.");
 // }
 
@@ -239,4 +237,4 @@ MarkersReference::getNumFrames() const {
     return _markerTable.getNumRows();
 }
 
-} // end of namespace OpenSim
+} // end of namespace OpenSim
\ No newline at end of file
diff --git a/OpenSim/Simulation/Model/Actuator.cpp b/OpenSim/Simulation/Model/Actuator.cpp
index b228b8e62..22b5ecb76 100644
--- a/OpenSim/Simulation/Model/Actuator.cpp
+++ b/OpenSim/Simulation/Model/Actuator.cpp
@@ -31,8 +31,6 @@
 
 using namespace std;
 using namespace OpenSim;
-using namespace SimTK;
-
 // here for perf reasons: many functions take a const reference to a
 // std::string. Using a C string literal results in millions of temporary
 // std::strings being constructed so, instead, pre-allocate it in static
@@ -78,10 +76,10 @@ void Actuator::extendAddToSystem(SimTK::MultibodySystem& system) const
     // Model is in charge of creating the shared cache for all actuator controls
     // but it does so based on the size and order in its _defaultControls
     // Actuator has the opportunity here to add slots for its control and record
-    // the index into the shared cache Vector.
+    // the index into the shared cache SimTK::Vector.
     mutableThis->_controlIndex = _model->updDefaultControls().size();
     _model->updDefaultControls().resizeKeep(_controlIndex + numControls());
-    _model->updDefaultControls()(_controlIndex, numControls()) = Vector(numControls(), 0.0);
+    _model->updDefaultControls()(_controlIndex, numControls()) = SimTK::Vector(numControls(), 0.0);
 }
 
 // CONTROLS
@@ -92,13 +90,13 @@ void Actuator::extendAddToSystem(SimTK::MultibodySystem& system) const
  * @param the current state
  * @return The value of the controls.
  */
-const VectorView_<Real> Actuator::getControls( const SimTK::State& s ) const
+const SimTK::VectorView_<SimTK::Real> Actuator::getControls( const SimTK::State& s ) const
 {
-    const Vector &controlsCache = _model->getControls(s);
+    const SimTK::Vector &controlsCache = _model->getControls(s);
     return  controlsCache(_controlIndex, numControls());
 }
 
-void Actuator::getControls(const Vector& modelControls, Vector& actuatorControls) const
+void Actuator::getControls(const SimTK::Vector& modelControls, SimTK::Vector& actuatorControls) const
 {
     SimTK_ASSERT(modelControls.size() == _model->getNumControls(), 
         "Actuator::getControls, input modelControls size does not match model.getNumControls().\n");
@@ -107,7 +105,7 @@ void Actuator::getControls(const Vector& modelControls, Vector& actuatorControls
     actuatorControls = modelControls(_controlIndex, numControls());
 }
 
-void Actuator::setControls(const Vector& actuatorControls, Vector& modelControls) const
+void Actuator::setControls(const SimTK::Vector& actuatorControls, SimTK::Vector& modelControls) const
 {
     SimTK_ASSERT(actuatorControls.size() == numControls(), 
         "Actuator::setControls, input actuatorControls incompatible with actuator's numControls().\n");
@@ -118,7 +116,7 @@ void Actuator::setControls(const Vector& actuatorControls, Vector& modelControls
     modelControls(_controlIndex, numControls()) = actuatorControls;
 }
 
-void Actuator::addInControls(const Vector& actuatorControls, Vector& modelControls) const
+void Actuator::addInControls(const SimTK::Vector& actuatorControls, SimTK::Vector& modelControls) const
 {
     SimTK_ASSERT(actuatorControls.size() == numControls(), 
         "Actuator::addInControls, input actuatorControls incompatible with actuator's numControls()\n");
@@ -149,8 +147,8 @@ ScalarActuator::ScalarActuator()
  */
 void ScalarActuator::constructProperties()
 {
-    constructProperty_min_control(-Infinity);
-    constructProperty_max_control( Infinity);
+    constructProperty_min_control(-SimTK::Infinity);
+    constructProperty_max_control( SimTK::Infinity);
 }
 
 void ScalarActuator::setMinControl(const double& aMinControl)
@@ -183,10 +181,10 @@ void ScalarActuator::extendAddToSystem(SimTK::MultibodySystem& system) const
     addModelingOption(overrideActuationKey, 1);
 
     // Cache the computed actuation of the scalar valued actuator
-    _actuationCV = addCacheVariable("actuation", 0.0, Stage::Velocity);
+    _actuationCV = addCacheVariable("actuation", 0.0, SimTK::Stage::Velocity);
 
     // Discrete state variable is the override actuation value if in override mode
-    addDiscreteVariable(overrideActuationKey, Stage::Time);
+    addDiscreteVariable(overrideActuationKey, SimTK::Stage::Time);
 }
 
 double ScalarActuator::getControl(const SimTK::State& s) const
@@ -204,7 +202,7 @@ double ScalarActuator::getOptimalForce() const
     OPENSIM_ERROR_IF_NOT_OVERRIDDEN();
 }
 
-double ScalarActuator::getActuation(const State &s) const
+double ScalarActuator::getActuation(const SimTK::State &s) const
 {
     if (appliesForce(s)) {
         return getCacheVariableValue(s, _actuationCV);
@@ -213,7 +211,7 @@ double ScalarActuator::getActuation(const State &s) const
     }
 }
 
-void ScalarActuator::setActuation(const State& s, double aActuation) const
+void ScalarActuator::setActuation(const SimTK::State& s, double aActuation) const
 {
     setCacheVariableValue(s, _actuationCV, aActuation);
 }
@@ -242,4 +240,4 @@ double ScalarActuator::computeOverrideActuation(const SimTK::State& s) const
     double appliedActuation = getOverrideActuation(s);
     setActuation(s, appliedActuation);
     return appliedActuation;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/Model/ExponentialContactForce.cpp b/OpenSim/Simulation/Model/ExponentialContactForce.cpp
deleted file mode 100644
index fb1252366..000000000
--- a/OpenSim/Simulation/Model/ExponentialContactForce.cpp
+++ /dev/null
@@ -1,568 +0,0 @@
-/* -------------------------------------------------------------------------- *
- *                   OpenSim:  ExponentialContactForce.cpp                    *
- * -------------------------------------------------------------------------- *
- * The OpenSim API is a toolkit for musculoskeletal modeling and simulation.  *
- * See http://opensim.stanford.edu and the NOTICE file for more information.  *
- * OpenSim is developed at Stanford University and supported by the US        *
- * National Institutes of Health (U54 GM072970, R24 HD065690) and by DARPA    *
- * through the Warrior Web program.                                           *
- *                                                                            *
- * Copyright (c) 2024-2025 Stanford University and the Authors                *
- * Author(s):  F. C. Anderson                                                 *
- * Contributor(s): Nicholas Bianco                                            *
- *                                                                            *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may    *
- * not use this file except in compliance with the License. You may obtain a  *
- * copy of the License at http://www.apache.org/licenses/LICENSE-2.0.         *
- *                                                                            *
- * Unless required by applicable law or agreed to in writing, software        *
- * distributed under the License is distributed on an "AS IS" BASIS,          *
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *
- * See the License for the specific language governing permissions and        *
- * limitations under the License.                                             *
- * -------------------------------------------------------------------------- */
-
-#include "Model.h"
-#include "simbody/internal/SimbodyMatterSubsystem.h"
-#include "ExponentialContactForce.h"
-
-using namespace OpenSim;
-using namespace std;
-using SimTK::Real;
-using SimTK::Vec3;
-using SimTK::State;
-
-
-//=============================================================================
-// ExponentialContactForce::Parameters
-//=============================================================================
-ExponentialContactForce::Parameters::
-Parameters() {
-    setNull();
-    constructProperties();
-}
-
-ExponentialContactForce::Parameters::
-Parameters(const SimTK::ExponentialSpringParameters& params) {
-    setNull();
-    _stkparams = params;
-    constructProperties();
-}
-
-void ExponentialContactForce::Parameters::setNull() {
-    setAuthors("F. C. Anderson");
-}
-
-void
-ExponentialContactForce::Parameters::
-constructProperties() {
-    SimTK::Vec3 shape;
-    _stkparams.getShapeParameters(shape[0], shape[1], shape[2]);
-    constructProperty_exponential_shape_parameters(shape);
-    constructProperty_normal_viscosity(_stkparams.getNormalViscosity());
-    constructProperty_max_normal_force(_stkparams.getMaxNormalForce());
-    constructProperty_friction_elasticity(_stkparams.getFrictionElasticity());
-    constructProperty_friction_viscosity(_stkparams.getFrictionViscosity());
-    constructProperty_settle_velocity(_stkparams.getSettleVelocity());
-    constructProperty_initial_mu_static(_stkparams.getInitialMuStatic());
-    constructProperty_initial_mu_kinetic(_stkparams.getInitialMuKinetic());
-}
-
-void
-ExponentialContactForce::Parameters::
-updateProperties() {
-    SimTK::Vec3 shape;
-    _stkparams.getShapeParameters(shape[0], shape[1], shape[2]);
-    set_exponential_shape_parameters(shape);
-    set_normal_viscosity(_stkparams.getNormalViscosity());
-    set_max_normal_force(_stkparams.getMaxNormalForce());
-    set_friction_elasticity(_stkparams.getFrictionElasticity());
-    set_friction_viscosity(_stkparams.getFrictionViscosity());
-    set_settle_velocity(_stkparams.getSettleVelocity());
-    set_initial_mu_static(_stkparams.getInitialMuStatic());
-    set_initial_mu_kinetic(_stkparams.getInitialMuKinetic());
-}
-
-void
-ExponentialContactForce::Parameters::
-updateParameters() {
-    const SimTK::Vec3 shape = get_exponential_shape_parameters();
-    _stkparams.setShapeParameters(shape[0], shape[1], shape[2]);
-    _stkparams.setNormalViscosity(get_normal_viscosity());
-    _stkparams.setMaxNormalForce(get_max_normal_force());
-    _stkparams.setFrictionElasticity(get_friction_elasticity());
-    _stkparams.setFrictionViscosity(get_friction_viscosity());
-    _stkparams.setSettleVelocity(get_settle_velocity());
-    _stkparams.setInitialMuStatic(get_initial_mu_static());
-    _stkparams.setInitialMuKinetic(get_initial_mu_kinetic());
-}
-
-// This method is needed to ensure that the SimTK::ExponentialSpringParameters
-// member variable (_stkparam) is kept consistent with the properties.
-// It is necessary to have the _stkparams member variable because there needs
-// to be a place to store non-default parameters when the underlying
-// SimTK::ExponentialSpringForce hasn't yet been instantiated.
-// Having to do a little extra bookkeeping (i.e., storing properties values
-// twice [once in the Properties and once in _stkparams]) is justified
-// by not having to rewrite a whole bunch of additional accessor methods.
-// All parameter sets/gets go through the SimTK::ExponentialSpringParameters
-// interface (i.e., through _stkparams).
-void
-ExponentialContactForce::Parameters::
-updateFromXMLNode(SimTK::Xml::Element& node, int versionNumber) {
-    Super::updateFromXMLNode(node, versionNumber);
-    updateParameters(); // catching any invalid property values in the process
-    updateProperties(); // pushes valid parameters back to the properties.
-}
-
-void
-ExponentialContactForce::Parameters::
-setSimTKParameters(const SimTK::ExponentialSpringParameters& params) {
-    _stkparams = params;
-    updateProperties();
-}
-
-const SimTK::ExponentialSpringParameters&
-ExponentialContactForce::Parameters::
-getSimTKParameters() const {
-    return _stkparams;
-}
-
-
-//=============================================================================
-// ExponentialContactForce
-//=============================================================================
-// Default
-ExponentialContactForce::
-ExponentialContactForce() {
-    setNull();
-    constructProperties();
-}
-
-// Full Argument
-ExponentialContactForce::
-ExponentialContactForce(const SimTK::Transform& contactPlaneXform,
-    const PhysicalFrame& frame, const SimTK::Vec3& location,
-    SimTK::ExponentialSpringParameters params)
-{
-    setNull();
-    constructProperties();
-    set_contact_plane_transform(contactPlaneXform);
-
-    // Create a Station object and set the station property.
-    set_station(Station());
-    upd_station().setParentFrame(frame);
-    upd_station().set_location(location);
-
-    setParameters(params);
-}
-
-void
-ExponentialContactForce::
-setNull() {
-    setAuthors("F. C. Anderson");
-}
-
-const SimTK::ExponentialSpringForce&
-ExponentialContactForce::
-getExponentialSpringForce() const {
-    SimTK_ASSERT(_index.isValid(), "Invalid Force index.");
-    const auto& forceSubsys = getModel().getForceSubsystem();
-    const SimTK::Force& abstractForce = forceSubsys.getForce(_index);
-    return static_cast<const SimTK::ExponentialSpringForce&>(abstractForce);
-}
-
-SimTK::ExponentialSpringForce&
-ExponentialContactForce::
-updExponentialSpringForce() {
-    SimTK_ASSERT(_index.isValid(), "Invalid Force index.");
-    auto& forceSubsys = updModel().updForceSubsystem();
-    SimTK::Force& abstractForce = forceSubsys.updForce(_index);
-    return static_cast<SimTK::ExponentialSpringForce&>(abstractForce);
-}
-
-void
-ExponentialContactForce::
-constructProperties() {
-    constructProperty_contact_plane_transform(SimTK::Transform());
-    constructProperty_contact_parameters(Parameters());
-    constructProperty_station(Station());
-}
-
-void
-ExponentialContactForce::
-updateFromXMLNode(SimTK::Xml::Element& node, int versionNumber) {
-    Super::updateFromXMLNode(node, versionNumber);
-}
-
-void
-ExponentialContactForce::
-extendConnectToModel(OpenSim::Model& model) {
-    // Allow base class to connect first
-    Super::extendConnectToModel(model);
-
-    // The station should not be connected to Ground.
-    const PhysicalFrame& frame = get_station().getParentFrame();
-    OPENSIM_THROW_IF(&frame == &model.getGround(), Exception,
-        "The station must be connected to a PhysicalFrame that is not Ground.")
-}
-
-// This method is where the actual underlying contact force subsystem
-// (i.e., SimTK::ExponentialSpringForce) is constructed and added to the
-// OpenSim::Model (wrapped by OpenSim::ExponentialContactForce).
-void
-ExponentialContactForce::
-extendAddToSystem(SimTK::MultibodySystem& system) const {
-    // Extend the OpenSim::Force parent
-    Super::extendAddToSystem(system);
-
-    // Construct the SimTK::ExponentialSpringForce object
-    SimTK::GeneralForceSubsystem& forces = _model->updForceSubsystem();
-    const SimTK::Transform& XContactPlane = get_contact_plane_transform();
-    const PhysicalFrame& frame = get_station().getParentFrame();
-    const Vec3& location = get_station().get_location();
-    SimTK::ExponentialSpringForce spr(forces, XContactPlane,
-            frame.getMobilizedBody(), location, getParameters());
-
-    // Get the subsystem index so we can access the SimTK::Force later.
-    ExponentialContactForce* mutableThis =
-        const_cast<ExponentialContactForce*>(this);
-    mutableThis->_index = spr.getForceIndex();
-
-    // Expose the discrete states of ExponentialSpringForce in OpenSim
-    bool allocate = false;
-    std::string name = getMuStaticDiscreteStateName();
-    addDiscreteVariable(name, SimTK::Stage::Dynamics, allocate);
-    name = getMuKineticDiscreteStateName();
-    addDiscreteVariable(name, SimTK::Stage::Dynamics, allocate);
-    name = getSlidingDiscreteStateName();
-    addDiscreteVariable(name, SimTK::Stage::Dynamics, allocate);
-    name = getAnchorPointDiscreteStateName();
-    addDiscreteVariable(name, SimTK::Stage::Dynamics, allocate);
-}
-
-// This method is needed because class OpenSim::ExponentialContactForce has 4
-// discrete states that are allocated in
-// SimTK::ExponentialSpringForce::realizeTopology(), not in
-// OpenSim::Component::extendRealizeTopology().
-// These states are added to the OpenSim map of discrete states
-// (i.e., Component::_namedDiscreteVariableInfo) so that they are accessible
-// in OpenSim. See ExponentialContactForce::extendAddToSystem(). However,
-// because these discrete states are not allocated by OpenSim::Component,
-// OpenSim has no knowledge of their indices into the SimTK::State. The purpose
-// of this method is to properly initialize those indices.
-void
-ExponentialContactForce::
-extendRealizeTopology(SimTK::State& state) const {
-
-    Super::extendRealizeTopology(state);
-
-    // A critical question...
-    // Can we guarrantee that ExponentialSpringForce::realizeTopology() will
-    // always be called before this method !?!?
-    //
-    // Maybe. Perhaps the ExponentialSpringForce object will always
-    // be listed in the SimTK::System before the ExponentialContactForce
-    // component? If not, then it is possible that getMuStaticStateIndex()
-    // will return a bad index.
-    //
-    // Or, perhaps the call above to Super::extendRealizeTopology(state)
-    // ensures that the SimTK::ExponentialSpringForce::realizeTopology()
-    // has been called before this method is executed.
-    //
-    // What I can confirm is that, so far, the indices in multiple tests have
-    // been assigned correctly.
-    //
-    // If there are mysterious failures because of a bad State index, the
-    // source of the issue may be that ExponentialSpringForce::realizeTopology
-    // was not called prior to ExponentialContactForce::extendRealizeTopology.
-
-    const SimTK::Subsystem* subsys = getSubsystem();
-    const SimTK::SubsystemIndex ssIndex = subsys->getMySubsystemIndex();
-    subsys->getMySubsystemIndex();
-    SimTK::DiscreteVariableIndex dvIndex;
-    std::string name;
-
-    name = getMuStaticDiscreteStateName();
-    dvIndex = getExponentialSpringForce().getMuStaticStateIndex();
-    initializeDiscreteVariableIndexes(name, ssIndex, dvIndex);
-
-    name = getMuKineticDiscreteStateName();
-    dvIndex = getExponentialSpringForce().getMuKineticStateIndex();
-    initializeDiscreteVariableIndexes(name, ssIndex, dvIndex);
-
-    name = getSlidingDiscreteStateName();
-    dvIndex = getExponentialSpringForce().getSlidingStateIndex();
-    initializeDiscreteVariableIndexes(name, ssIndex, dvIndex);
-
-    name = getAnchorPointDiscreteStateName();
-    dvIndex = getExponentialSpringForce().getAnchorPointStateIndex();
-    initializeDiscreteVariableIndexes(name, ssIndex, dvIndex);
-}
-
-//-----------------------------------------------------------------------------
-// Utility
-//-----------------------------------------------------------------------------
-void
-ExponentialContactForce::
-resetAnchorPoint(SimTK::State& state) const {
-    getExponentialSpringForce().resetAnchorPoint(state);
-}
-
-void
-ExponentialContactForce::
-resetAnchorPoints(OpenSim::Model& model, SimTK::State& state) {
-    for (auto& ec : model.updComponentList<ExponentialContactForce>()) {
-        ec.resetAnchorPoint(state);
-    }
-}
-
-//-----------------------------------------------------------------------------
-// ACCESSORS for properties
-//-----------------------------------------------------------------------------
-void
-ExponentialContactForce::
-setParameters(const SimTK::ExponentialSpringParameters& params) {
-    ExponentialContactForce::Parameters& p = upd_contact_parameters();
-    p.setSimTKParameters(params);
-    // Push the new parameters to the SimTK::ExponentialSpringForce instance.
-    // The following call will invalidate the System at Stage::Topology.
-    if (_index.isValid()) updExponentialSpringForce().setParameters(params);
-}
-
-const SimTK::ExponentialSpringParameters&
-ExponentialContactForce::
-getParameters() const {
-    return get_contact_parameters().getSimTKParameters();
-}
-
-const Station&
-ExponentialContactForce::
-getStation() const {
-    return get_station();
-}
-
-//-----------------------------------------------------------------------------
-// ACCESSORS for states
-//-----------------------------------------------------------------------------
-void
-ExponentialContactForce::
-setMuStatic(SimTK::State& state, SimTK::Real mus) {
-   updExponentialSpringForce().setMuStatic(state, mus);
-}
-
-SimTK::Real
-ExponentialContactForce::
-getMuStatic(const SimTK::State& state) const {
-    return getExponentialSpringForce().getMuStatic(state);
-}
-
-void
-ExponentialContactForce::
-setMuKinetic(SimTK::State& state, SimTK::Real muk) {
-    updExponentialSpringForce().setMuKinetic(state, muk);
-}
-
-SimTK::Real
-ExponentialContactForce::
-getMuKinetic(const SimTK::State& state) const {
-    return getExponentialSpringForce().getMuKinetic(state);
-}
-
-SimTK::Real
-ExponentialContactForce::
-getSliding(const SimTK::State& state) const {
-    return getExponentialSpringForce().getSliding(state);
-}
-
-//-----------------------------------------------------------------------------
-// ACCESSORS for data cache entries
-//-----------------------------------------------------------------------------
-Vec3
-ExponentialContactForce::
-getNormalForceElasticPart(const State& state, bool inGround) const {
-    return
-        getExponentialSpringForce().getNormalForceElasticPart(state, inGround);
-}
-
-Vec3
-ExponentialContactForce::
-getNormalForceDampingPart(const State& state, bool inGround) const {
-    return
-        getExponentialSpringForce().getNormalForceDampingPart(state, inGround);
-}
-
-Vec3
-ExponentialContactForce::
-getNormalForce(const State& state, bool inGround) const {
-    return getExponentialSpringForce().getNormalForce(state, inGround);
-}
-
-Real
-ExponentialContactForce::
-getMu(const State& state) const {
-    return getExponentialSpringForce().getMu(state);
-}
-
-Real
-ExponentialContactForce::
-getFrictionForceLimit(const SimTK::State& state) const {
-    return getExponentialSpringForce().
-                getFrictionForceLimit(state);
-}
-
-Vec3
-ExponentialContactForce::
-getFrictionForceElasticPart(const State& state, bool inGround) const {
-    return getExponentialSpringForce().
-                getFrictionForceElasticPart(state, inGround);
-}
-
-Vec3
-ExponentialContactForce::
-getFrictionForceDampingPart(const State& state, bool inGround) const {
-    return getExponentialSpringForce().
-                getFrictionForceDampingPart(state, inGround);
-}
-
-Vec3
-ExponentialContactForce::
-getFrictionForce(const State& state, bool inGround) const {
-    return getExponentialSpringForce().getFrictionForce(state, inGround);
-}
-
-Vec3
-ExponentialContactForce::
-getForce(const State& state, bool inGround) const {
-    return getExponentialSpringForce().getForce(state, inGround);
-}
-
-Vec3
-ExponentialContactForce::
-getStationPosition(const State& state, bool inGround) const {
-    return getExponentialSpringForce().getStationPosition(state, inGround);
-}
-
-Vec3
-ExponentialContactForce::
-getStationVelocity(const State& state, bool inGround) const {
-    return getExponentialSpringForce().getStationVelocity(state, inGround);
-}
-
-Vec3
-ExponentialContactForce::
-getAnchorPointPosition(const State& state, bool inGround) const {
-    return getExponentialSpringForce().getAnchorPointPosition(state, inGround);
-}
-
-//-----------------------------------------------------------------------------
-// Reporting
-//-----------------------------------------------------------------------------
-OpenSim::Array<std::string>
-ExponentialContactForce::
-getRecordLabels() const {
-    OpenSim::Array<std::string> labels("");
-    string name = getName();  // Name of this contact instance.
-    std::string frameName = get_station().getParentFrame().getName();
-    std::string groundName = getModel().getGround().getName();
-
-    // Record format consistent with HuntCrossleyForce.
-    // Body
-    labels.append(name + "." + frameName + ".force.X");
-    labels.append(name + "." + frameName + ".force.Y");
-    labels.append(name + "." + frameName + ".force.Z");
-    labels.append(name + "." + frameName + ".torque.X");
-    labels.append(name + "." + frameName + ".torque.Y");
-    labels.append(name + "." + frameName + ".torque.Z");
-    // Ground
-    labels.append(name + "." + groundName + ".force.X");
-    labels.append(name + "." + groundName + ".force.Y");
-    labels.append(name + "." + groundName + ".force.Z");
-    labels.append(name + "." + groundName + ".torque.X");
-    labels.append(name + "." + groundName + ".torque.Y");
-    labels.append(name + "." + groundName + ".torque.Z");
-
-    return labels;
-}
-
-OpenSim::Array<double>
-ExponentialContactForce::
-getRecordValues(const SimTK::State& state) const  {
-    OpenSim::Array<double> values(0.0);
-
-    const auto& forceSubsys = getModel().getForceSubsystem();
-    const SimTK::Force& abstractForce = forceSubsys.getForce(_index);
-    const auto& spr = (SimTK::ExponentialSpringForce&)(abstractForce);
-
-    // Get the loads
-    SimTK::Vector_<SimTK::SpatialVec> bForces(0);  // body
-    SimTK::Vector_<SimTK::Vec3> pForces(0);  // particle
-    SimTK::Vector mForces(0);  // mobility
-    spr.calcForceContribution(state, bForces, pForces, mForces);
-
-    // Body
-    SimTK::Vec3 force;
-    SimTK::Vec3 torque;
-    const auto& bodyIndex = get_station().getParentFrame()
-            .getMobilizedBodyIndex();
-    SimTK::SpatialVec& bodyForce = bForces(bodyIndex);
-    force = bodyForce[1];
-    torque = bodyForce[0];
-    values.append(3, &force[0]);
-    values.append(3, &torque[0]);
-
-    // Ground
-    const SimTK::MultibodySystem& system = _model->getSystem();
-    const SimTK::SimbodyMatterSubsystem& matter = system.getMatterSubsystem();
-    const SimTK::MobilizedBody& ground = matter.getGround();
-    const auto& groundIndex = ground.getMobilizedBodyIndex();
-    SimTK::SpatialVec& groundForce = bForces(groundIndex);
-    force = groundForce[1];
-    torque = groundForce[0];
-    values.append(3, &force[0]);
-    values.append(3, &torque[0]);
-
-    return values;
-}
-
-//-----------------------------------------------------------------------------
-// Internal Testing
-//-----------------------------------------------------------------------------
-void
-ExponentialContactForce::
-assertPropertiesAndParametersEqual() const {
-    const ExponentialContactForce::Parameters& a = get_contact_parameters();
-    const SimTK::ExponentialSpringParameters& b = getParameters();
-
-    const SimTK::Vec3& vecA = a.get_exponential_shape_parameters();
-    SimTK::Vec3 vecB;
-    b.getShapeParameters(vecB[0], vecB[1], vecB[2]);
-    SimTK_TEST_EQ(vecA[0], vecB[0]);
-    SimTK_TEST_EQ(vecA[1], vecB[1]);
-    SimTK_TEST_EQ(vecA[2], vecB[2]);
-
-    double valA, valB;
-    valA = a.get_normal_viscosity();
-    valB = b.getNormalViscosity();
-    SimTK_TEST_EQ(valA, valB);
-
-    valA = a.get_friction_elasticity();
-    valB = b.getFrictionElasticity();
-    SimTK_TEST_EQ(valA, valB);
-
-    valA = a.get_friction_viscosity();
-    valB = b.getFrictionViscosity();
-    SimTK_TEST_EQ(valA, valB);
-
-    valA = a.get_settle_velocity();
-    valB = b.getSettleVelocity();
-    SimTK_TEST_EQ(valA, valB);
-
-    valA = a.get_initial_mu_static();
-    valB = b.getInitialMuStatic();
-    SimTK_TEST_EQ(valA, valB);
-
-    valA = a.get_initial_mu_kinetic();
-    valB = b.getInitialMuKinetic();
-    SimTK_TEST_EQ(valA, valB);
-}
diff --git a/OpenSim/Simulation/Model/ExponentialContactForce.h b/OpenSim/Simulation/Model/ExponentialContactForce.h
deleted file mode 100644
index f4b779f83..000000000
--- a/OpenSim/Simulation/Model/ExponentialContactForce.h
+++ /dev/null
@@ -1,786 +0,0 @@
-#ifndef OPENSIM_EXPONENTIAL_CONTACT_FORCE_H_
-#define OPENSIM_EXPONENTIAL_CONTACT_FORCE_H_
-/* -------------------------------------------------------------------------- *
- *                  OpenSim:  ExponentialContactForce.h                       *
- * -------------------------------------------------------------------------- *
- * The OpenSim API is a toolkit for musculoskeletal modeling and simulation.  *
- * See http://opensim.stanford.edu and the NOTICE file for more information.  *
- * OpenSim is developed at Stanford University and supported by the US        *
- * National Institutes of Health (U54 GM072970, R24 HD065690) and by DARPA    *
- * through the Warrior Web program.                                           *
- *                                                                            *
- * Copyright (c) 2024-2025 Stanford University and the Authors                *
- * Author(s): F. C. Anderson                                                  *
- * Contributor(s): Nicholas Bianco                                            *
- *                                                                            *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may    *
- * not use this file except in compliance with the License. You may obtain a  *
- * copy of the License at http://www.apache.org/licenses/LICENSE-2.0.         *
- *                                                                            *
- * Unless required by applicable law or agreed to in writing, software        *
- * distributed under the License is distributed on an "AS IS" BASIS,          *
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *
- * See the License for the specific language governing permissions and        *
- * limitations under the License.                                             *
- * -------------------------------------------------------------------------- */
-// INCLUDE
-#include "Force.h"
-#include "OpenSim/Simulation/Model/Model.h"
-
-namespace OpenSim {
-
-//=============================================================================
-// ExponentialContactForce
-//=============================================================================
-/** Class ExponentialContactForce uses an "exponential spring" as a means
-of modeling contact of a specified point on a Body with a contact
-plane that is fixed to Ground. This specified point is referred to in this
-documentation as the "body station". Each ExponentialContactForce instance
-acts at only one body station. In practice, you should choose a number of
-body stations strategically located across the surface of a Body,
-and construct an ExponentialContactForce instance for each of those body
-stations. For example, if the Body were a cube, you would likely choose the
-body stations to be the corners of the cube and construct an
-ExponentialContactForce instance for each corner of the cube (so a total of 8
-instances). The contact plane is typically used to model interactions with a
-floor, but is not limited to this use case. The contact plane can be rotated
-and translated relative to the Ground frame and so can be used to model a
-wall, ramp, or some other planar structure.
-
-Aspects of the exponential contact model are described in the following
-publication:
-
-        Anderson F.C. and Pandy M.G. (1999). A dynamics optimization
-        solution for vertical jumping in three dimensions. Computer Methods
-        in Biomechanics and Biomedical Engineering 2(3):201-231.
-
-Under the covers, the OpenSim::ExponentialContactForce class encapsulates two
-SimTK objects: ExponentialSpringForce and ExponentialSpringParameters.
-For the details concerning these classes, see the Simbody API
-documentation. A condensed version of that documentation is provided here.
-
-### States
-Each instance of ExponentialContactForce possesses 4 states, which are listed
-below in the appropriate category:
-
-#### Discrete States
--  (Real) = Static coefficient of friction.  0.0  
--  (Real) = Kinetic coefficient of friction.  0.0    
-
-As discrete states,  and  can be changed during the course of a simulation
-without invalidating the model's topology. This feature allows  and  to be
-altered during a simulation to model, for example, a slippery spot on the
-floor.
-
-#### Auto Update Discrete States
-- p (Vec3) = Elastic anchor point of the frictional spring. p always lies in
-the contact plane.
-- Sliding (Real) = Sliding state of the body station. 0.0  Sliding  1.0.
-A value of 0.0 indicates that p is "static" or fixed in place, in which case
- = . A value of 1.0 indicates that p is "kinetic" or sliding, in which case
- = . A value between 0.0 and 1.0 indicates that a transition from fixed to
-sliding or from sliding to fixed is underway, in which case     .
-Sliding is also used to blend between friction Model 1 and Model 2 (see
-below).
-
-### Computations and Coordinate Frames
-The positive z-axis of the contact plane frame defines the normal direction.
-The positive z-axis is the axis along which the repelling normal force
-(modeled using an exponential) is applied. The x-axis and y-axis of the
-contact plane frame together define the plane in which any friction force
-acts. The friction force can be properly thought of as the tangent component
-of the total contact force.
-
-In the equations below, all quantities are expressed in the frame of the
-contact plane. A variable with a "z" suffix (e.g., pz, vz, or cz) refers
-to a quantity that is normal to the contact plane or that pertains to
-calculation of the normal force. A variable with an "xy" suffix
-(e.g., pxy, vxy, or cxy) refers to a quantity that lies in or is tangent to
-the contact plane or that pertains to calculation of the friction force.
-
-The terms 'contact plane', 'friction plane', and 'tangent plane' are synonymous
-with one another. They all refer to the plane defined by the x-axis and y-axis
-of the contact plane frame. Throughout the documentation, the term 
-'contact plane' is preferentially used.
-
-### Normal Force (positive z-axis)
-
-The elastic part of the normal force is computed using an exponential
-whose shape is a function of three parameters (d, d, and d):
-
-        fzElastic = dexp(d(pzd))
-
-Note that pz is the displacement of the body station above (pz > 0.0)
-or below (pz < 0.0) the contact plane. The default values of the shape
-parameters were chosen to maximize integration step size while maintaining a
-number of constraints (e.g., the normal force should fall below 0.01 Newtons
-when pz > 1.0 cm). The damping part of the normal force is linear in velocity
-and scaled by the elastic part:
-
-        fzDamping = cz vz fzElastic,
-
-where vz is the normal component of the velocity of the body station and
-cz is the damping coefficient for the normal direction. All together, the
-spring force in the normal direction is given by
-
-        fz  = fzElastic + fzDamping
-            = dexp(d(pyd))  cz vz dexp(d(pzd)))
-            = dexp(d(pzd)) (1  cz vz)
-
-which has the form of the Hunt & Crossley damping model:
-
-        K. H. Hunt and F. R. E. Crossley (1975). Coefficient of Restitution
-        Interpreted as Damping in Vibroimpact. ASME Journal of Applied
-        Mechanics, pp. 440-445.
-
-### Friction Force (x-y plane)
-
-The friction force is computed by blending two different friction models.
-The blending is performed based on the 'Sliding' State of the
-ExponentialSpringForce class.
-
-#### Friction Model 1 - Pure Damping (Sliding = 1.0)
-When the body station is sliding with respect to the contact plane, the
-friction force is computed using a simple damping term:
-
-        fricDamp = cxy vxy
-
-where cxy is the damping coefficient in the contact plane and vxy is the
-velocity of the body station in the contact plane. The magnitude of the
-total frictional force is not allowed to exceed the frictional limit:
-
-        fricLimit =  fz
-        if (|fricDamp| > fricLimit)
-            fricDamp = fricLimit vxy / |vxy| =  fz vxy / |vxy|
-
-where  is the instantaneous coefficient of friction (more below). Note that
-fz is always positive and so fricLimit is a positive scalar. Thus, for
-velocities in the contact plane above some threshold velocity, which is
-typically small (i.e., less than 0.1 m/s), this model is consistent with a
-standard Coulomb Friction model.
-
-#### Friction Model 2 - Damped Linear Spring (Sliding = 0.0)
-When the body station is anchored with respect to the contact plane, the
-friction force is represented by a damped linear spring. The viscous term is
-given by the same damping expression as above:
-
-        fricDampSpr = cxy vxy
-
-and the elastic term is given by
-
-        fricElasSpr = kxy (pxyp)
-
-where kxy is the friction spring elasticity, pxy is the position of the body
-station projected onto the contact plane, and p is the current spring zero
-(i.e., the elastic anchor point of the friction spring). Note that p always
-resides in the contact plane.
-
-The total friction spring force is then given by the sum of the elastic and
-viscous terms:
-
-        fricSpr = fricElasSpr + fricDampSpr
-
-If the magnitude of the fricSpr exceeds the magnitude of the friction limit,
-the terms are scaled down:
-
-        if(|fricSpr| > fricLimit)
-            scaleFactor = fricLimit / |fricSpr|
-            fricDampSpr = scaleFactor * fricDampSpr
-            fricElasSpr = scaleFactor * fricElasSpr
-            fricSpr = fricElasSpr + fricDampSpr
-
-Scaling down the friction spring force does not alter its direction.
-
-#### Blending the Friction Models
-Blending Model 1 and Model 2 is accomplished using linear expressions of the
-Sliding State:
-
-        fricElasBlend = fricElasSpr * (1.0  Sliding)
-        fricDampBlend = fricDampSpr + (fricDamp  fricDampSpr)*Sliding
-        fricBlend = fricElasBlend + fricDampBlend
-
-Model 1 (Pure Damping) dominates as Sliding  1.0, and Model 2
-(Damped Linear Spring) dominates as Sliding  0.0.
-
-#### Moving the Friction Spring Zero
-The friction spring zero (p) (the elastic anchor point) is always altered
-to be consistent with the final value of the blended elastic force:
-
-        p = pxy + fricElasBlend / kxy;
-        p[2] = 0.0;  // ensures that p lies in the contact plane
-
-#### Coefficients of Friction
-Coefficients of kinetic (sliding) and static (fixed) friction can be specified
-for the spring, subject to the following constraints:
-
-        0.0    
-
-Note that there is no upper bound on . The instantaneous coefficient of
-friction () is calculated based on the value of the Sliding State:
-
-         =   Sliding*(  )
-
-The value of Sliding is calculated using a continuous function of the
-ratio of the speed of the elastic anchor point (p) to the settle velocity
-(vSettle). vSettle is a customizable topology-stage parameter that represents
-the speed at which a body station settles into a static state with respect to
-the contact plane. See SimTK::ExponentialSpringParameters::setSettleVelocity()
-for details. In particular,
-
-        p = |p| / t
-        Sliding = SimTK::stepUp( SimTK::clamp(0.0, p/vSettle, 1.0) )
-
-where p is the change in p and t is the change in time since the last
-successful integration step. When p  vSettle, Sliding = 1.0, and as
-p  0.0, Sliding  0.0.
-
-### Usage
-
-To construct an ExponentialContactForce instance, supply 1) a transform, which
-specifies the orientation and position of the contact plane in the ground
-frame, 2) a frame, which specifies the body on which the contact force will
-act, and 3) a location, which specifies the point, expressed in the local body
-frame, at which the contact force will be applied.
-
-Note that during construction, a Station is generated internally as a
-subcomponent of the ExponentialContactForce instance.
-
-\code{.cpp}
-// Step 1: Define the contact plane transform.
-// The following transform rotates about the x-axis by -90 degrees so that
-// the positive z-axis of the contact plane (i.e., the normal direction)
-// aligns with the positive y-axis of the ground frame, which is up in OpenSim.
-Rotation rotation(-SimTK::Pi/2.0, XAxis);
-Transform transform(rotation, SimTK::Vec3(0.));
-
-// Step 2: Obtain the PhysicalFrame on which the force will act.
-const PhysicalFrame& frame =
-    model->getComponent<PhysicalFrame>("/path/to/body/frame");
-
-// Step 3: Specify the body-local location at which the force will be applied.
-SimTK::Vec3 location(0.1, 0.2, 0.3);
-
-// Create the ExponentialContactForce instance and add it to the model.
-auto* ecf = new ExponentialContactForce(transform, frame, location);
-ecf->setName("myExponentialContactForce");
-model.addForce(ecf);
-\endcode
-
-The default contact parameters can be modified via a fourth, optional argument
-to the constructor. See "Customizable Parameters" below for details on how
-to customize the parameters of an ExponentialContactForce.
-
-\code{.cpp}
-SimTK::ExponentialSpringParameters myParams;
-myParams.setNormalViscosity(0.25);
-auto* ecf = new ExponentialContactForce(transform, frame, location, myParams);
-ecf->setName("myExponentialContactForce");
-model.addForce(ecf);
-\endcode
-
-### Copy Constructor, Move Constructor, and the Copy Assignment Operator
-
-The copy constructor, move constructor, and copy assignment operator are all
-compiler-generated. As such, they will copy or move member variables,
-OpenSim properties, and OpenSim sockets in cannonical ways. In general, these
-methods can be called at any time before the OpenSim::Model is built. Once the
-Model is built, however, certain operations will fail. In particular, using
-the assignment operator on an ExponentialContactForce instance after the Model
-is built will cause an exception to be thrown because the needed resources
-for connecting the Station socket properly do not exist in the left-hand side
-object.
-
-### Customizable Parameters
-
-Customizable Topology-stage parameters specifying the characteristics of the
-exponential spring are managed using SimTK::ExponentialSpringParameters.
-To customize any of the Topology-stage parameters on an ExponentialContactForce
-instance, you should
-
-1) Create an ExponentialSpringParameters object. This object will come with
-parameters that are suitable for simulating contact in typical situations
-(e.g., foot contact during gait).
-
-\code{.cpp}
-SimTK::ExponentialSpringParameters myParams;
-\endcode
-
-2) Use any of the available 'set' methods in ExponentialSpringParamters to
-change the parameters of that object. For example,
-
-\code{.cpp}
-myParams.setNormalViscosity(0.25);
-\endcode
-
-3) Use ExponentialContactForce::setParameters() to alter the parameters of one
-(or many) ExponentialContactForce instances. For example,
-
-\code{.cpp}
-SimTK::ExponentialContactForce spr1, spr2;
-spr1.setParameters(myParams);
-spr2.setParameters(myParams);
-\endcode
-
-4) Realize the system to Stage::Topology. When a new set of parameters is
-set on an ExponentialContactForce instance, as above in step 3, the System
-will be invalidated at Stage::Topology. The System must therefore be realized
-at Stage::Topology (and hence at Stage::Model) before a simulation can proceed.
-
-        system.realizeTopology();
-
-Note that each ExponentialContactForce instance owns its own private
-ExponentialSpringParameters object. The myParams object is just used to set
-the desired parameter values of the privately owned parameters object. It is
-fine for objects like myParams to go out of scope or for myParams objects
-allocated from the heap to be deleted.
-
-Therefore, also note that the parameter values possessed by an
-ExponentialContactForce instance do not necessarily correspond to the values
-held by a local instance of ExponentialSpringParameters until a call to
-ExponentialContactForce::setParameters() is made.
-
-The default values of the parameters are expressed in units of Newtons,
-meters, seconds, and kilograms; however, you may use an alternate set of
-self-consistent units by re-specifying all parameters.
-
-The default values of the parameters work well for typical contact
-interactions, but clearly may not be appropriate for simulating many contact
-interactions. For the full descriptions of the contact parameters see the
-Simbody API documentation for SimTK::ExponentialSpringParameters.
-
-@author F. C. Anderson **/
-class OSIMSIMULATION_API ExponentialContactForce : public Force {
-    OpenSim_DECLARE_CONCRETE_OBJECT(ExponentialContactForce, Force);
-
-public:
-    class Parameters;
-
-    //-------------------------------------------------------------------------
-    // Construction
-    //-------------------------------------------------------------------------
-    /** Default constructor. Construct an instance with default values for
-    the contact plane transform, body station, and contact parameters. Note
-    that the underlying SimTK::ExponentialSpringForce is not constructed until
-    the OpenSim Model is built. This constructor is relied upon when
-    deserializing from a .osim model file. */
-    ExponentialContactForce();
-
-    /** Construct an ExponentialContactForce instance.
-    @param X_GP Transform specifying the location and orientation of the
-    contact plane frame (P) with respect to the Ground frame (G). The positive
-    z-axis of P defines the normal direction; the x-axis and y-axis of P
-    together define the tangent (or friction) plane. Note that X_GP is the
-    operator that transforms a point of P (point_P) to that same point in
-    space but measured from the Ground origin (G) and expressed in G
-    (i.e., point_G = X_GP * point_P).
-    @param frame The frame in which the station is located.
-    @param location The location of the station in the frame.
-    @param params Optional parameters object used to customize the
-    topology-stage characteristics of the contact model. */
-    explicit ExponentialContactForce(const SimTK::Transform& X_GP,
-        const PhysicalFrame& frame,
-        const SimTK::Vec3& location,
-        SimTK::ExponentialSpringParameters params =
-        SimTK::ExponentialSpringParameters());
-
-    //-------------------------------------------------------------------------
-    // Utility
-    //-------------------------------------------------------------------------
-    /** Reset the elastic anchor point (friction spring zero) so that it
-    coincides with the projection of the body station onto the contact
-    plane. This step is often needed at the beginning of a simulation to
-    ensure that a simulation does not begin with large friction forces.
-    After this call, the elastic portion of the friction force should be 0.0.
-    Calling this method will invalidate the System at Stage::Dynamics.
-    @param state State object on which to base the reset. */
-    void resetAnchorPoint(SimTK::State& state) const;
-
-    /** Reset the elastic anchor points (friction spring zeros) of all
-    ExponentialContactForce instances in an OpenSim::Model. This step is
-    often needed at the beginning of a simulation to ensure that a simulation
-    does not begin with large friction forces. Calling this method will
-    invalidate the System at Stage::Dynamics.
-    @param model the Model.
-    @param state State object on which to base the reset. */
-    static void resetAnchorPoints(OpenSim::Model& model, SimTK::State& state);
-
-    //-------------------------------------------------------------------------
-    // Accessors for properties
-    //-------------------------------------------------------------------------
-    /** Get the transform that specifies the location and orientation of the
-    contact plane in the Ground frame. */
-    const SimTK::Transform& getContactPlaneTransform() const {
-        return get_contact_plane_transform();
-    }
-
-    /** Set the customizable Topology-stage spring parameters.
-    Calling this method will invalidate the SimTK::System at
-    Stage::Toplogy and, thus, require the SimTK::System to be re-realized
-    to Stage::Model before simulation or analysis can be resumed. */
-    void setParameters(const SimTK::ExponentialSpringParameters& params);
-    /** Get the customizable topology-stage spring parameters. Use the copy
-    constructor or the assignment operator on the returned reference to create
-    a parameters object that can be modified. */
-    const SimTK::ExponentialSpringParameters& getParameters() const;
-
-    /** Get the Station that is connected to the body frame and at which the
-    contact force is applied. The Station is a subcomponent of this
-    ExponentialContactForce instance. */
-    const Station& getStation() const;
-
-    //-------------------------------------------------------------------------
-    // Accessors for Discrete States
-    //-------------------------------------------------------------------------
-    /** Get a pointer to the SimTK::Subsystem from which this
-    ExponentialContactForce instance allocates its discrete states. */
-    const SimTK::Subsystem* getSubsystem() const {
-        return &getExponentialSpringForce().getForceSubsystem();
-    }
-
-    /** Get the name used for the discrete state representing the static
-    coefficient of friction (). This name is used to access informattion
-    related to  via the OpenSim::Component API.
-    See Component::getDiscreteVariableValue(). */
-    std::string getMuStaticDiscreteStateName() const { return "mu_static"; }
-
-    /** Set the static coefficient of friction () for this exponential
-    spring.  is a discrete state. The value of  is held in the System's
-    State object. Unlike the parameters managed by
-    SimTK::ExponentialSpringParameters,  can be set at any time during a
-    simulation. A change to  will invalidate the System at Stage::Dynamics,
-    but not Stage::Topology.
-    @param state State object that will be modified.
-    @param mus %Value of the static coefficient of friction. No upper bound.
-    0.0  . If  < ,  is set equal to . */
-    void setMuStatic(SimTK::State& state, SimTK::Real mus);
-
-    /** Get the static coefficient of friction () for this exponential
-    contact instance held by the specified state.
-    @param state State object from which to retrieve . */
-    SimTK::Real getMuStatic(const SimTK::State& state) const;
-
-    /** Get the name used for the discrete state representing the kinetic
-    coefficient of friction (). This name is used to access informattion
-    related to  via the OpenSim::Component API. For example, see
-    Component::getDiscreteVariableValue(). */
-    std::string getMuKineticDiscreteStateName() const { return "mu_kinetic"; }
-
-    /** Set the kinetic coefficient of friction () for this exponential
-    spring. The value of  is held in the System's State object. Unlike the
-    parameters managed by ExponentialSpringParameters,  can be set at any
-    time during a simulation. A change to  will invalidate the System at
-    Stage::Dynamics.
-    @param state State object that will be modified.
-    @param muk %Value of the kinetic coefficient of friction. No upper bound.
-    0.0  . If  > ,  is set equal to . */
-    void setMuKinetic(SimTK::State& state, SimTK::Real muk);
-
-    /** Get the kinetic coefficient of friction () for this exponential
-    contact instance held by the specified state.
-    @param state State object from which to retrieve . */
-    SimTK::Real getMuKinetic(const SimTK::State& state) const;
-
-    /** Get the name used for the discrete state representing the Sliding
-    state (K) of the elastic anchor point. This name is used to access
-    informattion related to K via the OpenSim::Component API. For example, see
-    Component::getDiscreteVariableValue(). */
-    std::string getSlidingDiscreteStateName() const { return "sliding"; }
-
-    /** Get the Sliding state of this exponential contact instance after it
-    has been updated to be consistent with the System State. The Sliding state
-    lies between 0.0 and 1.0, where 0.0 indicates that p (the elastic anchor)
-    point is "static" or fixed in place, and 1.0 indicates that p is "kinetic" 
-    or sliding. The System must be realized to Stage::Dynamics to access this 
-    data.
-    @param state State object on which to base the calculations. */
-    SimTK::Real getSliding(const SimTK::State& state) const;
-
-    /** Get the name used for the discrete state representing the position
-    of the elastic anchor point (p). This name is used to access
-    informattion related to p via the OpenSim::Component API. For example,
-    see Component::getDiscreteVariableAbstractValue(). */
-    std::string getAnchorPointDiscreteStateName() const { return "anchor"; }
-
-    /** Get the position of the elastic anchor point (p) after it has been
-    updated to be consistent with friction limits. p is the spring zero of
-    the damped linear spring used in Friction Model 2. See the documentation
-    for SimTK::ExponentialSpringForce for a detailed description of the
-    friction model. The system must be realized to Stage::Dynamics to access
-    this data.
-    @param state State object on which to base the calculations.
-    @param inGround Flag for choosing the frame in which the returned quantity
-    will be expressed. If true (the default), the quantity will be expressed
-    in the Ground frame. If false, the quantity will be expressed in the frame
-    of the contact plane. */
-    SimTK::Vec3 getAnchorPointPosition(
-            const SimTK::State& state, bool inGround = true) const;
-
-    //-------------------------------------------------------------------------
-    // Accessors for data cache entries
-    //-------------------------------------------------------------------------
-    /** Get the elastic part of the normal force. The system must be realized
-    to Stage::Dynamics to access this data.
-    @param state State object on which to base the calculations.
-    @param inGround Flag for choosing the frame in which the returned quantity
-    will be expressed. If true (the default), the quantity will be expressed
-    in the Ground frame. If false, the quantity will be expressed in the frame
-    of the contact plane. */
-    SimTK::Vec3 getNormalForceElasticPart(
-        const SimTK::State& state, bool inGround = true) const;
-
-    /** Get the damping part of the normal force. The system must be realized
-    to Stage::Dynamics to access this data.
-    @param state State object on which to base the calculations.
-    @param inGround Flag for choosing the frame in which the returned quantity
-    will be expressed. If true (the default), the quantity will be expressed
-    in the Ground frame. If false, the quantity will be expressed in the frame
-    of the contact plane. */
-    SimTK::Vec3 getNormalForceDampingPart(
-        const SimTK::State& state, bool inGround = true) const;
-
-    /** Get the total normal force. The system must be realized to
-    Stage::Dynamics to access this data.
-    @param state State object on which to base the calculations.
-    @param inGround Flag for choosing the frame in which the returned quantity
-    will be expressed. If true (the default), the quantity will be expressed
-    in the Ground frame. If false, the quantity will be expressed in the frame
-    of the contact plane. */
-    SimTK::Vec3 getNormalForce(
-        const SimTK::State& state, bool inGround = true) const;
-
-    /** Get the instantaneous coefficient of friction (). The system must be
-    realized to Stage::Dynamics to access this data.  is obtained by using
-    the Sliding state to transition between  and :
-
-             =  - Sliding*( - )
-
-    Because 0.0  Sliding  1.0,     .
-    @param state State object on which to base the calculations. */
-    SimTK::Real getMu(const SimTK::State& state) const;
-
-    /** Get the friction limit. The system must be realized to Stage::Dynamics
-    to access this data.
-    @param state State object on which to base the calculations. */
-    SimTK::Real getFrictionForceLimit(const SimTK::State& state) const;
-
-    /** Get the elastic part of the friction force. The system must be
-    realized to Stage::Dynamics to access this data.
-    @param state State object on which to base the calculations.
-    @param inGround Flag for choosing the frame in which the returned quantity
-    will be expressed. If true (the default), the quantity will be expressed
-    in the Ground frame. If false, the quantity will be expressed in the frame
-    of the contact plane. */
-    SimTK::Vec3 getFrictionForceElasticPart(
-        const SimTK::State& state, bool inGround = true) const;
-
-    /** Get the damping part of the friction force. The system must be
-    realized to Stage::Dynamics to access this data.
-    @param state State object on which to base the calculations.
-    @param inGround Flag for choosing the frame in which the returned quantity
-    will be expressed. If true (the default), the quantity will be expressed
-    in the Ground frame. If false, the quantity will be expressed in the frame
-    of the contact plane. */
-    SimTK::Vec3 getFrictionForceDampingPart(
-        const SimTK::State& state, bool inGround = true) const;
-
-    /** Get the total friction force. The total frictional force is always
-    just the sum of the elastic part and the damping part of the frictional
-    force, which may be obtained separately by calling
-    getFrictionalForceElasticPart() and getFrictionalForceDampingPart().
-    The system must be realized to Stage::Dynamics to access this data.
-    @param state State object on which to base the calculations.
-    @param inGround Flag for choosing the frame in which the returned quantity
-    will be expressed. If true (the default), the quantity will be expressed
-    in the Ground frame. If false, the quantity will be expressed in the frame
-    of the contact plane. */
-    SimTK::Vec3 getFrictionForce(
-        const SimTK::State& state, bool inGround = true) const;
-
-    /** Get the total force applied to the body by this
-    ExponentialSpringForce instance. The total force is the vector sum of the
-    friction force, which may be obtained by a call to getFrictionForce(), and
-    the normal force, which may be obtained by a call to getNormalForce().
-    The system must be realized to Stage::Dynamics to access this data.
-    @param state State object on which to base the calculations.
-    @param inGround Flag for choosing the frame in which the returned quantity
-    will be expressed. If true (the default), the quantity will be expressed
-    in the Ground frame. If false, the quantity will be expressed in the frame
-    of the contact plane. */
-    SimTK::Vec3 getForce(
-        const SimTK::State& state, bool inGround = true) const;
-
-    /** Get the position of the body station (i.e., the point on the body at
-    which the force generated by this ExponentialSpringForce is applied). This
-    method differs from getStation() in terms of the frame in which the
-    station is expressed. getStationPosition() expresses the point either in the
-    Ground frame or in the frame of the contact plane. getStation() expresses
-    the point in the frame of the MobilizedBody.  The system must be realized to 
-    Stage::Position to access this data.
-    @param state State object on which to base the calculations.
-    @param inGround Flag for choosing the frame in which the returned quantity
-    will be expressed. If true (the default), the quantity will be expressed
-    in the Ground frame. If false, the quantity will be expressed in the frame
-    of the contact plane. */
-    SimTK::Vec3 getStationPosition(
-        const SimTK::State& state, bool inGround = true) const;
-
-    /** Get the velocity of the body station (i.e., the point on the body at
-    which the force generated by this ExponentialSpringForce is applied).
-    The system must be realized to Stage::Velocity to access this data.
-    @param state State object on which to base the calculations.
-    @param inGround Flag for choosing the frame in which the returned quantity
-    will be expressed. If true (the default), the quantity will be expressed
-    in the Ground frame. If false, the quantity will be expressed in the frame
-    of the contact plane. */
-    SimTK::Vec3 getStationVelocity(
-        const SimTK::State& state, bool inGround = true) const;
-
-    //-------------------------------------------------------------------------
-    // Reporting
-    //-------------------------------------------------------------------------
-    /** Provide name(s) of the quantities (column labels) of the value(s)
-    to be reported. */
-    OpenSim::Array<std::string> getRecordLabels() const override;
-    /** Provide the value(s) to be reported that correspond to the labels. */
-    OpenSim::Array<double> getRecordValues(
-            const SimTK::State& state) const override;
-
-    //-------------------------------------------------------------------------
-    // Internal Testing
-    //-------------------------------------------------------------------------
-    /** Assess consistency between Properties and internal parameters. */
-    void assertPropertiesAndParametersEqual() const;
-
-protected:
-    /** Connect to the OpenSim Model. */
-    void extendConnectToModel(Model& model) override;
-
-    /** Create the SimTK::ExponentialSpringForce object that implements
-    this Force. */
-    void extendAddToSystem(SimTK::MultibodySystem& system) const override;
-
-    /** Initialize discrete variable indices. */
-    virtual void extendRealizeTopology(SimTK::State& state) const override;
-
-    /** Update this Object base on an XML node. */
-    void updateFromXMLNode(SimTK::Xml::Element& node,
-        int versionNumber) override;
-
-private:
-    //-------------------------------------------------------------------------
-    // PROPERTIES
-    //-------------------------------------------------------------------------
-    OpenSim_DECLARE_PROPERTY(contact_plane_transform, SimTK::Transform,
-        "Orientation and location of the contact plane wrt Ground. The positive z-axis of the contact plane defines the normal.");
-    OpenSim_DECLARE_PROPERTY(contact_parameters,
-        ExponentialContactForce::Parameters,
-        "Customizable topology-stage parameters.");
-    OpenSim_DECLARE_PROPERTY(station, Station,
-        "The station at which the contact force is applied.");
-
-    void setNull();
-    void constructProperties();
-    const SimTK::ExponentialSpringForce& getExponentialSpringForce() const;
-    SimTK::ExponentialSpringForce& updExponentialSpringForce();
-
-}; // END of class ExponentialContactForce
-
-
-//=============================================================================
-// ExponentialContactForce::Parameters
-//=============================================================================
-/** This subclass helps manage the topology-stage parameters of the underlying
-SimTK::ExponentialSpringForce instance. These parameters (e.g., elasticity,
-viscosity, etc.) determine the force-producing characteristics of the
-exponential spring force.
-
-This class does 3 things:
-
-- Implements an OpenSim Property for each of the customizable contact
-parameters, enabling those parameters to be serialized and de-serialized to
-and from an OpenSim Model file.
-
-- Provides a member variable (_stkparams) for storing user-set parameters
-prior to the existance of the underlying SimTK::ExponentialSpringForce object.
-During model initialization, when the SimTK::ExponetialSpringForce object is
-constructed, the user-set properties/parameters are then pushed to that object.
-
-- Ensures that the values held by the OpenSim properties are kept consistent
-with the values held by a SimTK::ExponentialSpringParameters object.
-Depending on the circumstance, parameters are updated to match properties, or
-properties are updated to match parameters.
-
-To change the values of individual parameters programmatically:
-```
-    // Get a modifiable copy of the underlying parameter object
-    // (`exp_contact` is an instance of ExponentialContactForce)
-    SimTK::ExponentialSpringParameters p = exp_contact.getParameters();
-
-    // Make the desired changes to the copy using the appropropriate setters
-    p.setFrictionElasticity(kpNew);
-    p.setFrictionViscosity(kvNew);
-    ...
-
-    // Call ExponentialContactForce::setParameters() to push the new
-    // parameters to the underlying SimTK::ExponentialSpringForce object.
-    exp_contact.setParameters(p);
-```
-
-@author F. C. Anderson **/
-class ExponentialContactForce::Parameters : public Object {
-    OpenSim_DECLARE_CONCRETE_OBJECT(ExponentialContactForce::Parameters, Object);
-
-public:
-    OpenSim_DECLARE_PROPERTY(exponential_shape_parameters, SimTK::Vec3,
-        "Shape parameters for the exponential that models the normal force: d0 (0.0065905 m), d1 (0.5336 N), d2 (1150.0/m).");
-    OpenSim_DECLARE_PROPERTY(normal_viscosity, double,
-        "Viscosity in the normal direction (0.5 s/m).");
-    OpenSim_DECLARE_PROPERTY(max_normal_force, double,
-        "Maximum allowed normal force (100,000.0 N).");
-    OpenSim_DECLARE_PROPERTY(friction_elasticity, double,
-        "Elasticity of the friction spring (20,000.0 N/m).");
-    OpenSim_DECLARE_PROPERTY(friction_viscosity, double,
-        "Viscosity of the friction spring (282.8427 N*s/m).");
-     OpenSim_DECLARE_PROPERTY(settle_velocity, double,
-        "Velocity below which static friction conditions are triggered (0.01 m/s) .");
-    OpenSim_DECLARE_PROPERTY(initial_mu_static, double,
-        "Initial value of the static coefficient of friction.");
-    OpenSim_DECLARE_PROPERTY(initial_mu_kinetic, double,
-        "Initial value of the kinetic coefficient of friction.");
-
-public:
-    /** Default constructor. */
-    Parameters();
-
-    /** Construct an instance based on a SimTK::ExponentialSpringParameters
-    object. */
-    Parameters(const SimTK::ExponentialSpringParameters& params);
-
-    /** Set the underlying SimTK parameters. This method is used to maintain
-    consistency between OpenSim Properties and the underlying parameters.
-    The typical user of OpenSim::ExponentialContactForce will not have reason
-    to call this method. For setting contact parameters, the typical user
-    should call OpenSim::ExponentialContactForce::setParameters(). */
-    void setSimTKParameters(const SimTK::ExponentialSpringParameters& params);
-
-    /** Get a read-only reference to the underlying SimTK parameters. This
-    method is used to maintain consistency between OpenSim Properties and the
-    underlying parameters. The typical user of OpenSim::ExponentialContactForce
-    will not have reason to call this method. For getting contact parameters,
-    the typical user should call
-    OpenSim::ExponentialContactForce::getParameters() */
-    const SimTK::ExponentialSpringParameters& getSimTKParameters() const;
-
-private:
-    void setNull();
-    void constructProperties();
-    void updateParameters();
-    void updateProperties();
-    void updateFromXMLNode(SimTK::Xml::Element& node,
-        int versionNumber) override;
-    SimTK::ExponentialSpringParameters _stkparams;
-};
-
-} // end of namespace OpenSim
-
-#endif // OPENSIM_EXPONENTIAL_CONTACT_FORCE_H_
diff --git a/OpenSim/Simulation/Model/ExpressionBasedCoordinateForce.cpp b/OpenSim/Simulation/Model/ExpressionBasedCoordinateForce.cpp
index bb76b4417..f0e496720 100644
--- a/OpenSim/Simulation/Model/ExpressionBasedCoordinateForce.cpp
+++ b/OpenSim/Simulation/Model/ExpressionBasedCoordinateForce.cpp
@@ -131,7 +131,6 @@ void ExpressionBasedCoordinateForce::implProduceForces(const SimTK::State& s,
 // Compute the force
 double ExpressionBasedCoordinateForce::calcExpressionForce(const SimTK::State& s ) const
 {
-    using namespace SimTK;
     double q = _coord->getValue(s);
     double qdot = _coord->getSpeedValue(s);
     std::map<std::string, double> forceVars;
@@ -164,4 +163,4 @@ Array<double> ExpressionBasedCoordinateForce::getRecordValues(const SimTK::State
     OpenSim::Array<double> values(0.0, 0, 1);
     values.append(calcExpressionForce(state));
     return values;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/Model/ExpressionBasedPointToPointForce.cpp b/OpenSim/Simulation/Model/ExpressionBasedPointToPointForce.cpp
index c5dbcb23c..8fdb1bf25 100644
--- a/OpenSim/Simulation/Model/ExpressionBasedPointToPointForce.cpp
+++ b/OpenSim/Simulation/Model/ExpressionBasedPointToPointForce.cpp
@@ -166,22 +166,20 @@ void ExpressionBasedPointToPointForce::implProduceForces(
     const SimTK::State& s,
     ForceConsumer& forceConsumer) const
 {
-    using namespace SimTK;
+    const SimTK::Transform& X_GB1 = _body1->getMobilizedBody().getBodyTransform(s);
+    const SimTK::Transform& X_GB2 = _body2->getMobilizedBody().getBodyTransform(s);
 
-    const Transform& X_GB1 = _body1->getMobilizedBody().getBodyTransform(s);
-    const Transform& X_GB2 = _body2->getMobilizedBody().getBodyTransform(s);
+    const SimTK::Vec3 s1_G = X_GB1.R() * getPoint1();
+    const SimTK::Vec3 s2_G = X_GB2.R() * getPoint2();
 
-    const Vec3 s1_G = X_GB1.R() * getPoint1();
-    const Vec3 s2_G = X_GB2.R() * getPoint2();
-
-    const Vec3 p1_G = X_GB1.p() + s1_G; // point measured from ground origin
-    const Vec3 p2_G = X_GB2.p() + s2_G;
-    const Vec3 r_G = p2_G - p1_G; // vector from point1 to point2
+    const SimTK::Vec3 p1_G = X_GB1.p() + s1_G; // point measured from ground origin
+    const SimTK::Vec3 p2_G = X_GB2.p() + s2_G;
+    const SimTK::Vec3 r_G = p2_G - p1_G; // vector from point1 to point2
     const double d = r_G.norm();  // distance between the points
 
-    const Vec3 v1_G = _body1->getMobilizedBody().findStationVelocityInGround(s, getPoint1());
-    const Vec3 v2_G = _body2->getMobilizedBody().findStationVelocityInGround(s, getPoint2());
-    const Vec3 vRel = v2_G - v1_G; // relative velocity
+    const SimTK::Vec3 v1_G = _body1->getMobilizedBody().findStationVelocityInGround(s, getPoint1());
+    const SimTK::Vec3 v2_G = _body2->getMobilizedBody().findStationVelocityInGround(s, getPoint2());
+    const SimTK::Vec3 vRel = v2_G - v1_G; // relative velocity
 
     //speed along the line connecting the two bodies
     const double ddot = dot(vRel, r_G)/d;
@@ -193,10 +191,10 @@ void ExpressionBasedPointToPointForce::implProduceForces(
     double forceMag = _forceProg.evaluate(forceVars);
     setCacheVariableValue(s, _forceMagnitudeCV, forceMag);
 
-    const Vec3 f1_G = (forceMag/d) * r_G;
+    const SimTK::Vec3 f1_G = (forceMag/d) * r_G;
 
-    forceConsumer.consumeBodySpatialVec(s, *_body1,  SpatialVec(s1_G % f1_G, f1_G));
-    forceConsumer.consumeBodySpatialVec(s, *_body2, -SpatialVec(s2_G % f1_G, f1_G));
+    forceConsumer.consumeBodySpatialVec(s, *_body1,  SimTK::SpatialVec(s1_G % f1_G, f1_G));
+    forceConsumer.consumeBodySpatialVec(s, *_body2, -SimTK::SpatialVec(s2_G % f1_G, f1_G));
 }
 
 // get the force magnitude that has already been computed
@@ -261,5 +259,4 @@ getRecordValues(const SimTK::State& state) const
     values.append(3, &gpoint[0]);
 
     return values;
-}
-
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/Model/FunctionBasedBushingForce.cpp b/OpenSim/Simulation/Model/FunctionBasedBushingForce.cpp
index 6805bd58e..47a6fe5db 100644
--- a/OpenSim/Simulation/Model/FunctionBasedBushingForce.cpp
+++ b/OpenSim/Simulation/Model/FunctionBasedBushingForce.cpp
@@ -29,7 +29,6 @@
 #include "FunctionBasedBushingForce.h"
 
 using namespace std;
-using namespace SimTK;
 using namespace OpenSim;
 
 //=============================================================================
@@ -63,11 +62,11 @@ FunctionBasedBushingForce::FunctionBasedBushingForce(
 // Convenience constructor for zero value force functions.
 FunctionBasedBushingForce::FunctionBasedBushingForce(const string&   name,
                                     const string&   frame1Name,
-                                    const Vec3&     point1,
-                                    const Vec3&     orientation1,
+                                    const SimTK::Vec3&     point1,
+                                    const SimTK::Vec3&     orientation1,
                                     const string&   frame2Name,
-                                    const Vec3&     point2,
-                                    const Vec3&     orientation2)
+                                    const SimTK::Vec3&     point2,
+                                    const SimTK::Vec3&     orientation2)
     : Super(name,
             frame1Name, point1, orientation1,
             frame2Name, point2, orientation2)
@@ -107,15 +106,15 @@ FunctionBasedBushingForce::FunctionBasedBushingForce(
 FunctionBasedBushingForce::FunctionBasedBushingForce(
                                     const std::string& name,
                                     const string&    frame1Name,
-                                    const Vec3&      point1,
-                                    const Vec3&      orientation1,
+                                    const SimTK::Vec3&      point1,
+                                    const SimTK::Vec3&      orientation1,
                                     const string&    frame2Name,
-                                    const Vec3&      point2,
-                                    const Vec3&      orientation2,
-                                    const Vec3&      transStiffness,
-                                    const Vec3&      rotStiffness,
-                                    const Vec3&      transDamping,
-                                    const Vec3&      rotDamping)
+                                    const SimTK::Vec3&      point2,
+                                    const SimTK::Vec3&      orientation2,
+                                    const SimTK::Vec3&      transStiffness,
+                                    const SimTK::Vec3&      rotStiffness,
+                                    const SimTK::Vec3&      transDamping,
+                                    const SimTK::Vec3&      rotDamping)
     : FunctionBasedBushingForce(name,
                                 frame1Name, point1, orientation1,
                                 frame2Name, point2, orientation2)
@@ -151,8 +150,8 @@ void FunctionBasedBushingForce::constructProperties()
     constructProperty_f_y_delta_y_function( zeroFunc );
     constructProperty_f_z_delta_z_function( zeroFunc );
     
-    constructProperty_rotational_damping(Vec3(0));
-    constructProperty_translational_damping(Vec3(0));
+    constructProperty_rotational_damping(SimTK::Vec3(0));
+    constructProperty_translational_damping(SimTK::Vec3(0));
     
     constructProperty_moment_visual_scale( 1.0 );
     constructProperty_force_visual_scale( 1.0 );
@@ -177,9 +176,9 @@ SimTK::Vec6 FunctionBasedBushingForce::
 {
     // Calculate stiffness generalized forces of bushing by first computing
     // the deviation of the two frames measured by dq
-    Vec6 dq = computeDeflection(s);
+    SimTK::Vec6 dq = computeDeflection(s);
 
-    Vec6 fk = Vec6(0.0);
+    SimTK::Vec6 fk = SimTK::Vec6(0.0);
     fk[0] = get_m_x_theta_x_function().calcValue(SimTK::Vector(1, dq[0]));
     fk[1] = get_m_y_theta_y_function().calcValue(SimTK::Vector(1, dq[1]));
     fk[2] = get_m_z_theta_z_function().calcValue(SimTK::Vector(1, dq[2]));
@@ -194,7 +193,7 @@ SimTK::Vec6 FunctionBasedBushingForce::
 SimTK::Vec6 FunctionBasedBushingForce::
     calcDampingForce(const SimTK::State& s) const
 {
-    Vec6 dqdot = computeDeflectionRate(s);
+    SimTK::Vec6 dqdot = computeDeflectionRate(s);
     // _dampingMatrix is initialized from Properties in extendFinalizeFromProperties (issue #2512)
     return -_dampingMatrix * dqdot;
 }
@@ -204,12 +203,12 @@ void FunctionBasedBushingForce::implProduceForces(
     ForceConsumer& forceConsumer) const
 {
     // stiffness force
-    Vec6 fk = calcStiffnessForce(s);
+    SimTK::Vec6 fk = calcStiffnessForce(s);
     // damping force
-    Vec6 fv = calcDampingForce(s);
+    SimTK::Vec6 fv = calcDampingForce(s);
 
     // total bushing force in the internal basis of the deflection (dq) 
-    Vec6 f = fk + fv;
+    SimTK::Vec6 f = fk + fv;
 
     // convert internal forces to spatial and add then add to system
     // physical (body) forces
@@ -250,11 +249,11 @@ OpenSim::Array<std::string> FunctionBasedBushingForce::getRecordLabels() const
 OpenSim::Array<double> FunctionBasedBushingForce::
     getRecordValues(const SimTK::State& s) const 
 {
-    SpatialVec F_GM( Vec3(0.0),Vec3(0.0) );
-    SpatialVec F_GF( Vec3(0.0),Vec3(0.0) );
+    SimTK::SpatialVec F_GM( SimTK::Vec3(0.0),SimTK::Vec3(0.0) );
+    SimTK::SpatialVec F_GF( SimTK::Vec3(0.0),SimTK::Vec3(0.0) );
 
     // total bushing force in the internal basis of the deflection (dq) 
-    Vec6 f = calcStiffnessForce(s) + calcDampingForce(s);
+    SimTK::Vec6 f = calcStiffnessForce(s) + calcDampingForce(s);
     
     convertInternalForceToForcesOnFrames(s, f, F_GF, F_GM);
 
@@ -313,12 +312,12 @@ void FunctionBasedBushingForce::generateDecorations(
 
         // if the model is moving and the state is adequately realized,
         // calculate and draw the bushing forces.
-        if (!fixed && (s.getSystemStage() >= Stage::Dynamics)) {
-            SpatialVec F_GM(Vec3(0.0), Vec3(0.0));
-            SpatialVec F_GF(Vec3(0.0), Vec3(0.0));
+        if (!fixed && (s.getSystemStage() >= SimTK::Stage::Dynamics)) {
+            SimTK::SpatialVec F_GM(SimTK::Vec3(0.0), SimTK::Vec3(0.0));
+            SimTK::SpatialVec F_GF(SimTK::Vec3(0.0), SimTK::Vec3(0.0));
 
             // total bushing force in the internal basis of the deflection (dq) 
-            Vec6 f = calcStiffnessForce(s) + calcDampingForce(s);
+            SimTK::Vec6 f = calcStiffnessForce(s) + calcDampingForce(s);
 
             convertInternalForceToForcesOnFrames(s, f, F_GF, F_GM);
 
@@ -347,4 +346,4 @@ void FunctionBasedBushingForce::generateDecorations(
 
             geometryArray.push_back(frame2Force);
         }
-    }
+    }
\ No newline at end of file
diff --git a/OpenSim/Simulation/Model/Model.h b/OpenSim/Simulation/Model/Model.h
index c11bffd11..3dec18c60 100644
--- a/OpenSim/Simulation/Model/Model.h
+++ b/OpenSim/Simulation/Model/Model.h
@@ -939,8 +939,8 @@ public:
             const SimTK::Array_<SimTK::ForceIndex>& forceIndexes,
             SimTK::Vector_<SimTK::SpatialVec>& bodyForces,
             SimTK::Vector& mobilityForces) const {
-        getForceSubsystem().calcForceContributionsSum(
-            state, forceIndexes, bodyForces, mobilityForces);
+        //getForceSubsystem().calcForceContributionsSum(
+        //    state, forceIndexes, bodyForces, mobilityForces); //not available in this version of simbody
     }
 
     int getNumMuscleStates() const;
diff --git a/OpenSim/Simulation/Model/Probe.cpp b/OpenSim/Simulation/Model/Probe.cpp
index 3dac76fae..a5aa884df 100644
--- a/OpenSim/Simulation/Model/Probe.cpp
+++ b/OpenSim/Simulation/Model/Probe.cpp
@@ -25,18 +25,15 @@
 #include "OpenSim/Common/XMLDocument.h"
 
 using namespace std;
-using namespace SimTK;
-
-
-//This Measure returns a probe value only at the Acceleration stage
+//This SimTK::Measure returns a probe value only at the Acceleration stage
 template <class T>
 class ProbeMeasure : public SimTK::Measure_<T> {
 public:
-    SimTK_MEASURE_HANDLE_PREAMBLE(ProbeMeasure, Measure_<T>);
+    SimTK_MEASURE_HANDLE_PREAMBLE(ProbeMeasure, SimTK::Measure_<T>);
  
-    ProbeMeasure(Subsystem& sub, const OpenSim::Probe& probe, int index)
-    :   SimTK::Measure_<T>(sub, new Implementation(probe, index), AbstractMeasure::SetHandle()) {}
-    SimTK_MEASURE_HANDLE_POSTSCRIPT(ProbeMeasure, Measure_<T>);
+    ProbeMeasure(SimTK::Subsystem& sub, const OpenSim::Probe& probe, int index)
+    :   SimTK::Measure_<T>(sub, new Implementation(probe, index), SimTK::AbstractMeasure::SetHandle()) {}
+    SimTK_MEASURE_HANDLE_POSTSCRIPT(ProbeMeasure, SimTK::Measure_<T>);
 };
  
  
@@ -57,11 +54,11 @@ public:
         return 0;
     }
 
-    Stage getDependsOnStageVirtual(int order) const override {   
-        return Stage::Acceleration; 
+    SimTK::Stage getDependsOnStageVirtual(int order) const override {   
+        return SimTK::Stage::Acceleration; 
     }
  
-    void calcCachedValueVirtual(const State& s, int derivOrder, T& value) const
+    void calcCachedValueVirtual(const SimTK::State& s, int derivOrder, T& value) const
         override
     {
         SimTK_ASSERT1_ALWAYS(derivOrder==0,
@@ -79,7 +76,7 @@ private:
 
 
 template <>
-void ProbeMeasure<double>::Implementation::calcCachedValueVirtual(const State& s, int derivOrder, double& value) const
+void ProbeMeasure<double>::Implementation::calcCachedValueVirtual(const SimTK::State& s, int derivOrder, double& value) const
 {
     SimTK_ASSERT1_ALWAYS(derivOrder==0,
         "ProbeMeasure::Implementation::calcCachedValueVirtual():"
@@ -141,7 +138,7 @@ void Probe::extendConnectToModel(Model& model)
 /**
  * Create the underlying system component(s).
  */
-void Probe::extendAddToSystem(MultibodySystem& system) const
+void Probe::extendAddToSystem(SimTK::MultibodySystem& system) const
 {
     Super::extendAddToSystem(system);
 
@@ -149,15 +146,15 @@ void Probe::extendAddToSystem(MultibodySystem& system) const
         return;
 
     // Make writable briefly so we can finalize the Probe to include 
-    // references to the allocated System resources.
+    // references to the allocated SimTK::System resources.
     Probe* mutableThis = const_cast<Probe*>(this);
 
     // ---------------------------------------------------------------------
-    // Create a <double> Measure of the value to be probed (operand).
-    // For now, this is scalarized, i.e. a separate Measure is created
-    // for each probe input element in the Vector.
+    // Create a <double> SimTK::Measure of the value to be probed (operand).
+    // For now, this is scalarized, i.e. a separate SimTK::Measure is created
+    // for each probe input element in the SimTK::Vector.
     // ---------------------------------------------------------------------
-    // save for when we can directly operate on Vector SimTK::Measures
+    // save for when we can directly operate on SimTK::Vector SimTK::Measures
     //ProbeMeasure<SimTK::Vector> beforeOperationValueVector(system, *this);
 
     int npi = getNumProbeInputs();
@@ -169,7 +166,7 @@ void Probe::extendAddToSystem(MultibodySystem& system) const
         beforeOperationValues.push_back(tmpPM);
     }
 
-    // Assign the correct (operation) Measure subclass to the operand
+    // Assign the correct (operation) SimTK::Measure subclass to the operand
     // ==============================================================
 
     // ---------------------------------------------------------------------
@@ -206,9 +203,9 @@ void Probe::extendAddToSystem(MultibodySystem& system) const
         }
 
         for (int i=0; i<getNumProbeInputs(); ++i) {
-            //Measure::Constant initCond(system, getInitialConditions()(i));  // init cond is handled as a special case in getProbeOutputs()
-            Measure::Constant initCond(system, 0.0);
-            mutableThis->afterOperationValues[i] = Measure::Integrate(
+            //SimTK::Measure::Constant initCond(system, getInitialConditions()(i));  // init cond is handled as a special case in getProbeOutputs()
+            SimTK::Measure::Constant initCond(system, 0.0);
+            mutableThis->afterOperationValues[i] = SimTK::Measure::Integrate(
                 system, beforeOperationValues[i], initCond);
         }
     }
@@ -219,7 +216,7 @@ void Probe::extendAddToSystem(MultibodySystem& system) const
     // ---------------------------------------------------------------------
     else if (getOperation() == "differentiate") {
         for (int i=0; i<getNumProbeInputs(); ++i) {
-            mutableThis->afterOperationValues[i] = Measure::Differentiate(
+            mutableThis->afterOperationValues[i] = SimTK::Measure::Differentiate(
                 system, beforeOperationValues[i]);
         }
     }
@@ -228,7 +225,7 @@ void Probe::extendAddToSystem(MultibodySystem& system) const
     // ---------------------------------------------------------------------
     else if (getOperation() == "minimum") {
         for (int i=0; i<getNumProbeInputs(); ++i) {
-            mutableThis->afterOperationValues[i] = Measure::Minimum(
+            mutableThis->afterOperationValues[i] = SimTK::Measure::Minimum(
                 system, beforeOperationValues[i]);
         }
     }
@@ -237,7 +234,7 @@ void Probe::extendAddToSystem(MultibodySystem& system) const
     // ---------------------------------------------------------------------
     else if (getOperation() == "minabs") {
         for (int i=0; i<getNumProbeInputs(); ++i) {
-            mutableThis->afterOperationValues[i] = Measure::MinAbs(
+            mutableThis->afterOperationValues[i] = SimTK::Measure::MinAbs(
                 system, beforeOperationValues[i]);
         }
     }
@@ -246,7 +243,7 @@ void Probe::extendAddToSystem(MultibodySystem& system) const
     // ---------------------------------------------------------------------
     else if (getOperation() == "maximum") {
         for (int i=0; i<getNumProbeInputs(); ++i) {
-            mutableThis->afterOperationValues[i] = Measure::Maximum(
+            mutableThis->afterOperationValues[i] = SimTK::Measure::Maximum(
                 system, beforeOperationValues[i]);
         }
     }
@@ -256,7 +253,7 @@ void Probe::extendAddToSystem(MultibodySystem& system) const
     // ---------------------------------------------------------------------
     else if (getOperation() == "maxabs") {
         for (int i=0; i<getNumProbeInputs(); ++i) {
-            mutableThis->afterOperationValues[i] = Measure::MaxAbs(
+            mutableThis->afterOperationValues[i] = SimTK::Measure::MaxAbs(
                 system, beforeOperationValues[i]);
         }
     }
@@ -288,7 +285,7 @@ void Probe::reset(SimTK::State& s)
     for (int i=0; i<getNumProbeInputs(); ++i) {
         if (isEnabled()) {
             //cout << "Resetting probe " << getName() << ",  (" << i << " / " << getNumProbeInputs() << ")." << endl;
-            //const Measure::Scale& scaleMeasure = Measure::Scale::getAs(afterOperationValues[i]);
+            //const SimTK::Measure::Scale& scaleMeasure = SimTK::Measure::Scale::getAs(afterOperationValues[i]);
 
             if (getOperation() == "integrate")
                 SimTK::Measure::Integrate::getAs(afterOperationValues[i]).setValue(s, resetValue);
@@ -341,10 +338,10 @@ string Probe::getOperation() const
  *
  * @return initial_conditions_for_integration SimTK::Vector
  */
-Vector Probe::getInitialConditions() const
+SimTK::Vector Probe::getInitialConditions() const
 {
     int size = getProperty_initial_conditions_for_integration().size();
-    Vector v(size);
+    SimTK::Vector v(size);
     for(int i = 0; i < size ; i++)
     {
         v[i] = get_initial_conditions_for_integration(i);
@@ -389,7 +386,7 @@ void Probe::setOperation(string probe_operation)
  * Sets the initial_conditions_for_integration.
  *
  */
-void Probe::setInitialConditions(Vector initial_conditions_for_integration) 
+void Probe::setInitialConditions(SimTK::Vector initial_conditions_for_integration) 
 {
     set_initial_conditions_for_integration(initial_conditions_for_integration);
 }
@@ -412,7 +409,7 @@ void Probe::setGain(double gain)
 /**
  * Provide the probe values to be reported that correspond to the probe labels.
  */
-SimTK::Vector Probe::getProbeOutputs(const State& s) const 
+SimTK::Vector Probe::getProbeOutputs(const SimTK::State& s) const 
 {
     if (!isEnabled()) {
         stringstream errorMessage;
@@ -424,7 +421,7 @@ SimTK::Vector Probe::getProbeOutputs(const State& s) const
 
 
     // For now, this is scalarized, i.e. compile the result of the separate
-    // Measure for each scalar element of the probe input into a SimTK::Vector
+    // SimTK::Measure for each scalar element of the probe input into a SimTK::Vector
     // of outputs.
     SimTK::Vector output(getNumProbeInputs());
     for (int i=0; i<getNumProbeInputs(); ++i) {
@@ -436,7 +433,7 @@ SimTK::Vector Probe::getProbeOutputs(const State& s) const
     
     return output;
 
-    //return afterOperationValueVector.getValue(s);         // save for when we can directly operate on Vector SimTK::Measures
+    //return afterOperationValueVector.getValue(s);         // save for when we can directly operate on SimTK::Vector SimTK::Measures
 }
 
 
@@ -481,4 +478,4 @@ void Probe::updateFromXMLNode(SimTK::Xml::Element& node,
     Super::updateFromXMLNode(node, versionNumber);
 }
 
-} // end of namespace OpenSim
+} // end of namespace OpenSim
\ No newline at end of file
diff --git a/OpenSim/Simulation/OrientationsReference.cpp b/OpenSim/Simulation/OrientationsReference.cpp
index d26e0624d..15d0f10a8 100644
--- a/OpenSim/Simulation/OrientationsReference.cpp
+++ b/OpenSim/Simulation/OrientationsReference.cpp
@@ -27,8 +27,6 @@
 #include <SimTKcommon/internal/State.h>
 
 using namespace std;
-using namespace SimTK;
-
 namespace OpenSim {
 
 OrientationsReference::OrientationsReference()
@@ -45,7 +43,7 @@ OrientationsReference::OrientationsReference(const std::string& orientationFile,
 
 
 OrientationsReference::OrientationsReference(
-    const TimeSeriesTable_<Rotation>& orientationData,
+    const TimeSeriesTable_<SimTK::Rotation>& orientationData,
     const Set<OrientationWeight>* orientationWeightSet) 
         : OrientationsReference()
 {
@@ -61,7 +59,7 @@ void OrientationsReference::loadOrientationsEulerAnglesFile(
 {
     upd_orientation_file() = orientationFile;
 
-    auto xyzEulerData = TimeSeriesTable_<Vec3>(orientationFile);
+    auto xyzEulerData = TimeSeriesTable_<SimTK::Vec3>(orientationFile);
 
     _orientationData.updTableMetaData() = xyzEulerData.getTableMetaData();
     _orientationData.setDependentsMetaData(xyzEulerData.getDependentsMetaData());
@@ -71,14 +69,14 @@ void OrientationsReference::loadOrientationsEulerAnglesFile(
     size_t nt = xyzEulerData.getNumRows();
     int nc = int(xyzEulerData.getNumColumns());
 
-    RowVector_<Rotation> row(nc);
+    SimTK::RowVector_<SimTK::Rotation> row(nc);
 
     for (size_t i = 0; i < nt; ++i) {
         const auto& xyzRow = xyzEulerData.getRowAtIndex(i);
         for (int j = 0; j < nc; ++j) {
-            const Vec3& xyzO = xyzRow[j];
-            row[j] = Rotation(BodyOrSpaceType::BodyRotationSequence,
-                xyzO[0], XAxis, xyzO[1], YAxis, xyzO[2], ZAxis);
+            const SimTK::Vec3& xyzO = xyzRow[j];
+            row[j] = SimTK::Rotation(SimTK::BodyOrSpaceType::BodyRotationSequence,
+                xyzO[0], SimTK::XAxis, xyzO[1], SimTK::XAxis, xyzO[2], SimTK::XAxis);
         }
         _orientationData.appendRow(times[i], row);
     }
@@ -130,7 +128,7 @@ double OrientationsReference::getSamplingFrequency() const
 SimTK::Vec2 OrientationsReference::getValidTimeRange() const
 {
     auto& times = _orientationData.getIndependentColumn();
-    return Vec2(*times.begin(), *(--times.end()));
+    return SimTK::Vec2(*times.begin(), *(--times.end()));
 }
 
 const std::vector<double>& OrientationsReference::getTimes() const
@@ -156,11 +154,11 @@ const SimTK::Array_<std::string>& OrientationsReference::getNames() const
 
 /** get the values of the OrientationsReference */
 void OrientationsReference::getValuesAtTime(
-        double time, SimTK::Array_<Rotation> &values) const
+        double time, SimTK::Array_<SimTK::Rotation> &values) const
 {
 
     // get values for time
-    SimTK::RowVector_<Rotation> row = _orientationData.getRow(time);
+    SimTK::RowVector_<SimTK::Rotation> row = _orientationData.getRow(time);
 
     int n = row.size();
     values.resize(n);
diff --git a/OpenSim/Simulation/RegisterTypes_osimSimulation.cpp b/OpenSim/Simulation/RegisterTypes_osimSimulation.cpp
index 68a8f59e5..f04740494 100644
--- a/OpenSim/Simulation/RegisterTypes_osimSimulation.cpp
+++ b/OpenSim/Simulation/RegisterTypes_osimSimulation.cpp
@@ -47,7 +47,7 @@
 #include "Model/CoordinateLimitForce.h"
 #include "Model/CoordinateSet.h"
 #include "Model/ElasticFoundationForce.h"
-#include "Model/ExponentialContactForce.h"
+//#include "Model/ExponentialContactForce.h" ##TODO:newer simbody?
 #include "Model/HuntCrossleyForce.h"
 #include "Model/SmoothSphereHalfSpaceForce.h"
 #include "Model/Ligament.h"
@@ -251,8 +251,8 @@ OSIMSIMULATION_API void RegisterTypes_osimSimulation()
     Object::registerType( ContactTorus() );
     Object::registerType( CoordinateLimitForce() );
     Object::registerType( SmoothSphereHalfSpaceForce() );
-    Object::registerType( ExponentialContactForce() );
-    Object::registerType( ExponentialContactForce::Parameters() );
+    //Object::registerType( ExponentialContactForce() ); TODO: newer simbody
+    //Object::registerType( ExponentialContactForce::Parameters() );
     Object::registerType( HuntCrossleyForce() );
     Object::registerType( ElasticFoundationForce() );
     Object::registerType( HuntCrossleyForce::ContactParameters() );
diff --git a/OpenSim/Simulation/SimbodyEngine/Body.cpp b/OpenSim/Simulation/SimbodyEngine/Body.cpp
index 71dc8cd05..9e4d39cc0 100644
--- a/OpenSim/Simulation/SimbodyEngine/Body.cpp
+++ b/OpenSim/Simulation/SimbodyEngine/Body.cpp
@@ -180,10 +180,9 @@ void Body::setInertia(const SimTK::Inertia& inertia)
     upd_inertia()[4] = I[0][2];
     upd_inertia()[5] = I[1][2];
 }
-
 SimTK::SpatialVec Body::calcMomentumAboutOrigin(const SimTK::State& s) const {
     const SimTK::MobilizedBody& mobod = getMobilizedBody();
-    return mobod.calcBodyMomentumAboutBodyOriginInGround(s);
+    return const_cast<SimTK::MobilizedBody&>(mobod).calcBodyMomentumAboutBodyOriginInGround(s);
 }
 
 SimTK::Vec3 Body::calcAngularMomentumAboutOrigin(const SimTK::State& s) const {
diff --git a/OpenSim/Simulation/SimbodyEngine/CoordinateCouplerConstraint.cpp b/OpenSim/Simulation/SimbodyEngine/CoordinateCouplerConstraint.cpp
index 8dd39eb6a..44d0ca1f3 100644
--- a/OpenSim/Simulation/SimbodyEngine/CoordinateCouplerConstraint.cpp
+++ b/OpenSim/Simulation/SimbodyEngine/CoordinateCouplerConstraint.cpp
@@ -160,7 +160,6 @@ public:
 // STATICS
 //=============================================================================
 using namespace std;
-using namespace SimTK;
 using namespace OpenSim;
 
 //=============================================================================
@@ -321,9 +320,9 @@ extendScale(const SimTK::State& s, const ScaleSet& scaleSet)
     if (depCoordinate.getMotionType() != Coordinate::Translational)
         return;
 
-    // Get scale factors (if there exists an entry for the base Body of the
+    // Get scale factors (if there exists an entry for the base SimTK::Body of the
     // Joint's parent Frame).
-    const Vec3& scaleFactors =
+    const SimTK::Vec3& scaleFactors =
         getScaleFactors(scaleSet, depCoordinate.getJoint().getParentFrame());
     if (scaleFactors == ModelComponent::InvalidScaleFactors)
         return;
@@ -344,4 +343,4 @@ extendScale(const SimTK::State& s, const ScaleSet& scaleSet)
     }
 
     upd_scale_factor() *= scaleFactor;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/SimbodyEngine/EllipsoidJoint.cpp b/OpenSim/Simulation/SimbodyEngine/EllipsoidJoint.cpp
index 9cffa2e93..9da65911f 100644
--- a/OpenSim/Simulation/SimbodyEngine/EllipsoidJoint.cpp
+++ b/OpenSim/Simulation/SimbodyEngine/EllipsoidJoint.cpp
@@ -32,7 +32,6 @@
 // STATICS
 //==============================================================================
 using namespace std;
-using namespace SimTK;
 using namespace OpenSim;
 
 //==============================================================================
@@ -80,7 +79,7 @@ EllipsoidJoint::EllipsoidJoint(const std::string&    name,
 void EllipsoidJoint::constructProperties()
 {
     setAuthors("Ajay Seth");
-    SimTK::Vec3 radii(NaN);
+    SimTK::Vec3 radii(SimTK::NaN);
     constructProperty_radii_x_y_z(radii);
 
     Appearance appearance;
@@ -94,11 +93,11 @@ void EllipsoidJoint::constructProperties()
 //_____________________________________________________________________________
 /**
  * Set the EllipsoidJoint's radii. If the system is created, will attempt
- * to update the default radii of the underlying MobilizedBody::Ellipsoid
+ * to update the default radii of the underlying SimTK::MobilizedBody::Ellipsoid
  *
- * @param Vec3 of radii: X, Y, Z in the parent frame.
+ * @param SimTK::Vec3 of radii: X, Y, Z in the parent frame.
  */
-void EllipsoidJoint::setEllipsoidRadii(const Vec3& radii)
+void EllipsoidJoint::setEllipsoidRadii(const SimTK::Vec3& radii)
 {
     set_radii_x_y_z(radii);
 }
@@ -111,8 +110,8 @@ extendScale(const SimTK::State& s, const ScaleSet& scaleSet)
 {
     Super::extendScale(s, scaleSet);
 
-    // Get scale factors (if an entry for the parent Frame's base Body exists).
-    const Vec3& scaleFactors = getScaleFactors(scaleSet, getParentFrame());
+    // Get scale factors (if an entry for the parent Frame's base SimTK::Body exists).
+    const SimTK::Vec3& scaleFactors = getScaleFactors(scaleSet, getParentFrame());
     if (scaleFactors == ModelComponent::InvalidScaleFactors)
         return;
 
@@ -128,8 +127,8 @@ void EllipsoidJoint::extendAddToSystem(SimTK::MultibodySystem& system) const
 {
     Super::extendAddToSystem(system);
     // CREATE MOBILIZED BODY
-    MobilizedBody::Ellipsoid mobod =
-        createMobilizedBody<MobilizedBody::Ellipsoid>(system);
+    SimTK::MobilizedBody::Ellipsoid mobod =
+        createMobilizedBody<SimTK::MobilizedBody::Ellipsoid>(system);
     mobod.setDefaultRadii(get_radii_x_y_z());
 }
 
@@ -137,14 +136,14 @@ void EllipsoidJoint::extendInitStateFromProperties(SimTK::State& s) const
 {
     Super::extendInitStateFromProperties(s);
 
-    const SimbodyMatterSubsystem& matter = getModel().getMatterSubsystem();
+    const SimTK::SimbodyMatterSubsystem& matter = getModel().getMatterSubsystem();
     
     if (!matter.getUseEulerAngles(s)){
         double xangle = getCoordinate(EllipsoidJoint::Coord::Rotation1X).getDefaultValue();
         double yangle = getCoordinate(EllipsoidJoint::Coord::Rotation2Y).getDefaultValue();
         double zangle = getCoordinate(EllipsoidJoint::Coord::Rotation3Z).getDefaultValue();
-        Rotation r(BodyRotationSequence, xangle, XAxis, 
-                                         yangle, YAxis, zangle, ZAxis);
+        SimTK::Rotation r(SimTK::BodyRotationSequence, xangle, SimTK::XAxis, 
+                                         yangle, SimTK::YAxis, zangle, SimTK::YAxis);
 
         //EllipsoidJoint* mutableThis = const_cast<EllipsoidJoint*>(this);
         getChildFrame().getMobilizedBody().setQToFitRotation(s, r);
@@ -156,11 +155,11 @@ void EllipsoidJoint::extendSetPropertiesFromState(const SimTK::State& state)
     Super::extendSetPropertiesFromState(state);
 
     // Override default in case of quaternions.
-    const SimbodyMatterSubsystem& matter = getModel().getMatterSubsystem();
+    const SimTK::SimbodyMatterSubsystem& matter = getModel().getMatterSubsystem();
     if (!matter.getUseEulerAngles(state)) {
 
-        Rotation r = getChildFrame().getMobilizedBody().getBodyRotation(state);
-        Vec3 angles = r.convertRotationToBodyFixedXYZ();
+        SimTK::Rotation r = getChildFrame().getMobilizedBody().getBodyRotation(state);
+        SimTK::Vec3 angles = r.convertRotationToBodyFixedXYZ();
 
         updCoordinate(EllipsoidJoint::Coord::Rotation1X).setDefaultValue(angles[0]);
         updCoordinate(EllipsoidJoint::Coord::Rotation2Y).setDefaultValue(angles[1]);
@@ -183,8 +182,8 @@ void EllipsoidJoint::generateDecorations
     if (!get_Appearance().get_visible()) return;
     SimTK::DecorativeEllipsoid ellipsoid(get_radii_x_y_z());
     const OpenSim::PhysicalFrame& frame = getParentFrame();
-    ellipsoid.setColor(Vec3(0.0, 1.0, 1.0));
+    ellipsoid.setColor(SimTK::Vec3(0.0, 1.0, 1.0));
     ellipsoid.setBodyId(frame.getMobilizedBodyIndex());
     ellipsoid.setTransform(frame.findTransformInBaseFrame());
     geometryArray.push_back(ellipsoid);
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/SimbodyEngine/GimbalJoint.cpp b/OpenSim/Simulation/SimbodyEngine/GimbalJoint.cpp
index cc75b28d6..fd5d6c18b 100644
--- a/OpenSim/Simulation/SimbodyEngine/GimbalJoint.cpp
+++ b/OpenSim/Simulation/SimbodyEngine/GimbalJoint.cpp
@@ -32,7 +32,6 @@
 // STATICS
 //=============================================================================
 using namespace std;
-using namespace SimTK;
 using namespace OpenSim;
 
 //=============================================================================
@@ -42,22 +41,22 @@ using namespace OpenSim;
 void GimbalJoint::extendAddToSystem(SimTK::MultibodySystem& system) const
 {
     Super::extendAddToSystem(system);
-    createMobilizedBody<MobilizedBody::Gimbal>(system);
+    createMobilizedBody<SimTK::MobilizedBody::Gimbal>(system);
 }
 
 void GimbalJoint::extendInitStateFromProperties(SimTK::State& s) const
 {
     Super::extendInitStateFromProperties(s);
 
-    const MultibodySystem& system = _model->getMultibodySystem();
-    const SimbodyMatterSubsystem& matter = system.getMatterSubsystem();
+    const SimTK::MultibodySystem& system = _model->getMultibodySystem();
+    const SimTK::SimbodyMatterSubsystem& matter = system.getMatterSubsystem();
     if (matter.getUseEulerAngles(s))
         return;
 
     double xangle = getCoordinate(GimbalJoint::Coord::Rotation1X).getDefaultValue();
     double yangle = getCoordinate(GimbalJoint::Coord::Rotation2Y).getDefaultValue();
     double zangle = getCoordinate(GimbalJoint::Coord::Rotation3Z).getDefaultValue();
-    Rotation r(BodyRotationSequence, xangle, XAxis, yangle, YAxis, zangle, ZAxis);
+    SimTK::Rotation r(SimTK::BodyRotationSequence, xangle, SimTK::XAxis, yangle, SimTK::XAxis, zangle, SimTK::XAxis);
 
     //GimbalJoint* mutableThis = const_cast<GimbalJoint*>(this);
     getChildFrame().getMobilizedBody().setQToFitRotation(s, r);
@@ -68,14 +67,14 @@ void GimbalJoint::extendSetPropertiesFromState(const SimTK::State& state)
     Super::extendSetPropertiesFromState(state);
 
     // Override default behavior in case of quaternions.
-    const MultibodySystem&        system = _model->getMultibodySystem();
-    const SimbodyMatterSubsystem& matter = system.getMatterSubsystem();
+    const SimTK::MultibodySystem&        system = _model->getMultibodySystem();
+    const SimTK::SimbodyMatterSubsystem& matter = system.getMatterSubsystem();
     if (!matter.getUseEulerAngles(state)) {
-        Rotation r = getChildFrame().getMobilizedBody().getBodyRotation(state);
+        SimTK::Rotation r = getChildFrame().getMobilizedBody().getBodyRotation(state);
 
-        Vec3 angles = r.convertRotationToBodyFixedXYZ();
+        SimTK::Vec3 angles = r.convertRotationToBodyFixedXYZ();
         updCoordinate(GimbalJoint::Coord::Rotation1X).setDefaultValue(angles[0]);
         updCoordinate(GimbalJoint::Coord::Rotation2Y).setDefaultValue(angles[1]);
         updCoordinate(GimbalJoint::Coord::Rotation3Z).setDefaultValue(angles[2]);
     }
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/SimbodyEngine/Joint.cpp b/OpenSim/Simulation/SimbodyEngine/Joint.cpp
index eea104586..b24158c56 100644
--- a/OpenSim/Simulation/SimbodyEngine/Joint.cpp
+++ b/OpenSim/Simulation/SimbodyEngine/Joint.cpp
@@ -36,7 +36,6 @@
 // STATICS
 //==============================================================================
 using namespace std;
-using namespace SimTK;
 using namespace OpenSim;
 
 //==============================================================================
@@ -76,10 +75,10 @@ Joint::Joint(const std::string&    name,
     setName(name);
 
     // PARENT TRANSFORM
-    Rotation parentRotation(BodyRotationSequence,
-        orientationInParent[0], XAxis,
-        orientationInParent[1], YAxis,
-        orientationInParent[2], ZAxis);
+    SimTK::Rotation parentRotation(SimTK::BodyRotationSequence,
+        orientationInParent[0], SimTK::XAxis,
+        orientationInParent[1], SimTK::YAxis,
+        orientationInParent[2], SimTK::ZAxis);
     SimTK::Transform parentTransform(parentRotation, locationInParent);
 
     // Define the offset frame that the joint connects to in the parent
@@ -91,10 +90,10 @@ Joint::Joint(const std::string&    name,
     int pix = append_frames(pInPo);
 
     // CHILD TRANSFORM
-    Rotation childRotation(BodyRotationSequence,
-        orientationInChild[0], XAxis,
-        orientationInChild[1], YAxis,
-        orientationInChild[2], ZAxis);
+    SimTK::Rotation childRotation(SimTK::BodyRotationSequence,
+        orientationInChild[0], SimTK::XAxis,
+        orientationInChild[1], SimTK::YAxis,
+        orientationInChild[2], SimTK::ZAxis);
     SimTK::Transform childTransform(childRotation, locationInChild);
 
     PhysicalOffsetFrame cInCo( child.getName() + "_offset",
@@ -344,7 +343,7 @@ SimTK::SpatialVec Joint::calcEquivalentSpatialForce(const SimTK::State &s,
     std::set<SimTK::MobilizedBodyIndex> mbds;
 
     for(int i = 0; i < numCoordinates(); ++i) {
-        const MobilizedBodyIndex& coordsMbx = get_coordinates(i).getBodyIndex();
+        const SimTK::MobilizedBodyIndex& coordsMbx = get_coordinates(i).getBodyIndex();
         if (coordsMbx != mbx){
             mbds.insert(coordsMbx);
         }
@@ -484,7 +483,7 @@ SimTK::SpatialVec Joint::calcEquivalentSpatialForceForMobilizedBody(const SimTK:
     }
 
     // The spatial forces above are expressed in the joint frame of the parent
-    // Transform from parent joint frame, P into the parent body frame, Po
+    // SimTK::Transform from parent joint frame, P into the parent body frame, Po
     const SimTK::Rotation R_PPo = (mbd.getInboardFrame(s).R());
 
     // Re-express forces in ground, first by describing force in the parent, Po, 
@@ -492,10 +491,10 @@ SimTK::SpatialVec Joint::calcEquivalentSpatialForceForMobilizedBody(const SimTK:
     SimTK::Vec3 vecFw = R_PPo*SimTK::Vec3::getAs(&Fw[0]);
     SimTK::Vec3 vecFv = R_PPo*SimTK::Vec3::getAs(&Fv[0]);
 
-    //Force Acting on joint frame, B,  in child body expressed in Parent body, Po
+    //SimTK::Force Acting on joint frame, B,  in child body expressed in Parent body, Po
     SimTK::SpatialVec FB_Po(vecFw, vecFv);
 
-    const MobilizedBody parent = mbd.getParentMobilizedBody();
+    const SimTK::MobilizedBody parent = mbd.getParentMobilizedBody();
     // to apply spatial forces on bodies they must be expressed in ground
     vecFw = parent.expressVectorInAnotherBodyFrame(s, FB_Po[0], ground);
     vecFv = parent.expressVectorInAnotherBodyFrame(s, FB_Po[1], ground);
@@ -572,22 +571,22 @@ void Joint::updateFromXMLNode(SimTK::Xml::Element& aNode, int versionNumber)
             SimTK::Xml::element_iterator orientChildElt =
                 aNode.element_begin("orientation_in_child");
 
-            Vec3 location_in_parent(0);
-            Vec3 orientation_in_parent(0);
-            Vec3 location_in_child(0);
-            Vec3 orientation_in_child(0);
+            SimTK::Vec3 location_in_parent(0);
+            SimTK::Vec3 orientation_in_parent(0);
+            SimTK::Vec3 location_in_child(0);
+            SimTK::Vec3 orientation_in_child(0);
 
             if (locParentElt != aNode.element_end()){
-                locParentElt->getValueAs<Vec3>(location_in_parent);
+                locParentElt->getValueAs<SimTK::Vec3>(location_in_parent);
             }
             if (orientParentElt != aNode.element_end()){
-                orientParentElt->getValueAs<Vec3>(orientation_in_parent);
+                orientParentElt->getValueAs<SimTK::Vec3>(orientation_in_parent);
             }
             if (locChildElt != aNode.element_end()){
-                locChildElt->getValueAs<Vec3>(location_in_child);
+                locChildElt->getValueAs<SimTK::Vec3>(location_in_child);
             }
             if (orientChildElt != aNode.element_end()){
-                orientChildElt->getValueAs<Vec3>(orientation_in_child);
+                orientChildElt->getValueAs<SimTK::Vec3>(orientation_in_child);
             }
 
             // now append updated frames to the property list for
@@ -615,7 +614,7 @@ void Joint::updateFromXMLNode(SimTK::Xml::Element& aNode, int versionNumber)
                         // at least one "Coordinate" element.
 
                         // Create an element for the new layout.
-                        Xml::Element coordinatesElement("coordinates");
+                        SimTK::Xml::Element coordinatesElement("coordinates");
                         // Copy all "Coordinate" elements from the old layout.
                         while (coordIter != aNode.element_end()) {
                             coordinatesElement.appendNode(coordIter->clone());
@@ -762,7 +761,7 @@ int Joint::assignSystemIndicesToBodyAndCoordinates(
         }
         else{
             std::string msg = getConcreteClassName() +
-                " creating MobilizedBody with more mobilities than declared Coordinates.";
+                " creating SimTK::MobilizedBody with more mobilities than declared Coordinates.";
             throw Exception(msg);
         }
     }
@@ -771,7 +770,7 @@ int Joint::assignSystemIndicesToBodyAndCoordinates(
 
 /* Return the equivalent (internal) SimTK::Rigid::Body for a given parent OR
 child OpenSim::Body. Not guaranteed to be valid until after addToSystem on
-Body has be called  */
+SimTK::Body has be called  */
 const SimTK::Body& Joint::getParentInternalRigidBody() const
 {
     if (_slaveBodyForParent){
@@ -789,4 +788,4 @@ const SimTK::Body& Joint::getChildInternalRigidBody() const
 
     return static_cast<const PhysicalFrame&>(getChildFrame()
         .findBaseFrame()).extractInternalRigidBody();;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/SimbodyEngine/PinJoint.cpp b/OpenSim/Simulation/SimbodyEngine/PinJoint.cpp
index 5ee79b3e0..6b79cdb8e 100644
--- a/OpenSim/Simulation/SimbodyEngine/PinJoint.cpp
+++ b/OpenSim/Simulation/SimbodyEngine/PinJoint.cpp
@@ -30,7 +30,6 @@
 //=============================================================================
 // STATICS
 //=============================================================================
-using namespace SimTK;
 using namespace OpenSim;
 
 //=============================================================================
@@ -40,5 +39,5 @@ using namespace OpenSim;
 void PinJoint::extendAddToSystem(SimTK::MultibodySystem& system) const
 {
     Super::extendAddToSystem(system);
-    createMobilizedBody<MobilizedBody::Pin>(system);
+    createMobilizedBody<SimTK::MobilizedBody::Pin>(system);
 }
\ No newline at end of file
diff --git a/OpenSim/Simulation/SimbodyEngine/PlanarJoint.cpp b/OpenSim/Simulation/SimbodyEngine/PlanarJoint.cpp
index b6e09afac..1edd4a162 100644
--- a/OpenSim/Simulation/SimbodyEngine/PlanarJoint.cpp
+++ b/OpenSim/Simulation/SimbodyEngine/PlanarJoint.cpp
@@ -30,7 +30,6 @@
 //=============================================================================
 // STATICS
 //=============================================================================
-using namespace SimTK;
 using namespace OpenSim;
 
 //=============================================================================
@@ -40,5 +39,5 @@ using namespace OpenSim;
 void PlanarJoint::extendAddToSystem(SimTK::MultibodySystem& system) const
 {
     Super::extendAddToSystem(system);
-    createMobilizedBody<MobilizedBody::Planar>(system);
-}
+    createMobilizedBody<SimTK::MobilizedBody::Planar>(system);
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/SimbodyEngine/PointConstraint.cpp b/OpenSim/Simulation/SimbodyEngine/PointConstraint.cpp
index dbc9b7461..46c8903e3 100644
--- a/OpenSim/Simulation/SimbodyEngine/PointConstraint.cpp
+++ b/OpenSim/Simulation/SimbodyEngine/PointConstraint.cpp
@@ -33,7 +33,6 @@
 // STATICS
 //=============================================================================
 using namespace std;
-using namespace SimTK;
 using namespace OpenSim;
 
 //=============================================================================
@@ -93,10 +92,10 @@ void PointConstraint::constructProperties()
     //Default location and orientation (rotation sequence)
     SimTK::Vec3 origin(0.0, 0.0, 0.0);
 
-    // Location in Body 1 
+    // Location in SimTK::Body 1 
     constructProperty_location_body_1(origin);
 
-    // Location in Body 2 
+    // Location in SimTK::Body 2 
     constructProperty_location_body_2(origin);
 }
 
@@ -138,19 +137,19 @@ void PointConstraint::setBody2ByName(const std::string& aBodyName)
 }
 
 /** Set the location for point on body 1*/
-void PointConstraint::setBody1PointLocation(Vec3 location)
+void PointConstraint::setBody1PointLocation(SimTK::Vec3 location)
 {
     set_location_body_1(location);
 }
 
 /** Set the location for point on body 2*/
-void PointConstraint::setBody2PointLocation(Vec3 location)
+void PointConstraint::setBody2PointLocation(SimTK::Vec3 location)
 {
     set_location_body_2(location);
 }
 
 /** Set the point locations */
-void PointConstraint::setContactPointForInducedAccelerations(const SimTK::State &s, Vec3 point)
+void PointConstraint::setContactPointForInducedAccelerations(const SimTK::State &s, SimTK::Vec3 point)
 {
     // make sure we are at the position stage
     getSystem().realize(s, SimTK::Stage::Position);
@@ -163,7 +162,7 @@ void PointConstraint::setContactPointForInducedAccelerations(const SimTK::State
     // For external forces we assume point position vector is defined wrt foot (i.e., _body2)
     // because we are passing it in from a prescribed force.
     // We must also get that point position vector wrt ground (i.e., _body1)
-    Vec3 spoint = body2.findStationLocationInAnotherFrame(s, point, body1);
+    SimTK::Vec3 spoint = body2.findStationLocationInAnotherFrame(s, point, body1);
 
     setBody1PointLocation(spoint);
     setBody2PointLocation(point);
@@ -203,4 +202,4 @@ void PointConstraint::updateFromXMLNode(SimTK::Xml::Element& aNode, int versionN
     }
 
     Super::updateFromXMLNode(aNode, versionNumber);
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/SimbodyEngine/PointOnLineConstraint.cpp b/OpenSim/Simulation/SimbodyEngine/PointOnLineConstraint.cpp
index c55ef2379..579799e5a 100644
--- a/OpenSim/Simulation/SimbodyEngine/PointOnLineConstraint.cpp
+++ b/OpenSim/Simulation/SimbodyEngine/PointOnLineConstraint.cpp
@@ -33,7 +33,6 @@
 // STATICS
 //=============================================================================
 using namespace std;
-using namespace SimTK;
 using namespace OpenSim;
 
 //=============================================================================
@@ -104,7 +103,7 @@ void PointOnLineConstraint::constructProperties()
     // Default Point On Line
     constructProperty_point_on_line(origin);
 
-    // Point On Follower Body 
+    // Point On Follower SimTK::Body 
     constructProperty_point_on_follower(origin);
 }
 
@@ -151,19 +150,19 @@ void PointOnLineConstraint::setFollowerBodyByName(const std::string& aBodyName)
 
 
 /** Set the line direction for the point on line constraint*/
-void PointOnLineConstraint::setLineDirection(Vec3 direction)
+void PointOnLineConstraint::setLineDirection(SimTK::Vec3 direction)
 {
     set_line_direction_vec(direction);
 }
 
 /** Set the location of the point on the line*/
-void PointOnLineConstraint::setPointOnLine(Vec3 point)
+void PointOnLineConstraint::setPointOnLine(SimTK::Vec3 point)
 {
     set_point_on_line(point);
 }
 
 /** Set the location of the point on the follower body*/
-void PointOnLineConstraint::setPointOnFollower(Vec3 point)
+void PointOnLineConstraint::setPointOnFollower(SimTK::Vec3 point)
 {
     set_point_on_follower(point);
 }
@@ -202,4 +201,4 @@ void PointOnLineConstraint::updateFromXMLNode(SimTK::Xml::Element& aNode, int ve
     }
 
     Super::updateFromXMLNode(aNode, versionNumber);
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/SimbodyEngine/RollingOnSurfaceConstraint.cpp b/OpenSim/Simulation/SimbodyEngine/RollingOnSurfaceConstraint.cpp
index 116c8c152..37fa00aac 100644
--- a/OpenSim/Simulation/SimbodyEngine/RollingOnSurfaceConstraint.cpp
+++ b/OpenSim/Simulation/SimbodyEngine/RollingOnSurfaceConstraint.cpp
@@ -33,7 +33,6 @@
 // STATICS
 //=============================================================================
 using namespace std;
-using namespace SimTK;
 using namespace OpenSim;
 
 //=============================================================================
@@ -80,7 +79,7 @@ void RollingOnSurfaceConstraint::setNull()
 void RollingOnSurfaceConstraint::constructProperties()
 {
     // Surface parameters
-    constructProperty_surface_normal(Vec3(0, 1.0, 0));
+    constructProperty_surface_normal(SimTK::Vec3(0, 1.0, 0));
 
     constructProperty_surface_height(0.0);
     
@@ -106,7 +105,7 @@ void RollingOnSurfaceConstraint::extendAddToSystem(SimTK::MultibodySystem& syste
     SimTK::MobilizedBody::Weld  cb(surface, SimTK::Body::Massless());
 
     // Constrain the roller to the surface
-    SimTK::Constraint::PointInPlane contactY(surface, SimTK::UnitVec3(get_surface_normal()), get_surface_height(), roller,Vec3(0));
+    SimTK::Constraint::PointInPlane contactY(surface, SimTK::UnitVec3(get_surface_normal()), get_surface_height(), roller,SimTK::Vec3(0));
     SimTK::Constraint::ConstantAngle contactTorqueAboutY(surface, SimTK::UnitVec3(1,0,0), roller, SimTK::UnitVec3(0,0,1));
     // Constrain the roller to roll on surface and not slide 
     SimTK::Constraint::NoSlip1D contactPointXdir(cb, SimTK::Vec3(0), SimTK::UnitVec3(1,0,0), surface, roller);
@@ -180,7 +179,7 @@ void RollingOnSurfaceConstraint::setSurfaceBodyByName(const std::string& aBodyNa
 }
 
 /** Set the point of contact on the rolling body that will be in contact with the surface */
-void RollingOnSurfaceConstraint::setContactPointForInducedAccelerations(const SimTK::State &s, Vec3 point)
+void RollingOnSurfaceConstraint::setContactPointForInducedAccelerations(const SimTK::State &s, SimTK::Vec3 point)
 {
     // Get the individual underlying constraints
     SimTK::Constraint::PointInPlane &contactY = (SimTK::Constraint::PointInPlane &)
@@ -193,30 +192,30 @@ void RollingOnSurfaceConstraint::setContactPointForInducedAccelerations(const Si
         updSystem().updMatterSubsystem().updConstraint(_indices[3]);
 
     // The contact point coordinates in the surface body frame 
-    Vec3 surfaceNormal = get_surface_normal();
+    SimTK::Vec3 surfaceNormal = get_surface_normal();
 
     // make sure we are at the position stage
     getSystem().realize(s, SimTK::Stage::Position);
 
     // For external forces we assume w.r.t. ground
-    Vec3 spoint = _rollingFrame->findStationLocationInAnotherFrame(s, point, *_surfaceFrame);
+    SimTK::Vec3 spoint = _rollingFrame->findStationLocationInAnotherFrame(s, point, *_surfaceFrame);
 
     // The contact point coordinates in the surface body frame 
-    contactY.setDefaultPlaneNormal(UnitVec3(surfaceNormal));
+    contactY.setDefaultPlaneNormal(SimTK::UnitVec3(surfaceNormal));
     contactY.setDefaultPlaneHeight(~spoint*surfaceNormal);
     // And the point in the follower (roller) frame
     contactY.setDefaultFollowerPoint(point);
 
     // Assume that torsion constraint is always normal to surface.
     // Find corresponding vector in the rolling body
-    Vec3 normalInRoller = 
+    SimTK::Vec3 normalInRoller = 
         _surfaceFrame->expressVectorInAnotherFrame(s, surfaceNormal, *_rollingFrame);
 
-    const UnitVec3& surfaceBase = contactTorqueAboutY.getDefaultBaseAxis();
-    Vec3 baseAxisInRoller =
+    const SimTK::UnitVec3& surfaceBase = contactTorqueAboutY.getDefaultBaseAxis();
+    SimTK::Vec3 baseAxisInRoller =
         _surfaceFrame->expressVectorInAnotherFrame(s, surfaceBase, *_rollingFrame);
 
-    contactTorqueAboutY.setDefaultFollowerAxis(UnitVec3(baseAxisInRoller%normalInRoller));
+    contactTorqueAboutY.setDefaultFollowerAxis(SimTK::UnitVec3(baseAxisInRoller%normalInRoller));
 
     // Set the point of no slip for this instant
     contactPointXdir.setDefaultContactPoint(spoint);
@@ -311,7 +310,7 @@ bool RollingOnSurfaceConstraint::setIsEnforced(SimTK::State& state,
     // If dynamics has been realized, then this is an attempt to enforce/disable
     //  the constraint during a computation and not an initialization, in which
     // case we must check the unilateral conditions for each constraint
-    if(state.getSystemStage() > Stage::Dynamics)
+    if(state.getSystemStage() > SimTK::Stage::Dynamics)
         shouldBeOn = unilateralConditionsSatisfied(state);
 
     return setIsEnforced(state, isEnforced, shouldBeOn);
@@ -376,9 +375,9 @@ void RollingOnSurfaceConstraint::calcConstraintForces(const SimTK::State& state,
             //int anc = simConstraint.getAncestorMobilizedBody().getMobilizedBodyIndex();
             
             for(int j=0; j< ncb; j++){
-                if (_surfaceFrame->getMobilizedBodyIndex() == simConstraint.getMobilizedBodyFromConstrainedBody(ConstrainedBodyIndex(j)).getMobilizedBodyIndex())
+                if (_surfaceFrame->getMobilizedBodyIndex() == simConstraint.getMobilizedBodyFromConstrainedBody(SimTK::ConstrainedBodyIndex(j)).getMobilizedBodyIndex())
                     sbi = j;
-                if (_rollingFrame->getMobilizedBodyIndex() == simConstraint.getMobilizedBodyFromConstrainedBody(ConstrainedBodyIndex(j)).getMobilizedBodyIndex())
+                if (_rollingFrame->getMobilizedBodyIndex() == simConstraint.getMobilizedBodyFromConstrainedBody(SimTK::ConstrainedBodyIndex(j)).getMobilizedBodyIndex())
                     rbi = j;
             }
 
@@ -436,4 +435,4 @@ RollingOnSurfaceConstraint::
 setIsEnforcedWithCachedUnilateralConditions(bool isEnforced,
                                             SimTK::State& state) {
     return setIsEnforced(state, isEnforced, _defaultUnilateralConditions);
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/SimbodyEngine/ScapulothoracicJoint.cpp b/OpenSim/Simulation/SimbodyEngine/ScapulothoracicJoint.cpp
index e247ed310..379cac4a1 100644
--- a/OpenSim/Simulation/SimbodyEngine/ScapulothoracicJoint.cpp
+++ b/OpenSim/Simulation/SimbodyEngine/ScapulothoracicJoint.cpp
@@ -37,7 +37,6 @@
 // STATICS
 //=============================================================================
 using namespace OpenSim;
-using namespace SimTK;
 //=============================================================================
 // CONSTRUCTOR(S)
 //=============================================================================
@@ -108,8 +107,8 @@ ScapulothoracicJoint::ScapulothoracicJoint(const std::string& name,
 void ScapulothoracicJoint::constructProperties()
 {
     setAuthors("Ajay Seth");
-    constructProperty_thoracic_ellipsoid_radii_x_y_z(Vec3(NaN));
-    constructProperty_scapula_winging_axis_origin(Vector(2, 0.0));
+    constructProperty_thoracic_ellipsoid_radii_x_y_z(SimTK::Vec3(SimTK::NaN));
+    constructProperty_scapula_winging_axis_origin(SimTK::Vector(2, 0.0));
     constructProperty_scapula_winging_axis_direction(0.0);
 }
 
@@ -133,8 +132,8 @@ void ScapulothoracicJoint::extendScale(const SimTK::State& s,
     const std::string& parentName = getParentFrame().getName();
 
     // Scaling related to the parent body:
-    // Get scale factors (if an entry for the parent Frame's base Body exists).
-    const Vec3& scaleFactorsP = getScaleFactors(scaleSet, getParentFrame());
+    // Get scale factors (if an entry for the parent Frame's base SimTK::Body exists).
+    const SimTK::Vec3& scaleFactorsP = getScaleFactors(scaleSet, getParentFrame());
     if (scaleFactorsP == ModelComponent::InvalidScaleFactors) return;
 
     // Now apply scale factors to the thoracic ellipsoid
@@ -142,8 +141,8 @@ void ScapulothoracicJoint::extendScale(const SimTK::State& s,
             get_thoracic_ellipsoid_radii_x_y_z().elementwiseMultiply(
                     scaleFactorsP);
 
-    // Get scale factors (if an entry for the child Frame's base Body exists).
-    const Vec3& scaleFactorsC = getScaleFactors(scaleSet, getChildFrame());
+    // Get scale factors (if an entry for the child Frame's base SimTK::Body exists).
+    const SimTK::Vec3& scaleFactorsC = getScaleFactors(scaleSet, getChildFrame());
     if (scaleFactorsC == ModelComponent::InvalidScaleFactors) return;
 
     upd_scapula_winging_axis_origin(0) =
@@ -160,38 +159,38 @@ void ScapulothoracicJoint::extendAddToSystem(SimTK::MultibodySystem& system) con
 {
     Super::extendAddToSystem(system);
 
-    // Transform for ellipsoid joint frame in intermediate Scapula massless
+    // SimTK::Transform for ellipsoid joint frame in intermediate Scapula massless
     // body frame.
     //
     // Oriented such that intermediate frame is aligned with scapula joint
     // frame with respect to the scapula body frame as user specified by
     // _location and _orientation
-    Transform ellipsoidJointFrameInIntermediate{
-        Rotation{
-            BodyRotationSequence,
-            0, XAxis,
-            0, YAxis,
-            Pi/2,
-            ZAxis},
-        Vec3(0.0)};
+    SimTK::Transform ellipsoidJointFrameInIntermediate{
+        SimTK::Rotation{
+            SimTK::BodyRotationSequence,
+            0, SimTK::XAxis,
+            0, SimTK::YAxis,
+            SimTK::Pi/2,
+            SimTK::ZAxis},
+        SimTK::Vec3(0.0)};
 
-    // Transform for Ellipsoid in parent body (Thorax).
+    // SimTK::Transform for Ellipsoid in parent body (Thorax).
     //
-    // Note: Ellipsoid rotated Pi/2 w.r.t. parent (i.e. Thorax) so that
+    // Note: Ellipsoid rotated SimTK::Pi/2 w.r.t. parent (i.e. Thorax) so that
     //       abduction and elevation are positive.
-    Transform ellipsoidJointFrameInThorax = [&](){
-        Transform parentTransform = getParentFrame().findTransformInBaseFrame();
+    SimTK::Transform ellipsoidJointFrameInThorax = [&](){
+        SimTK::Transform parentTransform = getParentFrame().findTransformInBaseFrame();
 
-        const Vec3 orientationInParent =
+        const SimTK::Vec3 orientationInParent =
             parentTransform.R().convertRotationToBodyFixedXYZ();
 
-        return Transform{
-            Rotation{
-                BodyRotationSequence,
-                orientationInParent[0], XAxis,
-                orientationInParent[1], YAxis,
-                orientationInParent[2] + Pi/2,
-                ZAxis},
+        return SimTK::Transform{
+            SimTK::Rotation{
+                SimTK::BodyRotationSequence,
+                orientationInParent[0], SimTK::XAxis,
+                orientationInParent[1], SimTK::YAxis,
+                orientationInParent[2] + SimTK::Pi/2,
+                SimTK::ZAxis},
             parentTransform.p()};
     }();
 
@@ -200,19 +199,19 @@ void ScapulothoracicJoint::extendAddToSystem(SimTK::MultibodySystem& system) con
 
     // Create mobilized body.
     //
-    // Ellipsoid is rotated Pi/2 for desired rotations, but user's still wants
+    // Ellipsoid is rotated SimTK::Pi/2 for desired rotations, but user's still wants
     // to define Ellipsoid shape w.r.t thorax.
     //
     // Swap ellipsoidRadii X,Y,Z in Thorax body frame to Y, X, Z in rotated
     // joint frame in parent.
-    MobilizedBody::Ellipsoid simtkMasslessBody1 = [&]() {
+    SimTK::MobilizedBody::Ellipsoid simtkMasslessBody1 = [&]() {
         const SimTK::MobilizedBodyIndex& parentMobodIndex =
             getParentFrame().getMobilizedBodyIndex();
 
-        MobilizedBody& parentMobod =
+        SimTK::MobilizedBody& parentMobod =
             system.updMatterSubsystem().updMobilizedBody(parentMobodIndex);
 
-        auto mobod = createMobilizedBody<MobilizedBody::Ellipsoid>(
+        auto mobod = createMobilizedBody<SimTK::MobilizedBody::Ellipsoid>(
             parentMobod,
             ellipsoidJointFrameInThorax,
             SimTK::Body::Massless(),
@@ -220,7 +219,7 @@ void ScapulothoracicJoint::extendAddToSystem(SimTK::MultibodySystem& system) con
             coordinateIndexForMobility);
 
         // swizzle radii coordinates appropriately
-        Vec3 ellipsoidRadii{
+        SimTK::Vec3 ellipsoidRadii{
             get_thoracic_ellipsoid_radii_x_y_z()[1],
             get_thoracic_ellipsoid_radii_x_y_z()[0],
             get_thoracic_ellipsoid_radii_x_y_z()[2]};
@@ -229,7 +228,7 @@ void ScapulothoracicJoint::extendAddToSystem(SimTK::MultibodySystem& system) con
         return mobod;
     }();
 
-    MobilizedBody::Pin simtkMasslessBody2 = [&]() {
+    SimTK::MobilizedBody::Pin simtkMasslessBody2 = [&]() {
         // get unit vector version of direction in the scapula joint frame of
         // the Ellipsoid, where:
         //
@@ -248,7 +247,7 @@ void ScapulothoracicJoint::extendAddToSystem(SimTK::MultibodySystem& system) con
 
         // Find rotation that aligns z-axis of pin mobilizer frame to winging
         // axis. This is in the scapula-ellipsoid (massless body) frame.
-        SimTK::Rotation wingOrientationInIntermediateFrame(dir, ZAxis);
+        SimTK::Rotation wingOrientationInIntermediateFrame(dir, SimTK::ZAxis);
 
         // origin of the winging axis w.r.t to the scapula joint frame of the
         // ellipsoid
@@ -262,7 +261,7 @@ void ScapulothoracicJoint::extendAddToSystem(SimTK::MultibodySystem& system) con
             wingOrientationInIntermediateFrame,
             wingOriginInIntermediateFrame);
 
-        return createMobilizedBody<MobilizedBody::Pin>(
+        return createMobilizedBody<SimTK::MobilizedBody::Pin>(
             simtkMasslessBody1,
             wingingInIntermediateFrame,
             SimTK::Body::Massless(),
@@ -271,12 +270,12 @@ void ScapulothoracicJoint::extendAddToSystem(SimTK::MultibodySystem& system) con
     }();
 
     // Define the scapular joint frame in w.r.t to the Scapula body frame
-    //Rotation rotation2(BodyRotationSequence, orientation[0], XAxis,
-    //    orientation[1], YAxis, orientation[2], ZAxis);
+    //SimTK::Rotation rotation2(SimTK::BodyRotationSequence, orientation[0], SimTK::XAxis,
+    //    orientation[1], SimTK::YAxis, orientation[2], SimTK::YAxis);
     //SimTK::Transform jointInScapula(rotation2, location);
-    MobilizedBody::Weld mobod(
+    SimTK::MobilizedBody::Weld mobod(
         simtkMasslessBody2,
-        Transform(),
+        SimTK::Transform(),
         getChildInternalRigidBody(),
         getChildFrame().findTransformInBaseFrame());
 
@@ -285,4 +284,4 @@ void ScapulothoracicJoint::extendAddToSystem(SimTK::MultibodySystem& system) con
         &getChildFrame(),
         0,
         coordinateIndexForMobility);
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/SimbodyEngine/Test/testConstraints.cpp b/OpenSim/Simulation/SimbodyEngine/Test/testConstraints.cpp
index fcab38bb7..13fd9f950 100644
--- a/OpenSim/Simulation/SimbodyEngine/Test/testConstraints.cpp
+++ b/OpenSim/Simulation/SimbodyEngine/Test/testConstraints.cpp
@@ -137,10 +137,8 @@ public:
 //==============================================================================
 int initTestStates(SimTK::Vector &qi, SimTK::Vector &ui)
 {
-    using namespace SimTK;
-
-    Random::Uniform randomAngle(-Pi/4, Pi/4);
-    Random::Uniform randomSpeed(-1.0, 1.0);
+    SimTK::Random::Uniform randomAngle(-SimTK::Pi/4, SimTK::Pi/4);
+    SimTK::Random::Uniform randomSpeed(-1.0, 1.0);
 
     // Provide initial states as random angles and speeds for OpenSim and 
     // Simbody models
@@ -155,15 +153,13 @@ int initTestStates(SimTK::Vector &qi, SimTK::Vector &ui)
 
 void integrateSimbodySystem(SimTK::MultibodySystem &system, SimTK::State &state)
 {
-    using namespace SimTK;
-
     // realize simbody system to velocity stage
-    system.realize(state, Stage::Velocity);
+    system.realize(state, SimTK::Stage::Velocity);
 
-    RungeKuttaMersonIntegrator integ(system);
+    SimTK::RungeKuttaMersonIntegrator integ(system);
     integ.setAccuracy(integ_accuracy);
     
-    TimeStepper ts(system, integ);
+    SimTK::TimeStepper ts(system, integ);
     ts.initialize(state);
     ts.stepTo(duration);
     state = ts.getState();
@@ -171,10 +167,8 @@ void integrateSimbodySystem(SimTK::MultibodySystem &system, SimTK::State &state)
 
 void integrateOpenSimModel(Model *osimModel, SimTK::State &osim_state)
 {
-    using namespace SimTK;
-
     // SETUP OpenSim SIMULATION Manager
-    osimModel->getMultibodySystem().realize(osim_state, Stage::Velocity);
+    osimModel->getMultibodySystem().realize(osim_state, SimTK::Stage::Velocity);
 
     Manager manager(*osimModel);
     manager.setIntegratorAccuracy(integ_accuracy);
@@ -187,10 +181,8 @@ void compareSimulationStates(SimTK::Vector q_sb, SimTK::Vector u_sb,
     SimTK::Vector q_osim, SimTK::Vector u_osim,
     string errorMessagePrefix = "")
 {
-    using namespace SimTK;
-    
-    Vector q_err = q_sb;
-    Vector u_err = u_sb;
+    SimTK::Vector q_err = q_sb;
+    SimTK::Vector u_err = u_sb;
 
     int nq = q_osim.size();
     if(q_sb.size() > nq){ // we have an unused quaternion slot in Simbody
@@ -235,11 +227,9 @@ void compareSimulationStates(SimTK::Vector q_sb, SimTK::Vector u_sb,
 
 void compareSimulations(SimTK::MultibodySystem &system, SimTK::State &state, Model *osimModel, SimTK::State &osim_state, string errorMessagePrefix = "")
 {
-    using namespace SimTK;
-
     // Set the initial states for both Simbody system and OpenSim model
-    Vector& qi = state.updQ();
-    Vector& ui = state.updU();
+    SimTK::Vector& qi = state.updQ();
+    SimTK::Vector& ui = state.updU();
     int nq_sb = initTestStates(qi, ui);
     int nq = osim_state.getNQ();
 
@@ -270,8 +260,8 @@ void compareSimulations(SimTK::MultibodySystem &system, SimTK::State &state, Mod
     integrateOpenSimModel(osimModel, osim_state);
 
     // Get the state at the end of the integration from OpenSim.
-    Vector& qf = osim_state.updQ();
-    Vector& uf = osim_state.updU();
+    SimTK::Vector& qf = osim_state.updQ();
+    SimTK::Vector& uf = osim_state.updU();
     qf.dump("\nOpenSim Final q's:");
     uf.dump("\nOpenSim Final u's:");
 
@@ -287,33 +277,31 @@ void compareSimulations(SimTK::MultibodySystem &system, SimTK::State &state, Mod
 
 TEST_CASE("testPointConstraint")
 {
-    using namespace SimTK;
-
     cout << endl;
     cout << "==================================================================" << endl;
     cout << " OpenSim PointConstraint vs. Simbody Constraint::Ball " << endl;
     cout << "==================================================================" << endl;
 
-    Random::Uniform randomLocation(-1, 1);
-    Vec3 pointOnFoot(randomLocation.getValue(), randomLocation.getValue(), randomLocation.getValue());
-    Vec3 pointOnGround(0,0,0);
+    SimTK::Random::Uniform randomLocation(-1, 1);
+    SimTK::Vec3 pointOnFoot(randomLocation.getValue(), randomLocation.getValue(), randomLocation.getValue());
+    SimTK::Vec3 pointOnGround(0,0,0);
 
     // Define the Simbody system
-    MultibodySystem system;
-    SimbodyMatterSubsystem matter(system);
-    GeneralForceSubsystem forces(system);
+    SimTK::MultibodySystem system;
+    SimTK::SimbodyMatterSubsystem matter(system);
+    SimTK::GeneralForceSubsystem forces(system);
     SimTK::Force::UniformGravity gravity(forces, matter, gravity_vec);
 
     // Create a free joint between the foot and ground
-    MobilizedBody::Free foot(matter.Ground(), Transform(Vec3(0)), 
-        SimTK::Body::Rigid(footMass), Transform(Vec3(0)));
+    SimTK::MobilizedBody::Free foot(matter.Ground(), SimTK::Transform(SimTK::Vec3(0)), 
+        SimTK::Body::Rigid(footMass), SimTK::Transform(SimTK::Vec3(0)));
     
     // Constrain foot to point on ground
     SimTK::Constraint::Ball simtkBall(matter.Ground(), pointOnGround, foot, pointOnFoot);
 
     // Simbody model state setup
     system.realizeTopology();
-    State state = system.getDefaultState();
+    SimTK::State state = system.getDefaultState();
     matter.setUseEulerAngles(state, true);
     system.realizeModel(state);
 
@@ -327,7 +315,7 @@ TEST_CASE("testPointConstraint")
     OpenSim::Body osim_foot("foot", footMass.getMass(), footMass.getMassCenter(), footMass.getInertia());
 
     // create foot as a free joint
-    FreeJoint footJoint("footToGround", ground, Vec3(0), Vec3(0), osim_foot, Vec3(0), Vec3(0));
+    FreeJoint footJoint("footToGround", ground, SimTK::Vec3(0), SimTK::Vec3(0), osim_foot, SimTK::Vec3(0), SimTK::Vec3(0));
     
     // Add the thigh body which now also contains the hip joint to the model
     osimModel->addBody(&osim_foot);
@@ -349,7 +337,7 @@ TEST_CASE("testPointConstraint")
 
     // Need to setup model before adding an analysis since it creates the AnalysisSet
     // for the model if it does not exist.
-    State& osim_state = osimModel->initSystem();
+    SimTK::State& osim_state = osimModel->initSystem();
 
     //==========================================================================================================
     // Compare Simbody system and OpenSim model simulations
@@ -358,34 +346,32 @@ TEST_CASE("testPointConstraint")
 
 TEST_CASE("testConstantDistanceConstraint")
 {
-    using namespace SimTK;
-
     cout << endl;
     cout << "==================================================================" << endl;
     cout << " OpenSim ConstantDistanceConstraint vs. Simbody Constraint::Rod " << endl;
     cout << "==================================================================" << endl;
 
-    Random::Uniform randomLocation(-1, 1);
-    Vec3 pointOnFoot(randomLocation.getValue(), randomLocation.getValue(), randomLocation.getValue());
-    Vec3 pointOnGround(0,0,0);
-    /** for some reason, adding another Random::Uniform causes testWeldConstraint to fail.  
+    SimTK::Random::Uniform randomLocation(-1, 1);
+    SimTK::Vec3 pointOnFoot(randomLocation.getValue(), randomLocation.getValue(), randomLocation.getValue());
+    SimTK::Vec3 pointOnGround(0,0,0);
+    /** for some reason, adding another SimTK::Random::Uniform causes testWeldConstraint to fail.  
     Why doesn't it cause this test to fail???? */
-    //Random::Uniform randomLength(0.01, 0.2);
+    //SimTK::Random::Uniform randomLength(0.01, 0.2);
     //randomLength.setSeed(1024);
     //double rodLength = randomLength.getValue(); 
     double rodLength = 0.05;
 
-    //std::cout << "Random Length = " << rodLength2 << ", used length = " << rodLength << std::endl;
+    //std::cout << "SimTK::Random Length = " << rodLength2 << ", used length = " << rodLength << std::endl;
 
     // Define the Simbody system
-    MultibodySystem system;
-    SimbodyMatterSubsystem matter(system);
-    GeneralForceSubsystem forces(system);
+    SimTK::MultibodySystem system;
+    SimTK::SimbodyMatterSubsystem matter(system);
+    SimTK::GeneralForceSubsystem forces(system);
     SimTK::Force::UniformGravity gravity(forces, matter, gravity_vec);
 
     // Create a free joint between the foot and ground
-    MobilizedBody::Free foot(matter.Ground(), Transform(Vec3(0)), 
-        SimTK::Body::Rigid(footMass), Transform(Vec3(0)));
+    SimTK::MobilizedBody::Free foot(matter.Ground(), SimTK::Transform(SimTK::Vec3(0)), 
+        SimTK::Body::Rigid(footMass), SimTK::Transform(SimTK::Vec3(0)));
     
     // Constrain foot to point on ground
     SimTK::Constraint::Rod simtkRod(matter.Ground(), pointOnGround, foot, pointOnFoot, rodLength);
@@ -393,7 +379,7 @@ TEST_CASE("testConstantDistanceConstraint")
 
     // Simbody model state setup
     system.realizeTopology();
-    State state = system.getDefaultState();
+    SimTK::State state = system.getDefaultState();
     matter.setUseEulerAngles(state, true);
     system.realizeModel(state);
 
@@ -409,8 +395,8 @@ TEST_CASE("testConstantDistanceConstraint")
                                         footMass.getInertia());
 
     // create foot as a free joint
-    auto* footJoint = new FreeJoint("footToGround", ground, Vec3(0), Vec3(0),
-                                    *osim_foot, Vec3(0), Vec3(0));
+    auto* footJoint = new FreeJoint("footToGround", ground, SimTK::Vec3(0), SimTK::Vec3(0),
+                                    *osim_foot, SimTK::Vec3(0), SimTK::Vec3(0));
     
     // Add the thigh body which now also contains the hip joint to the model
     osimModel.addBody(osim_foot);
@@ -430,7 +416,7 @@ TEST_CASE("testConstantDistanceConstraint")
 
     // Need to setup model before adding an analysis since it creates the
     // AnalysisSet for the model if it does not exist.
-    State& osim_state = osimModel.initSystem();
+    SimTK::State& osim_state = osimModel.initSystem();
 
     //=========================================================================
     // Compare Simbody system and OpenSim model simulations
@@ -439,15 +425,13 @@ TEST_CASE("testConstantDistanceConstraint")
 }
 TEST_CASE("testCoordinateLocking")
 {
-    using namespace SimTK;
-
     cout << endl;
     cout << "==================================================================" << endl;
     cout << " OpenSim testCoordinateLocking " << endl;
     cout << "==================================================================" << endl;
 
 
-    double fixedKneeAngle = Pi/2;
+    double fixedKneeAngle = SimTK::Pi/2;
 
     // Setup OpenSim model
     Model *osimModel = new Model;
@@ -458,7 +442,7 @@ TEST_CASE("testCoordinateLocking")
     OpenSim::Body osim_thigh("thigh", femurMass, femurCOM, femurInertiaAboutCOM);
 
     // create hip as a pin joint
-    PinJoint hip("hip",ground, hipInGround, Vec3(0), osim_thigh, hipInFemur, Vec3(0));
+    PinJoint hip("hip",ground, hipInGround, SimTK::Vec3(0), osim_thigh, hipInFemur, SimTK::Vec3(0));
     // Rename hip coordinates for a pin joint
     hip.updCoordinate().setName("hip_flex");
 
@@ -471,8 +455,8 @@ TEST_CASE("testCoordinateLocking")
         tibiaMass.getMassCenter(), tibiaMass.getInertia());
 
     // create pin knee joint
-    PinJoint knee("knee", osim_thigh, kneeInFemur, Vec3(0),
-                          osim_shank, Vec3(0), Vec3(0));
+    PinJoint knee("knee", osim_thigh, kneeInFemur, SimTK::Vec3(0),
+                          osim_shank, SimTK::Vec3(0), SimTK::Vec3(0));
 
     // Add the shank body and knee joint
     osimModel->addBody(&osim_shank);
@@ -484,7 +468,7 @@ TEST_CASE("testCoordinateLocking")
     osimModel->setGravity(gravity_vec);
 
     // Initialize the state of the model based on the defaults of ModelComponents.
-    State& si = osimModel->initSystem();
+    SimTK::State& si = osimModel->initSystem();
 
     // Model joint states
     CoordinateSet &coordinates = osimModel->updCoordinateSet();
@@ -502,9 +486,9 @@ TEST_CASE("testCoordinateLocking")
     osimModel = new Model("testLockingModel.osim");
 
     // Re-initialize the state of the model based on now saved defaults of the model.
-    State& si2 = osimModel->initSystem();
+    SimTK::State& si2 = osimModel->initSystem();
 
-    osimModel->getMultibodySystem().realize(si2, Stage::Velocity );
+    osimModel->getMultibodySystem().realize(si2, SimTK::Stage::Velocity );
  
     // Create the integrator and manager for the simulation.
     Manager manager(*osimModel);
@@ -515,7 +499,7 @@ TEST_CASE("testCoordinateLocking")
     // Print out the initial position and velocity states
     si2.getQ().dump("Initial q's"); // pendulum positions
     si2.getU().dump("Initial u's"); // pendulum velocities
-    Vector qi = si2.getQ();
+    SimTK::Vector qi = si2.getQ();
 
     // Integrate from initial time to final time
     si2.setTime(0.0);
@@ -524,7 +508,7 @@ TEST_CASE("testCoordinateLocking")
     si2 = manager.integrate(duration);
 
     // Print out the final position and velocity states
-    Vector qf = si2.getQ();
+    SimTK::Vector qf = si2.getQ();
     qf.dump("Final q's"); // pendulum positions
     si2.getU().dump("Final u's"); // pendulum velocities
 
@@ -535,36 +519,34 @@ TEST_CASE("testCoordinateLocking")
 
 TEST_CASE("testWeldConstraint")
 {
-    using namespace SimTK;
-
     cout << endl;
     cout << "==================================================================" << endl;
     cout << " OpenSim WeldConstraint vs. Simbody Constraint::Weld " << endl;
     cout << "==================================================================" << endl;
 
-    Random::Uniform randomValue(-0.05, 0.1);
-    Vec3 weldInGround(randomValue.getValue(), randomValue.getValue(), 0);
-    Vec3 weldInFoot(0.1*randomValue.getValue(), 0.1*randomValue.getValue(), 0);
+    SimTK::Random::Uniform randomValue(-0.05, 0.1);
+    SimTK::Vec3 weldInGround(randomValue.getValue(), randomValue.getValue(), 0);
+    SimTK::Vec3 weldInFoot(0.1*randomValue.getValue(), 0.1*randomValue.getValue(), 0);
 
     // Define the Simbody system
-    MultibodySystem system;
-    SimbodyMatterSubsystem matter(system);
-    GeneralForceSubsystem forces(system);
+    SimTK::MultibodySystem system;
+    SimTK::SimbodyMatterSubsystem matter(system);
+    SimTK::GeneralForceSubsystem forces(system);
     SimTK::Force::UniformGravity gravity(forces, matter, gravity_vec);
 
     // Thigh connected by hip
-    MobilizedBody::Pin thigh(matter.Ground(), SimTK::Transform(hipInGround), 
-        SimTK::Body::Rigid(MassProperties(femurMass, femurCOM, femurInertiaAboutCOM.shiftFromMassCenter(femurCOM, femurMass))), Transform(hipInFemur));
+    SimTK::MobilizedBody::Pin thigh(matter.Ground(), SimTK::Transform(hipInGround), 
+        SimTK::Body::Rigid(SimTK::MassProperties(femurMass, femurCOM, femurInertiaAboutCOM.shiftFromMassCenter(femurCOM, femurMass))), SimTK::Transform(hipInFemur));
     // Pin knee connects shank
-    MobilizedBody::Pin shank(thigh, Transform(kneeInFemur), SimTK::Body::Rigid(tibiaMass), Transform(kneeInTibia));
+    SimTK::MobilizedBody::Pin shank(thigh, SimTK::Transform(kneeInFemur), SimTK::Body::Rigid(tibiaMass), SimTK::Transform(kneeInTibia));
     // Pin ankle connects foot
-    MobilizedBody::Pin foot(shank, Transform(ankleInTibia), SimTK::Body::Rigid(footMass), Transform(ankleInFoot));
+    SimTK::MobilizedBody::Pin foot(shank, SimTK::Transform(ankleInTibia), SimTK::Body::Rigid(footMass), SimTK::Transform(ankleInFoot));
 
-    SimTK::Constraint::Weld weld(matter.Ground(), Transform(weldInGround), foot, Transform(weldInFoot));
+    SimTK::Constraint::Weld weld(matter.Ground(), SimTK::Transform(weldInGround), foot, SimTK::Transform(weldInFoot));
 
     // Simbody model state setup
     system.realizeTopology();
-    State state = system.getDefaultState();
+    SimTK::State state = system.getDefaultState();
     matter.setUseEulerAngles(state, true);
     system.realizeModel(state);
 
@@ -578,8 +560,8 @@ TEST_CASE("testWeldConstraint")
     OpenSim::Body osim_thigh("thigh", femurMass, femurCOM, femurInertiaAboutCOM);
 
     // create Pin hip joint
-    PinJoint hip("hip", ground, hipInGround, Vec3(0), 
-                        osim_thigh, hipInFemur, Vec3(0));
+    PinJoint hip("hip", ground, hipInGround, SimTK::Vec3(0), 
+                        osim_thigh, hipInFemur, SimTK::Vec3(0));
 
     // Add the thigh body which now also contains the hip joint to the model
     osimModel->addBody(&osim_thigh);
@@ -590,8 +572,8 @@ TEST_CASE("testWeldConstraint")
         tibiaMass.getMassCenter(), tibiaMass.getInertia());
 
     // create Pin knee joint
-    PinJoint knee("knee", osim_thigh, kneeInFemur, Vec3(0), 
-                          osim_shank, kneeInTibia, Vec3(0));
+    PinJoint knee("knee", osim_thigh, kneeInFemur, SimTK::Vec3(0), 
+                          osim_shank, kneeInTibia, SimTK::Vec3(0));
 
     // Add the thigh body which now also contains the hip joint to the model
     osimModel->addBody(&osim_shank);
@@ -602,8 +584,8 @@ TEST_CASE("testWeldConstraint")
         footMass.getMassCenter(), footMass.getInertia());
 
     // create Pin ankle joint
-    PinJoint ankle("ankle", osim_shank, ankleInTibia, Vec3(0),
-                             osim_foot, ankleInFoot, Vec3(0));
+    PinJoint ankle("ankle", osim_shank, ankleInTibia, SimTK::Vec3(0),
+                             osim_foot, ankleInFoot, SimTK::Vec3(0));
 
     // Add the foot body which now also contains the hip joint to the model
     osimModel->addBody(&osim_foot);
@@ -630,7 +612,7 @@ TEST_CASE("testWeldConstraint")
 
     // Need to setup model before adding an analysis since it creates the AnalysisSet
     // for the model if it does not exist.
-    State& osim_state = osimModel->initSystem();
+    SimTK::State& osim_state = osimModel->initSystem();
 
     //=========================================================================
     // Compare Simbody system and OpenSim model simulations
@@ -640,29 +622,27 @@ TEST_CASE("testWeldConstraint")
 
 TEST_CASE("testPointOnLineConstraint")
 {
-    using namespace SimTK;
-
     cout << endl;
     cout << "==================================================================" << endl;
     cout << "OpenSim PointOnLineConstraint vs. Simbody Constraint::PointOnLine " << endl;
     cout << "==================================================================" << endl;
 
-    Random::Uniform randomDirection(-1, 1);
-    Vec3 lineDirection(randomDirection.getValue(), randomDirection.getValue(),
+    SimTK::Random::Uniform randomDirection(-1, 1);
+    SimTK::Vec3 lineDirection(randomDirection.getValue(), randomDirection.getValue(),
         randomDirection.getValue());
-    UnitVec3 normLineDirection(lineDirection.normalize());
-    Vec3 pointOnLine(0,0,0);
-    Vec3 pointOnFollower(0,0,0);
+    SimTK::UnitVec3 normLineDirection(lineDirection.normalize());
+    SimTK::Vec3 pointOnLine(0,0,0);
+    SimTK::Vec3 pointOnFollower(0,0,0);
 
     // Define the Simbody system
-    MultibodySystem system;
-    SimbodyMatterSubsystem matter(system);
-    GeneralForceSubsystem forces(system);
+    SimTK::MultibodySystem system;
+    SimTK::SimbodyMatterSubsystem matter(system);
+    SimTK::GeneralForceSubsystem forces(system);
     SimTK::Force::UniformGravity gravity(forces, matter, gravity_vec);
 
     // Create a free joint between the foot and ground
-    MobilizedBody::Free foot(matter.Ground(), Transform(Vec3(0)), 
-        SimTK::Body::Rigid(footMass), Transform(Vec3(0)));
+    SimTK::MobilizedBody::Free foot(matter.Ground(), SimTK::Transform(SimTK::Vec3(0)), 
+        SimTK::Body::Rigid(footMass), SimTK::Transform(SimTK::Vec3(0)));
     
     // Constrain foot to line on ground
     SimTK::Constraint::PointOnLine simtkPointOnLine(matter.Ground(), 
@@ -670,7 +650,7 @@ TEST_CASE("testPointOnLineConstraint")
 
     // Simbody model state setup
     system.realizeTopology();
-    State state = system.getDefaultState();
+    SimTK::State state = system.getDefaultState();
     matter.setUseEulerAngles(state, true);
     system.realizeModel(state);
 
@@ -685,8 +665,8 @@ TEST_CASE("testPointOnLineConstraint")
         footMass.getMassCenter(), footMass.getInertia());
 
     // create foot as a free joint
-    FreeJoint footJoint("footToGround", ground, Vec3(0), Vec3(0),
-                                     osim_foot, Vec3(0), Vec3(0));
+    FreeJoint footJoint("footToGround", ground, SimTK::Vec3(0), SimTK::Vec3(0),
+                                     osim_foot, SimTK::Vec3(0), SimTK::Vec3(0));
     
     // Add the thigh body which now also contains the hip joint to the model
     osimModel->addBody(&osim_foot);
@@ -709,7 +689,7 @@ TEST_CASE("testPointOnLineConstraint")
 
     // Need to setup model before adding an analysis since it creates the AnalysisSet
     // for the model if it does not exist.
-    State& osim_state = osimModel->initSystem();
+    SimTK::State& osim_state = osimModel->initSystem();
 
     //==========================================================================================================
     // Compare Simbody system and OpenSim model simulations
@@ -718,8 +698,6 @@ TEST_CASE("testPointOnLineConstraint")
 
 TEST_CASE("testCoordinateCouplerConstraint")
 {
-    using namespace SimTK;
-
     cout << endl;
     cout << "=================================================================" << endl;
     cout << " OpenSim CoordinateCouplerConstraint vs. FunctionBasedMobilizer  " << endl;
@@ -742,7 +720,7 @@ TEST_CASE("testCoordinateCouplerConstraint")
     SimmSpline tx(npx, angX, kneeX);
     SimmSpline ty(npy, angY, kneeY);;
 
-    // Define the functions that specify the FunctionBased Mobilized Body.
+    // Define the functions that specify the FunctionBased Mobilized SimTK::Body.
     std::vector<std::vector<int> > coordIndices;
     std::vector<const SimTK::Function*> functions;
     std::vector<bool> isdof(6,false);
@@ -752,7 +730,7 @@ TEST_CASE("testCoordinateCouplerConstraint")
     int nm = 0;
     for(int i=0; i<6; i++){
         if(isdof[i]) {
-            Vector coeff(2);
+            SimTK::Vector coeff(2);
             coeff[0] = 1;
             coeff[1] = 0;
             std::vector<int> findex(1);
@@ -777,22 +755,22 @@ TEST_CASE("testCoordinateCouplerConstraint")
     }
 
     // Define the Simbody system
-    MultibodySystem system;
-    SimbodyMatterSubsystem matter(system);
-    GeneralForceSubsystem forces(system);
+    SimTK::MultibodySystem system;
+    SimTK::SimbodyMatterSubsystem matter(system);
+    SimTK::GeneralForceSubsystem forces(system);
     SimTK::Force::UniformGravity gravity(forces, matter, gravity_vec);
     //system.updDefaultSubsystem().addEventReporter(new VTKEventReporter(system, 0.01));
 
     // Thigh connected by hip
-    MobilizedBody::Pin thigh(matter.Ground(), Transform(hipInGround), 
-        SimTK::Body::Rigid(MassProperties(femurMass, femurCOM, femurInertiaAboutCOM.shiftFromMassCenter(femurCOM, femurMass))), Transform(hipInFemur));
+    SimTK::MobilizedBody::Pin thigh(matter.Ground(), SimTK::Transform(hipInGround), 
+        SimTK::Body::Rigid(SimTK::MassProperties(femurMass, femurCOM, femurInertiaAboutCOM.shiftFromMassCenter(femurCOM, femurMass))), SimTK::Transform(hipInFemur));
     //Function-based knee connects shank
-    MobilizedBody::FunctionBased shank(thigh, Transform(kneeInFemur), SimTK::Body::Rigid(tibiaMass), Transform(kneeInTibia), nm, functions, coordIndices);
-    //MobilizedBody::Pin shank(thigh, SimTK::Transform(kneeInFemur), SimTK::Body::Rigid(tibiaMass), SimTK::Transform(kneeInTibia));
+    SimTK::MobilizedBody::FunctionBased shank(thigh, SimTK::Transform(kneeInFemur), SimTK::Body::Rigid(tibiaMass), SimTK::Transform(kneeInTibia), nm, functions, coordIndices);
+    //SimTK::MobilizedBody::Pin shank(thigh, SimTK::Transform(kneeInFemur), SimTK::Body::Rigid(tibiaMass), SimTK::Transform(kneeInTibia));
 
     // Simbody model state setup
     system.realizeTopology();
-    State state = system.getDefaultState();
+    SimTK::State state = system.getDefaultState();
     matter.setUseEulerAngles(state, true);
     system.realizeModel(state);
 
@@ -805,7 +783,7 @@ TEST_CASE("testCoordinateCouplerConstraint")
     OpenSim::Body osim_thigh("thigh", femurMass, femurCOM, femurInertiaAboutCOM);
 
     // create hip as a pin joint
-    PinJoint hip("hip",ground, hipInGround, Vec3(0), osim_thigh, hipInFemur, Vec3(0));
+    PinJoint hip("hip",ground, hipInGround, SimTK::Vec3(0), osim_thigh, hipInFemur, SimTK::Vec3(0));
 
     // Rename hip coordinates for a pin joint
     hip.updCoordinate().setName("hip_flex");
@@ -837,7 +815,7 @@ TEST_CASE("testCoordinateCouplerConstraint")
     kneeTransform[4].setFunction(new LinearFunction());
 
     // create custom knee joint
-    CustomJoint knee("knee", osim_thigh, kneeInFemur, Vec3(0), osim_shank, kneeInTibia, Vec3(0), kneeTransform);
+    CustomJoint knee("knee", osim_thigh, kneeInFemur, SimTK::Vec3(0), osim_shank, kneeInTibia, SimTK::Vec3(0), kneeTransform);
 
     // Add the shank body which now also contains the knee joint to the model
     osimModel->addBody(&osim_shank);
@@ -873,7 +851,7 @@ TEST_CASE("testCoordinateCouplerConstraint")
 
     PointKinematics *pointKin = new PointKinematics(osimModel);
     // Get the point location of the shank origin in space
-    pointKin->setBodyPoint("shank", Vec3(0));
+    pointKin->setBodyPoint("shank", SimTK::Vec3(0));
     osimModel->addAnalysis(pointKin);
 
     // Model cannot own model components created on the stack in this test program
@@ -895,7 +873,7 @@ TEST_CASE("testCoordinateCouplerConstraint")
 
     // Need to setup model before adding an analysis since it creates the AnalysisSet
     // for the model if it does not exist.
-    State& osim_state = osimModel->initSystem();
+    SimTK::State& osim_state = osimModel->initSystem();
 
     //==========================================================================================================
     // Compare Simbody system and OpenSim model simulations
@@ -922,8 +900,6 @@ TEST_CASE("testCoordinateCouplerConstraint")
 
 TEST_CASE("testRollingOnSurfaceConstraint")
 {
-    using namespace SimTK;
-
     cout << endl;
     cout << "=================================================================" << endl;
     cout << " OpenSim RollingOnSurfaceConstraint Simulation " << endl;
@@ -934,10 +910,10 @@ TEST_CASE("testRollingOnSurfaceConstraint")
     double omega = -2.1234567890;
     double halfRodLength = 1.0 / (omega*omega);
 
-    UnitVec3 surfaceNormal(0,1,0);
+    SimTK::UnitVec3 surfaceNormal(0,1,0);
     double planeHeight = 0.0;
-    Vec3 comInRod(0, halfRodLength, 0);
-    Vec3 contactPointOnRod(0, 0, 0);
+    SimTK::Vec3 comInRod(0, halfRodLength, 0);
+    SimTK::Vec3 contactPointOnRod(0, 0, 0);
 
     double mass = 7.0;
     SimTK::Inertia inertiaAboutCom = mass*SimTK::Inertia::cylinderAlongY(0.1, 1.0);
@@ -946,14 +922,14 @@ TEST_CASE("testRollingOnSurfaceConstraint")
         inertiaAboutCom.shiftFromMassCenter(comInRod, mass));
 
     // Define the Simbody system
-    MultibodySystem system;
-    SimbodyMatterSubsystem matter(system);
-    GeneralForceSubsystem forces(system);
+    SimTK::MultibodySystem system;
+    SimTK::SimbodyMatterSubsystem matter(system);
+    SimTK::GeneralForceSubsystem forces(system);
     SimTK::Force::UniformGravity gravity(forces, matter, gravity_vec);
 
     // Create a free joint between the rod and ground
-    MobilizedBody::Planar rod(matter.Ground(), Transform(Vec3(0)), 
-        SimTK::Body::Rigid(rodMass), Transform());
+    SimTK::MobilizedBody::Planar rod(matter.Ground(), SimTK::Transform(SimTK::Vec3(0)), 
+        SimTK::Body::Rigid(rodMass), SimTK::Transform());
 
     // Get underlying mobilized bodies
     SimTK::MobilizedBody surface = matter.getGround();
@@ -970,7 +946,7 @@ TEST_CASE("testRollingOnSurfaceConstraint")
     
     // Simbody model state setup
     system.realizeTopology();
-    State state = system.getDefaultState();
+    SimTK::State state = system.getDefaultState();
 
     //state = system.realizeTopology();
     state.updQ()[0] = theta;
@@ -978,12 +954,12 @@ TEST_CASE("testRollingOnSurfaceConstraint")
     state.updQ()[2] = 0;
     state.updU()[0] = omega;
 
-    system.realize(state, Stage::Acceleration);
+    system.realize(state, SimTK::Stage::Acceleration);
     state.getUDot().dump("Simbody Accelerations");
 
-    Vec3 pcom = system.getMatterSubsystem().calcSystemMassCenterLocationInGround(state);
-    Vec3 vcom = system.getMatterSubsystem().calcSystemMassCenterVelocityInGround(state);
-    Vec3 acom = system.getMatterSubsystem().calcSystemMassCenterAccelerationInGround(state);
+    SimTK::Vec3 pcom = system.getMatterSubsystem().calcSystemMassCenterLocationInGround(state);
+    SimTK::Vec3 vcom = system.getMatterSubsystem().calcSystemMassCenterVelocityInGround(state);
+    SimTK::Vec3 acom = system.getMatterSubsystem().calcSystemMassCenterAccelerationInGround(state);
 
     //==========================================================================================================
     // Setup OpenSim model
@@ -993,16 +969,16 @@ TEST_CASE("testRollingOnSurfaceConstraint")
     //OpenSim bodies
     Ground& ground = osimModel->updGround();;
     Mesh arrowGeom("arrow.vtp");
-    arrowGeom.setColor(Vec3(1, 0, 0));
+    arrowGeom.setColor(SimTK::Vec3(1, 0, 0));
     ground.attachGeometry(arrowGeom.clone());
 
     //OpenSim rod
     auto osim_rod = new OpenSim::Body("rod", mass, comInRod, inertiaAboutCom);
-    OpenSim::PhysicalOffsetFrame* cylFrame = new PhysicalOffsetFrame(*osim_rod, Transform(comInRod));
+    OpenSim::PhysicalOffsetFrame* cylFrame = new PhysicalOffsetFrame(*osim_rod, SimTK::Transform(comInRod));
     cylFrame->setName("comInRod");
     osimModel->addComponent(cylFrame);
     Mesh cylGeom("cylinder.vtp");
-    cylGeom.set_scale_factors(2 * halfRodLength*Vec3(0.1, 1, 0.1));
+    cylGeom.set_scale_factors(2 * halfRodLength*SimTK::Vec3(0.1, 1, 0.1));
     cylFrame->attachGeometry(cylGeom.clone());
 
     // create rod as a free joint
@@ -1030,7 +1006,7 @@ TEST_CASE("testRollingOnSurfaceConstraint")
     // Need to setup model before adding an analysis since it creates the AnalysisSet
     // for the model if it does not exist.
     //osimModel->setUseVisualizer(true);
-    State osim_state = osimModel->initSystem();
+    SimTK::State osim_state = osimModel->initSystem();
     roll->setIsEnforced(osim_state, true);
     osim_state.updY() = state.getY();
 
@@ -1042,11 +1018,11 @@ TEST_CASE("testRollingOnSurfaceConstraint")
     //    .setBackgroundType(SimTK::Visualizer::GroundAndSky);
     //osimModel->getVisualizer().show(osim_state);
 
-    Vec3 osim_pcom = osimModel->calcMassCenterPosition(osim_state);
-    Vec3 osim_vcom = osimModel->calcMassCenterVelocity(osim_state);
-    Vec3 osim_acom = osimModel->calcMassCenterAcceleration(osim_state);
+    SimTK::Vec3 osim_pcom = osimModel->calcMassCenterPosition(osim_state);
+    SimTK::Vec3 osim_vcom = osimModel->calcMassCenterVelocity(osim_state);
+    SimTK::Vec3 osim_acom = osimModel->calcMassCenterAcceleration(osim_state);
 
-    Vec3 tol(SimTK::SignificantReal);
+    SimTK::Vec3 tol(SimTK::SignificantReal);
 
     ASSERT_EQUAL(pcom, osim_pcom, tol);
     ASSERT_EQUAL(vcom, osim_vcom, tol);
@@ -1088,7 +1064,7 @@ TEST_CASE("testSerializeDeserialize")
         xml.writeToFile(oldModelFile);
     }
 
-    // Model with Force::isDisabled (version < 30508)
+    // Model with SimTK::Force::isDisabled (version < 30508)
     Model oldModel{oldModelFile};
     oldModel.print(newModelFile);
     Model newModel{newModelFile};
@@ -1108,4 +1084,4 @@ TEST_CASE("testSerializeDeserialize")
 
     std::remove(oldModelFile.c_str());
     std::remove(newModelFile.c_str());
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/SimbodyEngine/Test/testJoints.cpp b/OpenSim/Simulation/SimbodyEngine/Test/testJoints.cpp
index 4b9121fce..94f2df75f 100644
--- a/OpenSim/Simulation/SimbodyEngine/Test/testJoints.cpp
+++ b/OpenSim/Simulation/SimbodyEngine/Test/testJoints.cpp
@@ -149,10 +149,8 @@ namespace {
     // Common Functions
     //==========================================================================
     int initTestStates(SimTK::Vector& qi, SimTK::Vector& ui) {
-        using namespace SimTK;
-
-        Random::Uniform randomAngle(-Pi / 4, Pi / 4);
-        Random::Uniform randomSpeed(-1.0, 1.0);
+        SimTK::Random::Uniform randomAngle(-SimTK::Pi / 4, SimTK::Pi / 4);
+        SimTK::Random::Uniform randomSpeed(-1.0, 1.0);
 
         // Provide initial states as random angles and speeds for OpenSim and
         // Simbody models
@@ -165,25 +163,21 @@ namespace {
 
     void integrateSimbodySystem(
             SimTK::MultibodySystem& system, SimTK::State& state) {
-        using namespace SimTK;
-
         // realize simbody system to velocity stage
-        system.realize(state, Stage::Velocity);
+        system.realize(state, SimTK::Stage::Velocity);
 
-        RungeKuttaFeldbergIntegrator integ(system);
+        SimTK::RungeKuttaFeldbergIntegrator integ(system);
         integ.setAccuracy(integ_accuracy);
 
-        TimeStepper ts(system, integ);
+        SimTK::TimeStepper ts(system, integ);
         ts.initialize(state);
         ts.stepTo(duration);
         state = ts.getState();
     }
 
     void integrateOpenSimModel(Model* osimModel, SimTK::State& osim_state) {
-        using namespace SimTK;
-
         // SETUP OpenSim SIMULATION Manager
-        osimModel->getMultibodySystem().realize(osim_state, Stage::Velocity);
+        osimModel->getMultibodySystem().realize(osim_state, SimTK::Stage::Velocity);
         Manager manager(*osimModel);
         manager.setIntegratorMethod(Manager::IntegratorMethod::RungeKuttaFeldberg);
         manager.setIntegratorAccuracy(integ_accuracy);
@@ -196,7 +190,7 @@ namespace {
         manager.initialize(osim_state);
 
         // Integrate
-        /*const SimbodyMatterSubsystem& matter2 = */ osimModel->getMultibodySystem()
+        /*const SimTK::SimbodyMatterSubsystem& matter2 = */ osimModel->getMultibodySystem()
                 .getMatterSubsystem();
         // for (int i = 0; i < matter2.getNumConstraints(); i++)
         //    printf("%d: %d\n", i, matter2.isConstraintDisabled(osim_state,
@@ -210,10 +204,8 @@ namespace {
     void compareSimulationStates(const SimTK::Vector& q_sb,
             const SimTK::Vector& u_sb, const SimTK::Vector& q_osim,
             const SimTK::Vector& u_osim, string errorMessagePrefix = "") {
-        using namespace SimTK;
-
-        Vector q_err = q_osim;
-        Vector u_err = u_sb - u_osim;
+        SimTK::Vector q_err = q_osim;
+        SimTK::Vector u_err = u_sb - u_osim;
 
         int nq = q_osim.size();
         if (q_sb.size() > nq) { // we have an unused quaternion slot in Simbody
@@ -267,23 +259,21 @@ namespace {
     void compareSimulations(SimTK::MultibodySystem& system, SimTK::State& state,
             Model* osimModel, SimTK::State& osim_state,
             string errorMessagePrefix = "") {
-        using namespace SimTK;
-
         // Set the initial states for both Simbody system and OpenSim model
-        Vector& q = state.updQ();
-        Vector& u = state.updU();
+        SimTK::Vector& q = state.updQ();
+        SimTK::Vector& u = state.updU();
         /*int nq_sb = */ initTestStates(q, u);
         /*int nq = */ osim_state.getNQ();
 
         // Push down to OpenSim "state"
         osim_state.updY() = state.getY();
-        Vector delta = osim_state.updY() - state.getY();
+        SimTK::Vector delta = osim_state.updY() - state.getY();
         /*double errnorm = */ delta.norm();
         cout << "osim_state - sb_state: " << delta << endl;
 
         /* Debugging Info */
-        // system.realize(state, Stage::Acceleration);
-        // osimModel->getSystem().realize(osim_state, Stage::Acceleration);
+        // system.realize(state, SimTK::Stage::Acceleration);
+        // osimModel->getSystem().realize(osim_state, SimTK::Stage::Acceleration);
 
         // state.getUDot().dump("Simbody UDot");
         // osim_state.getUDot().dump("OpenSim UDot");
@@ -304,8 +294,8 @@ namespace {
         integrateOpenSimModel(osimModel, osim_state);
 
         // Get the state at the end of the integration from OpenSim.
-        Vector& qos = osim_state.updQ();
-        Vector& uos = osim_state.updU();
+        SimTK::Vector& qos = osim_state.updQ();
+        SimTK::Vector& uos = osim_state.updU();
         cout << "\nOpenSim Final q's: " << qos << endl;
         cout << "OpenSim Final u's: " << uos << endl;
 
@@ -316,28 +306,26 @@ namespace {
     //==========================================================================
 
     void testEquivalentBodyForceForGenForces(Model& model) {
-        using namespace SimTK;
-
-        State& state = model.initSystem();
-        Vector& qi = state.updQ();
-        Vector& ui = state.updU();
+        SimTK::State& state = model.initSystem();
+        SimTK::Vector& qi = state.updQ();
+        SimTK::Vector& ui = state.updU();
         // Randomly select the initial state of this model
         /*int nq = */ initTestStates(qi, ui);
 
-        const SimbodyMatterSubsystem& matter = model.getMatterSubsystem();
+        const SimTK::SimbodyMatterSubsystem& matter = model.getMatterSubsystem();
 
         // The number of mobilities for the entire system.
         int nm = matter.getNumMobilities();
 
-        Vector genForces(nm, 0.0);
-        Random::Uniform genForceRandom(-1000, 1000);
+        SimTK::Vector genForces(nm, 0.0);
+        SimTK::Random::Uniform genForceRandom(-1000, 1000);
         for (int i = 0; i < nm; ++i) { genForces[i] = genForceRandom.getValue(); }
 
         int nb = matter.getNumBodies();
-        Vector_<SpatialVec> bodyForces(nb, SpatialVec(Vec3(0), Vec3(0)));
+        SimTK::Vector_<SimTK::SpatialVec> bodyForces(nb, SimTK::SpatialVec(SimTK::Vec3(0), SimTK::Vec3(0)));
 
-        Vector udot1(nm);
-        Vector_<SpatialVec> bodyAccs(nb);
+        SimTK::Vector udot1(nm);
+        SimTK::Vector_<SimTK::SpatialVec> bodyAccs(nb);
 
         model.getMultibodySystem().realize(state, SimTK::Stage::Acceleration);
         matter.calcAcceleration(state, genForces, bodyForces, udot1, bodyAccs);
@@ -347,22 +335,22 @@ namespace {
         for (int j = 0; j < model.getJointSet().getSize(); ++j) {
             Joint& joint = model.getJointSet()[j];
             const PhysicalFrame& B = joint.getChildFrame();
-            MobilizedBodyIndex mbx = B.getMobilizedBodyIndex();
+            SimTK::MobilizedBodyIndex mbx = B.getMobilizedBodyIndex();
             const Frame& Bo = B.findBaseFrame();
 
             const PhysicalFrame& P = joint.getParentFrame();
-            MobilizedBodyIndex mpx = P.getMobilizedBodyIndex();
+            SimTK::MobilizedBodyIndex mpx = P.getMobilizedBodyIndex();
             const Frame& Po = P.findBaseFrame();
 
-            Vec3 rB_Bo(0), rB_Po(0);
+            SimTK::Vec3 rB_Bo(0), rB_Po(0);
             rB_Bo = joint.getChildFrame().findTransformInBaseFrame().p();
 
-            // Get Joint frame B location in parent, Po, to apply to parent Body
+            // Get Joint frame B location in parent, Po, to apply to parent SimTK::Body
             rB_Po = Bo.findStationLocationInAnotherFrame(state, rB_Bo, Po);
 
             // get the equivalent spatial force on the joint frame of the (child)
             // body expressed in ground
-            SpatialVec FB_G = joint.calcEquivalentSpatialForce(state, genForces);
+            SimTK::SpatialVec FB_G = joint.calcEquivalentSpatialForce(state, genForces);
 
             cout << joint.getName() << " equivalent FB_G = " << FB_G << endl;
 
@@ -375,14 +363,14 @@ namespace {
             matter.addInBodyTorque(state, mpx, -FB_G[0], bodyForces);
         }
 
-        Vector udot2(nm);
+        SimTK::Vector udot2(nm);
         matter.calcAcceleration(
                 state, 0.0 * genForces, bodyForces, udot2, bodyAccs);
 
         // If calcEquivalentSpatialForce is correct then the two methods of applying
         // forces to the model should be equivalent and the accelerations should be
         // identical
-        Vector error = udot2 - udot1;
+        SimTK::Vector error = udot2 - udot1;
         double norm_rel_error = error.norm() / udot1.norm();
 
         cout << "**************************************************************"
@@ -395,15 +383,13 @@ namespace {
              << endl;
 
         ASSERT(!SimTK::isNaN(norm_rel_error), __FILE__, __LINE__,
-                "testEquivalentBodyForceForGenForces FAILED, udot_error = NaN");
+                "testEquivalentBodyForceForGenForces FAILED, udot_error = SimTK::NaN");
         ASSERT(norm_rel_error <= SimTK::SignificantReal, __FILE__, __LINE__,
                 "testEquivalentBodyForceForGenForces FAILED, udot_error > "
                 "SimTK::SignificantReal");
     }
 
     void testWeldJoint(bool randomizeBodyOrder) {
-        using namespace SimTK;
-
         cout << endl;
         cout << "================================================================"
              << endl;
@@ -412,28 +398,28 @@ namespace {
              << endl;
 
         // Define the Simbody system
-        MultibodySystem system;
-        SimbodyMatterSubsystem matter(system);
-        GeneralForceSubsystem forces(system);
+        SimTK::MultibodySystem system;
+        SimTK::SimbodyMatterSubsystem matter(system);
+        SimTK::GeneralForceSubsystem forces(system);
         SimTK::Force::UniformGravity gravity(forces, matter, gravity_vec);
 
         // Thigh connected by hip
-        MobilizedBody::Universal thigh(matter.Ground(),
+        SimTK::MobilizedBody::Universal thigh(matter.Ground(),
                 SimTK::Transform(hipInPelvis), SimTK::Body::Rigid(femurMass),
                 SimTK::Transform(hipInFemur));
         // Function-based knee connects shank
-        MobilizedBody::Pin shank(thigh, SimTK::Transform(kneeInFemur),
+        SimTK::MobilizedBody::Pin shank(thigh, SimTK::Transform(kneeInFemur),
                 SimTK::Body::Rigid(tibiaMass), SimTK::Transform(kneeInTibia));
         // Weld foot to shank at ankle
-        MobilizedBody::Weld foot(shank, SimTK::Transform(ankleInTibia),
+        SimTK::MobilizedBody::Weld foot(shank, SimTK::Transform(ankleInTibia),
                 SimTK::Body::Rigid(footMass), SimTK::Transform(ankleInFoot));
         // fixed toes at right mtp
-        MobilizedBody::Weld toes(foot, SimTK::Transform(mtpInFoot),
+        SimTK::MobilizedBody::Weld toes(foot, SimTK::Transform(mtpInFoot),
                 SimTK::Body::Rigid(toesMass), SimTK::Transform(mtpInToes));
 
         // Simbody model state setup
         system.realizeTopology();
-        State state = system.getDefaultState();
+        SimTK::State state = system.getDefaultState();
         matter.setUseEulerAngles(state, true);
         system.realizeModel(state);
 
@@ -466,8 +452,8 @@ namespace {
 
         // create custom hip joint
         CustomJoint hip("hip", ground, hipInPelvis,
-                Vec3(0), osim_thigh, hipInFemur,
-                Vec3(0), hipTransform);
+                SimTK::Vec3(0), osim_thigh, hipInFemur,
+                SimTK::Vec3(0), hipTransform);
 
         tempBodySet.adoptAndAppend(&osim_thigh);
         tempJointSet.adoptAndAppend(&hip);
@@ -484,8 +470,8 @@ namespace {
 
         // create custom knee joint
         CustomJoint knee("knee", osim_thigh, kneeInFemur,
-                Vec3(0), osim_shank, kneeInTibia,
-                Vec3(0), kneeTransform);
+                SimTK::Vec3(0), osim_shank, kneeInTibia,
+                SimTK::Vec3(0), kneeTransform);
 
         tempBodySet.adoptAndAppend(&osim_shank);
         tempJointSet.adoptAndAppend(&knee);
@@ -494,8 +480,8 @@ namespace {
         OpenSim::Body osim_foot("foot", footMass.getMass(),
                 footMass.getMassCenter(), footMass.getInertia());
         WeldJoint ankle("ankle", osim_shank, ankleInTibia,
-                Vec3(0), osim_foot,
-                ankleInFoot, Vec3(0));
+                SimTK::Vec3(0), osim_foot,
+                ankleInFoot, SimTK::Vec3(0));
 
         tempBodySet.adoptAndAppend(&osim_foot);
         tempJointSet.adoptAndAppend(&ankle);
@@ -504,8 +490,8 @@ namespace {
         OpenSim::Body osim_toes("toes", toesMass.getMass(),
                 toesMass.getMassCenter(), toesMass.getInertia());
         WeldJoint mtp("mtp", osim_foot, mtpInFoot,
-                Vec3(0), osim_toes, mtpInToes,
-                Vec3(0));
+                SimTK::Vec3(0), osim_toes, mtpInToes,
+                SimTK::Vec3(0));
 
         tempBodySet.adoptAndAppend(&osim_toes);
         tempJointSet.adoptAndAppend(&mtp);
@@ -518,7 +504,7 @@ namespace {
             cout << "=========================================================="
                     "======"
                  << endl;
-            Random::Uniform randomOrder(0, 4);
+            SimTK::Random::Uniform randomOrder(0, 4);
             randomOrder.setSeed((int)clock());
 
             int bx = -1, jx = -1;
@@ -610,8 +596,6 @@ namespace {
 /// First compare behavior of a double pendulum with Universal hip and
 /// Pin-like knee
 TEST_CASE("testCustomVsUniversalPin") {
-    using namespace SimTK;
-
     cout << endl;
     cout << "=========================================================="
          << endl;
@@ -621,22 +605,22 @@ TEST_CASE("testCustomVsUniversalPin") {
          << endl;
 
     // Define the Simbody system
-    MultibodySystem system;
-    SimbodyMatterSubsystem matter(system);
-    GeneralForceSubsystem forces(system);
+    SimTK::MultibodySystem system;
+    SimTK::SimbodyMatterSubsystem matter(system);
+    SimTK::GeneralForceSubsystem forces(system);
     SimTK::Force::UniformGravity gravity(forces, matter, gravity_vec);
 
     // Thigh connected by hip
-    MobilizedBody::Universal thigh(matter.Ground(),
+    SimTK::MobilizedBody::Universal thigh(matter.Ground(),
             SimTK::Transform(hipInPelvis), SimTK::Body::Rigid(femurMass),
             SimTK::Transform(hipInFemur));
     // Function-based knee connects shank
-    MobilizedBody::Pin shank(thigh, SimTK::Transform(kneeInFemur),
+    SimTK::MobilizedBody::Pin shank(thigh, SimTK::Transform(kneeInFemur),
             SimTK::Body::Rigid(tibiaMass), SimTK::Transform(kneeInTibia));
 
     // Simbody model state setup
     system.realizeTopology();
-    State state = system.getDefaultState();
+    SimTK::State state = system.getDefaultState();
     matter.setUseEulerAngles(state, true);
     system.realizeModel(state);
 
@@ -661,8 +645,8 @@ TEST_CASE("testCustomVsUniversalPin") {
 
     // create custom hip joint
     CustomJoint hip("hip", ground, hipInPelvis,
-            Vec3(0), osim_thigh, hipInFemur,
-            Vec3(0), hipTransform);
+            SimTK::Vec3(0), osim_thigh, hipInFemur,
+            SimTK::Vec3(0), hipTransform);
 
     // Add the thigh body which now also contains the hip joint to the model
     osimModel.addBody(&osim_thigh);
@@ -682,8 +666,8 @@ TEST_CASE("testCustomVsUniversalPin") {
 
     // create custom knee joint
     CustomJoint knee("knee", osim_thigh, kneeInFemur,
-            Vec3(0), osim_shank,
-            kneeInTibia, Vec3(0), kneeTransform);
+            SimTK::Vec3(0), osim_shank,
+            kneeInTibia, SimTK::Vec3(0), kneeTransform);
 
     // Add the shank body which now also contains the knee joint to the model
     osimModel.addBody(&osim_shank);
@@ -715,8 +699,6 @@ TEST_CASE("testCustomVsUniversalPin") {
 /// Compare behavior of a double pendulum with pin hip and function-based
 /// translating tibia knee
 TEST_CASE("testCustomJointVsFunctionBased") {
-    using namespace SimTK;
-
     cout << endl;
     cout << "=========================================================="
          << endl;
@@ -751,7 +733,7 @@ TEST_CASE("testCustomJointVsFunctionBased") {
     SimmSpline ty(npy, angY, kneeY);
     ;
 
-    // Define the functions that specify the FunctionBased Mobilized Body.
+    // Define the functions that specify the FunctionBased Mobilized SimTK::Body.
     std::vector<std::vector<int>> coordIndices;
     std::vector<const SimTK::Function*> functions;
     std::vector<bool> isdof(6, false);
@@ -761,7 +743,7 @@ TEST_CASE("testCustomJointVsFunctionBased") {
     int nm = 0;
     for (int i = 0; i < 6; i++) {
         if (isdof[i]) {
-            Vector coeff(2);
+            SimTK::Vector coeff(2);
             coeff[0] = 1;
             coeff[1] = 0;
             std::vector<int> findex(1);
@@ -784,24 +766,24 @@ TEST_CASE("testCustomJointVsFunctionBased") {
     }
 
     // Define the Simbody system
-    MultibodySystem system;
-    SimbodyMatterSubsystem matter(system);
-    GeneralForceSubsystem forces(system);
+    SimTK::MultibodySystem system;
+    SimTK::SimbodyMatterSubsystem matter(system);
+    SimTK::GeneralForceSubsystem forces(system);
     SimTK::Force::UniformGravity gravity(forces, matter, gravity_vec);
     // system.updDefaultSubsystem().addEventReporter(new
     // VTKEventReporter(system, 0.01));
 
     // Thigh connected by hip
-    MobilizedBody::Pin thigh(matter.Ground(), SimTK::Transform(hipInPelvis),
+    SimTK::MobilizedBody::Pin thigh(matter.Ground(), SimTK::Transform(hipInPelvis),
             SimTK::Body::Rigid(femurMass), SimTK::Transform(hipInFemur));
     // Function-based knee connects shank
-    MobilizedBody::FunctionBased shank(thigh, SimTK::Transform(kneeInFemur),
+    SimTK::MobilizedBody::FunctionBased shank(thigh, SimTK::Transform(kneeInFemur),
             SimTK::Body::Rigid(tibiaMass), SimTK::Transform(kneeInTibia), nm,
             functions, coordIndices);
 
     // Simbody model state setup
     system.realizeTopology();
-    State state = system.getDefaultState();
+    SimTK::State state = system.getDefaultState();
     system.realizeModel(state);
 
     //==========================================================================
@@ -821,8 +803,8 @@ TEST_CASE("testCustomJointVsFunctionBased") {
 
     // create custom hip joint
     CustomJoint hip("hip", ground, hipInPelvis,
-            Vec3(0), osim_thigh, hipInFemur,
-            Vec3(0), hipTransform);
+            SimTK::Vec3(0), osim_thigh, hipInFemur,
+            SimTK::Vec3(0), hipTransform);
 
     // Add the thigh body which now also contains the hip joint to the model
     osimModel->addBody(&osim_thigh);
@@ -849,8 +831,8 @@ TEST_CASE("testCustomJointVsFunctionBased") {
     kneeTransform[4].setFunction(ty);
 
     // create custom knee joint
-    CustomJoint knee("knee", osim_thigh, kneeInFemur, Vec3(0), osim_shank,
-            kneeInTibia, Vec3(0), kneeTransform);
+    CustomJoint knee("knee", osim_thigh, kneeInFemur, SimTK::Vec3(0), osim_shank,
+            kneeInTibia, SimTK::Vec3(0), kneeTransform);
 
     // Add the shank body which now also contains the knee joint to the model
     osimModel->addBody(&osim_shank);
@@ -879,37 +861,35 @@ TEST_CASE("testCustomJointVsFunctionBased") {
 
 /// Compare behavior of a double pendulum with an Ellipsoid hip and pin knee
 TEST_CASE("testEllipsoidJoint") {
-    using namespace SimTK;
-
     cout << endl;
     cout << "============================================================="
          << endl;
-    cout << " OpenSim EllipsoidJoint vs. Simbody MobilizedBody::Ellipsoid "
+    cout << " OpenSim EllipsoidJoint vs. Simbody SimTK::MobilizedBody::Ellipsoid "
          << endl;
     cout << "============================================================="
          << endl;
 
     // Ellipsoid radii
-    Vec3 ellipsoidRadii(0.5, 0.33, 0.25);
+    SimTK::Vec3 ellipsoidRadii(0.5, 0.33, 0.25);
 
     // Define the Simbody system
-    MultibodySystem system;
-    SimbodyMatterSubsystem matter(system);
-    GeneralForceSubsystem forces(system);
+    SimTK::MultibodySystem system;
+    SimTK::SimbodyMatterSubsystem matter(system);
+    SimTK::GeneralForceSubsystem forces(system);
     SimTK::Force::UniformGravity gravity(forces, matter, gravity_vec);
 
     // Thigh connected by hip
-    MobilizedBody::Ellipsoid thigh(matter.Ground(),
+    SimTK::MobilizedBody::Ellipsoid thigh(matter.Ground(),
             SimTK::Transform(hipInPelvis), SimTK::Body::Rigid(femurMass),
             SimTK::Transform(hipInFemur));
     // Pin knee connects shank
-    MobilizedBody::Pin shank(thigh, SimTK::Transform(kneeInFemur),
+    SimTK::MobilizedBody::Pin shank(thigh, SimTK::Transform(kneeInFemur),
             SimTK::Body::Rigid(tibiaMass), SimTK::Transform(kneeInTibia));
 
     thigh.setDefaultRadii(ellipsoidRadii);
     // Simbody model state setup
     system.realizeTopology();
-    State state = system.getDefaultState();
+    SimTK::State state = system.getDefaultState();
     matter.setUseEulerAngles(state, true);
     system.realizeModel(state);
 
@@ -925,8 +905,8 @@ TEST_CASE("testEllipsoidJoint") {
             femurMass.getMassCenter(), femurMass.getInertia());
 
     // create hip as an ellipsoid joint
-    EllipsoidJoint hip("hip", ground, hipInPelvis, Vec3(0), osim_thigh,
-            hipInFemur, Vec3(0), ellipsoidRadii);
+    EllipsoidJoint hip("hip", ground, hipInPelvis, SimTK::Vec3(0), osim_thigh,
+            hipInFemur, SimTK::Vec3(0), ellipsoidRadii);
 
     // Rename hip coordinates for an ellipsoid joint
     for (int i = 0; i < hip.numCoordinates(); i++) {
@@ -944,8 +924,8 @@ TEST_CASE("testEllipsoidJoint") {
             tibiaMass.getMassCenter(), tibiaMass.getInertia());
 
     // create pin knee joint
-    PinJoint knee("knee", osim_thigh, kneeInFemur, Vec3(0), osim_shank,
-            kneeInTibia, Vec3(0));
+    PinJoint knee("knee", osim_thigh, kneeInFemur, SimTK::Vec3(0), osim_shank,
+            kneeInTibia, SimTK::Vec3(0));
 
     // Add the shank body which now also contains the knee joint to the model
     osimModel->addBody(&osim_shank);
@@ -1016,31 +996,29 @@ TEST_CASE("testWeldJoint randomized") {
 /// EllipsoidJoint and the fact that coordinates cannot map to/from
 /// quaternions
 TEST_CASE("testFreeJoint") {
-    using namespace SimTK;
-
     cout << endl;
     cout << "============================================================="
          << endl;
-    cout << " OpenSim FreeJoint vs. Simbody MobilizedBody::Free " << endl;
+    cout << " OpenSim FreeJoint vs. Simbody SimTK::MobilizedBody::Free " << endl;
     cout << "============================================================="
          << endl;
 
     // Define the Simbody system
-    MultibodySystem system;
-    SimbodyMatterSubsystem matter(system);
-    GeneralForceSubsystem forces(system);
+    SimTK::MultibodySystem system;
+    SimTK::SimbodyMatterSubsystem matter(system);
+    SimTK::GeneralForceSubsystem forces(system);
     SimTK::Force::UniformGravity gravity(forces, matter, gravity_vec);
 
     // Thigh connected by hip
-    MobilizedBody::Free thigh(matter.Ground(), SimTK::Transform(hipInPelvis),
+    SimTK::MobilizedBody::Free thigh(matter.Ground(), SimTK::Transform(hipInPelvis),
             SimTK::Body::Rigid(femurMass), SimTK::Transform(hipInFemur));
     // Function-based knee connects shank
-    MobilizedBody::Pin shank(thigh, SimTK::Transform(kneeInFemur),
+    SimTK::MobilizedBody::Pin shank(thigh, SimTK::Transform(kneeInFemur),
             SimTK::Body::Rigid(tibiaMass), SimTK::Transform(kneeInTibia));
 
     // Simbody model state setup
     system.realizeTopology();
-    State state = system.getDefaultState();
+    SimTK::State state = system.getDefaultState();
     matter.setUseEulerAngles(state, true);
     system.realizeModel(state);
 
@@ -1057,8 +1035,8 @@ TEST_CASE("testFreeJoint") {
 
     // create free hip joint
     FreeJoint hip("hip", ground, hipInPelvis,
-            Vec3(0), osim_thigh, hipInFemur,
-            Vec3(0));
+            SimTK::Vec3(0), osim_thigh, hipInFemur,
+            SimTK::Vec3(0));
 
     // Rename hip coordinates for a free joint
     for (int i = 0; i < hip.numCoordinates(); i++) {
@@ -1082,8 +1060,8 @@ TEST_CASE("testFreeJoint") {
     kneeTransform[2].setFunction(new LinearFunction());
 
     // create custom knee joint
-    CustomJoint knee("knee", osim_thigh, kneeInFemur, Vec3(0), osim_shank,
-            kneeInTibia, Vec3(0), kneeTransform);
+    CustomJoint knee("knee", osim_thigh, kneeInFemur, SimTK::Vec3(0), osim_shank,
+            kneeInTibia, SimTK::Vec3(0), kneeTransform);
 
     // Add the shank body which now also contains the knee joint to the model
     osimModel->addBody(&osim_shank);
@@ -1164,10 +1142,10 @@ TEST_CASE("testScapulothoracicJoint") {
         Model m;
         m.setName(__FUNCTION__);
 
-        auto thorax = new Body{"thorax", femurMass.getMass(),
+        auto thorax = new OpenSim::Body{"thorax", femurMass.getMass(),
                 femurMass.getMassCenter(), femurMass.getInertia()};
 
-        auto scapula = new Body{"scapula", footMass.getMass(),
+        auto scapula = new OpenSim::Body{"scapula", footMass.getMass(),
                 footMass.getMassCenter(), footMass.getInertia()};
 
         m.addBody(thorax);
@@ -1232,31 +1210,29 @@ TEST_CASE("testScapulothoracicJoint") {
 /// support EllipsoidJoint and the fact that coordinates cannot map to/from
 /// quaternions
 TEST_CASE("testBallJoint") {
-    using namespace SimTK;
-
     cout << endl;
     cout << "============================================================="
          << endl;
-    cout << " OpenSim BallJoint vs. Simbody MobilizedBody::Ball " << endl;
+    cout << " OpenSim BallJoint vs. Simbody SimTK::MobilizedBody::Ball " << endl;
     cout << "============================================================="
          << endl;
 
     // Define the Simbody system
-    MultibodySystem system;
-    SimbodyMatterSubsystem matter(system);
-    GeneralForceSubsystem forces(system);
+    SimTK::MultibodySystem system;
+    SimTK::SimbodyMatterSubsystem matter(system);
+    SimTK::GeneralForceSubsystem forces(system);
     SimTK::Force::UniformGravity gravity(forces, matter, gravity_vec);
 
     // Thigh connected by hip
-    MobilizedBody::Ball thigh(matter.Ground(), SimTK::Transform(hipInPelvis),
+    SimTK::MobilizedBody::Ball thigh(matter.Ground(), SimTK::Transform(hipInPelvis),
             SimTK::Body::Rigid(femurMass), SimTK::Transform(hipInFemur));
     // Function-based knee connects shank
-    MobilizedBody::Pin shank(thigh, SimTK::Transform(kneeInFemur),
+    SimTK::MobilizedBody::Pin shank(thigh, SimTK::Transform(kneeInFemur),
             SimTK::Body::Rigid(tibiaMass), SimTK::Transform(kneeInTibia));
 
     // Simbody model state setup
     system.realizeTopology();
-    State state = system.getDefaultState();
+    SimTK::State state = system.getDefaultState();
     matter.setUseEulerAngles(state, true);
     system.realizeModel(state);
 
@@ -1272,8 +1248,8 @@ TEST_CASE("testBallJoint") {
 
     // create hip as an Ball joint
     BallJoint hip("hip", ground, hipInPelvis,
-            Vec3(0), osim_thigh, hipInFemur,
-            Vec3(0));
+            SimTK::Vec3(0), osim_thigh, hipInFemur,
+            SimTK::Vec3(0));
 
     // Rename hip coordinates for a ball joint
     for (int i = 0; i < hip.numCoordinates(); i++) {
@@ -1291,8 +1267,8 @@ TEST_CASE("testBallJoint") {
             tibiaMass.getMassCenter(), tibiaMass.getInertia());
 
     // create pin knee joint
-    PinJoint knee("knee", osim_thigh, kneeInFemur, Vec3(0), osim_shank,
-            kneeInTibia, Vec3(0));
+    PinJoint knee("knee", osim_thigh, kneeInFemur, SimTK::Vec3(0), osim_shank,
+            kneeInTibia, SimTK::Vec3(0));
 
     // Rename knee coordinates for a pin joint
     knee.upd_coordinates(0).setName("knee_q");
@@ -1344,43 +1320,41 @@ TEST_CASE("testBallJoint") {
 
 /// Compare behavior of a double pendulum with OpenSim pin hip and pin knee
 TEST_CASE("testPinJoint") {
-    using namespace SimTK;
-
     cout << endl;
     cout << "============================================================="
          << endl;
-    cout << " OpenSim PinJoint vs. Simbody MobilizedBody::Pin " << endl;
+    cout << " OpenSim PinJoint vs. Simbody SimTK::MobilizedBody::Pin " << endl;
     cout << "============================================================="
          << endl;
 
-    Random::Uniform randomAngle(-Pi / 2, Pi / 2);
-    Vec3 oInB(randomAngle.getValue(), randomAngle.getValue(),
+    SimTK::Random::Uniform randomAngle(-SimTK::Pi / 2, SimTK::Pi / 2);
+    SimTK::Vec3 oInB(randomAngle.getValue(), randomAngle.getValue(),
             randomAngle.getValue());
-    Vec3 oInP(randomAngle.getValue(), randomAngle.getValue(),
+    SimTK::Vec3 oInP(randomAngle.getValue(), randomAngle.getValue(),
             randomAngle.getValue());
 
     // Define the Simbody system
-    MultibodySystem system;
-    SimbodyMatterSubsystem matter(system);
-    GeneralForceSubsystem forces(system);
+    SimTK::MultibodySystem system;
+    SimTK::SimbodyMatterSubsystem matter(system);
+    SimTK::GeneralForceSubsystem forces(system);
     SimTK::Force::UniformGravity gravity(forces, matter, gravity_vec);
 
     // Thigh connected by hip
-    MobilizedBody::Pin thigh(matter.Ground(), SimTK::Transform(hipInPelvis),
+    SimTK::MobilizedBody::Pin thigh(matter.Ground(), SimTK::Transform(hipInPelvis),
             SimTK::Body::Rigid(femurMass), SimTK::Transform(hipInFemur));
     // Pin knee connects shank
-    MobilizedBody::Pin shank(thigh,
-            SimTK::Transform(Rotation(BodyRotationSequence, oInP[0], XAxis,
-                                     oInP[1], YAxis, oInP[2], ZAxis),
+    SimTK::MobilizedBody::Pin shank(thigh,
+            SimTK::Transform(SimTK::Rotation(SimTK::BodyRotationSequence, oInP[0], SimTK::XAxis,
+                                     oInP[1], SimTK::YAxis, oInP[2], SimTK::YAxis),
                     kneeInFemur),
             SimTK::Body::Rigid(tibiaMass),
-            SimTK::Transform(Rotation(BodyRotationSequence, oInB[0], XAxis,
-                                     oInB[1], YAxis, oInB[2], ZAxis),
+            SimTK::Transform(SimTK::Rotation(SimTK::BodyRotationSequence, oInB[0], SimTK::XAxis,
+                                     oInB[1], SimTK::YAxis, oInB[2], SimTK::YAxis),
                     kneeInTibia));
 
     // Simbody model state setup
     system.realizeTopology();
-    State state = system.getDefaultState();
+    SimTK::State state = system.getDefaultState();
     matter.setUseEulerAngles(state, true);
     system.realizeModel(state);
 
@@ -1399,8 +1373,8 @@ TEST_CASE("testPinJoint") {
 
     // create hip as a pin joint
     PinJoint hip("hip", ground, hipInPelvis,
-            Vec3(0), osim_thigh, hipInFemur,
-            Vec3(0));
+            SimTK::Vec3(0), osim_thigh, hipInFemur,
+            SimTK::Vec3(0));
 
     // Rename hip coordinates for a pin joint
     for (int i = 0; i < hip.numCoordinates(); i++) {
@@ -1430,13 +1404,13 @@ TEST_CASE("testPinJoint") {
     ASSERT(knee2.get_coordinates(0).getName() == "knee_q");
 
     auto* thigh_offset = new PhysicalOffsetFrame("thigh_offset", osim_thigh,
-            SimTK::Transform(Rotation(BodyRotationSequence, oInP[0], XAxis,
-                                     oInP[1], YAxis, oInP[2], ZAxis),
+            SimTK::Transform(SimTK::Rotation(SimTK::BodyRotationSequence, oInP[0], SimTK::XAxis,
+                                     oInP[1], SimTK::YAxis, oInP[2], SimTK::YAxis),
                     kneeInFemur));
 
     auto* shank_offset = new PhysicalOffsetFrame("shank_offset", osim_shank,
-            SimTK::Transform(Rotation(BodyRotationSequence, oInB[0], XAxis,
-                                     oInB[1], YAxis, oInB[2], ZAxis),
+            SimTK::Transform(SimTK::Rotation(SimTK::BodyRotationSequence, oInB[0], SimTK::XAxis,
+                                     oInB[1], SimTK::YAxis, oInB[2], SimTK::YAxis),
                     kneeInTibia));
 
     // Exercise new convenience constructor with common use case of adding
@@ -1506,43 +1480,41 @@ TEST_CASE("testPinJoint") {
 
 /// Compare behavior of a two body pendulum with OpenSim pin hip and slider knee
 TEST_CASE("testSliderJoint") {
-    using namespace SimTK;
-
     cout << endl;
     cout << "============================================================="
          << endl;
-    cout << " OpenSim SliderJoint vs. Simbody MobilizedBody::Slider " << endl;
+    cout << " OpenSim SliderJoint vs. Simbody SimTK::MobilizedBody::Slider " << endl;
     cout << "============================================================="
          << endl;
 
-    Random::Uniform randomAngle(-Pi / 2, Pi / 2);
-    Vec3 oInB(randomAngle.getValue(), randomAngle.getValue(),
+    SimTK::Random::Uniform randomAngle(-SimTK::Pi / 2, SimTK::Pi / 2);
+    SimTK::Vec3 oInB(randomAngle.getValue(), randomAngle.getValue(),
             randomAngle.getValue());
-    Vec3 oInP(randomAngle.getValue(), randomAngle.getValue(),
+    SimTK::Vec3 oInP(randomAngle.getValue(), randomAngle.getValue(),
             randomAngle.getValue());
 
     // Define the Simbody system
-    MultibodySystem system;
-    SimbodyMatterSubsystem matter(system);
-    GeneralForceSubsystem forces(system);
+    SimTK::MultibodySystem system;
+    SimTK::SimbodyMatterSubsystem matter(system);
+    SimTK::GeneralForceSubsystem forces(system);
     SimTK::Force::UniformGravity gravity(forces, matter, gravity_vec);
 
     // Thigh connected by hip
-    MobilizedBody::Pin thigh(matter.Ground(), SimTK::Transform(hipInPelvis),
+    SimTK::MobilizedBody::Pin thigh(matter.Ground(), SimTK::Transform(hipInPelvis),
             SimTK::Body::Rigid(femurMass), SimTK::Transform(hipInFemur));
     // Pin knee connects shank
-    MobilizedBody::Slider shank(thigh,
-            SimTK::Transform(Rotation(BodyRotationSequence, oInP[0], XAxis,
-                                     oInP[1], YAxis, oInP[2], ZAxis),
+    SimTK::MobilizedBody::Slider shank(thigh,
+            SimTK::Transform(SimTK::Rotation(SimTK::BodyRotationSequence, oInP[0], SimTK::XAxis,
+                                     oInP[1], SimTK::YAxis, oInP[2], SimTK::YAxis),
                     kneeInFemur),
             SimTK::Body::Rigid(tibiaMass),
-            SimTK::Transform(Rotation(BodyRotationSequence, oInB[0], XAxis,
-                                     oInB[1], YAxis, oInB[2], ZAxis),
+            SimTK::Transform(SimTK::Rotation(SimTK::BodyRotationSequence, oInB[0], SimTK::XAxis,
+                                     oInB[1], SimTK::YAxis, oInB[2], SimTK::YAxis),
                     kneeInTibia));
 
     // Simbody model state setup
     system.realizeTopology();
-    State state = system.getDefaultState();
+    SimTK::State state = system.getDefaultState();
     matter.setUseEulerAngles(state, true);
     system.realizeModel(state);
 
@@ -1558,8 +1530,8 @@ TEST_CASE("testSliderJoint") {
 
     // create hip as an Ball joint
     PinJoint hip("hip", ground, hipInPelvis,
-            Vec3(0), osim_thigh, hipInFemur,
-            Vec3(0));
+            SimTK::Vec3(0), osim_thigh, hipInFemur,
+            SimTK::Vec3(0));
 
     // Rename hip coordinates for a pin joint
     for (int i = 0; i < hip.numCoordinates(); i++) {
@@ -1629,43 +1601,41 @@ TEST_CASE("testSliderJoint") {
 
 /// Compare behavior of a two body model connected via planar joints
 TEST_CASE("testPlanarJoint") {
-    using namespace SimTK;
-
     cout << endl;
     cout << "============================================================="
          << endl;
-    cout << " OpenSim PlanarJoint vs. Simbody MobilizedBody::Planar " << endl;
+    cout << " OpenSim PlanarJoint vs. Simbody SimTK::MobilizedBody::Planar " << endl;
     cout << "============================================================="
          << endl;
 
-    Random::Uniform randomAngle(-Pi / 2, Pi / 2);
-    Vec3 oInB(randomAngle.getValue(), randomAngle.getValue(),
+    SimTK::Random::Uniform randomAngle(-SimTK::Pi / 2, SimTK::Pi / 2);
+    SimTK::Vec3 oInB(randomAngle.getValue(), randomAngle.getValue(),
             randomAngle.getValue());
-    Vec3 oInP(randomAngle.getValue(), randomAngle.getValue(),
+    SimTK::Vec3 oInP(randomAngle.getValue(), randomAngle.getValue(),
             randomAngle.getValue());
 
     // Define the Simbody system
-    MultibodySystem system;
-    SimbodyMatterSubsystem matter(system);
-    GeneralForceSubsystem forces(system);
+    SimTK::MultibodySystem system;
+    SimTK::SimbodyMatterSubsystem matter(system);
+    SimTK::GeneralForceSubsystem forces(system);
     SimTK::Force::UniformGravity gravity(forces, matter, gravity_vec);
 
     // Thigh connected by hip
-    MobilizedBody::Planar thigh(matter.Ground(), SimTK::Transform(hipInPelvis),
+    SimTK::MobilizedBody::Planar thigh(matter.Ground(), SimTK::Transform(hipInPelvis),
             SimTK::Body::Rigid(femurMass), SimTK::Transform(hipInFemur));
     // Pin knee connects shank
-    MobilizedBody::Planar shank(thigh,
-            SimTK::Transform(Rotation(BodyRotationSequence, oInP[0], XAxis,
-                                     oInP[1], YAxis, oInP[2], ZAxis),
+    SimTK::MobilizedBody::Planar shank(thigh,
+            SimTK::Transform(SimTK::Rotation(SimTK::BodyRotationSequence, oInP[0], SimTK::XAxis,
+                                     oInP[1], SimTK::YAxis, oInP[2], SimTK::YAxis),
                     kneeInFemur),
             SimTK::Body::Rigid(tibiaMass),
-            SimTK::Transform(Rotation(BodyRotationSequence, oInB[0], XAxis,
-                                     oInB[1], YAxis, oInB[2], ZAxis),
+            SimTK::Transform(SimTK::Rotation(SimTK::BodyRotationSequence, oInB[0], SimTK::XAxis,
+                                     oInB[1], SimTK::YAxis, oInB[2], SimTK::YAxis),
                     kneeInTibia));
 
     // Simbody model state setup
     system.realizeTopology();
-    State state = system.getDefaultState();
+    SimTK::State state = system.getDefaultState();
     matter.setUseEulerAngles(state, true);
     system.realizeModel(state);
 
@@ -1681,8 +1651,8 @@ TEST_CASE("testPlanarJoint") {
 
     // create hip as an Ball joint
     PlanarJoint hip("hip", ground, hipInPelvis,
-            Vec3(0), osim_thigh, hipInFemur,
-            Vec3(0));
+            SimTK::Vec3(0), osim_thigh, hipInFemur,
+            SimTK::Vec3(0));
 
     // Rename hip coordinates for a pin joint
     for (int i = 0; i < hip.numCoordinates(); i++) {
@@ -1754,8 +1724,6 @@ TEST_CASE("testPlanarJoint") {
 
 /// Compare behavior of a Free hip and pin knee
 TEST_CASE("testCustomWithMultidimFunction") {
-    using namespace SimTK;
-
     cout << endl;
     cout << "=========================================================="
          << endl;
@@ -1765,12 +1733,12 @@ TEST_CASE("testCustomWithMultidimFunction") {
 
     MultidimensionalFunction testFunction;
     // Define the Simbody system
-    MultibodySystem system;
-    SimbodyMatterSubsystem matter(system);
-    GeneralForceSubsystem forces(system);
+    SimTK::MultibodySystem system;
+    SimTK::SimbodyMatterSubsystem matter(system);
+    SimTK::GeneralForceSubsystem forces(system);
     SimTK::Force::UniformGravity gravity(forces, matter, gravity_vec);
 
-    // Define the functions that specify the FunctionBased Mobilized Body.
+    // Define the functions that specify the FunctionBased Mobilized SimTK::Body.
     std::vector<std::vector<int>> coordIndices;
     std::vector<const SimTK::Function*> functions;
     std::vector<bool> isdof(6, false);
@@ -1788,7 +1756,7 @@ TEST_CASE("testCustomWithMultidimFunction") {
             functions.push_back(testFunction.createSimTKFunction());
             coordIndices.push_back(findex);
         } else if (isdof[i]) {
-            Vector coeff(2);
+            SimTK::Vector coeff(2);
             coeff[0] = 1;
             coeff[1] = 0;
             std::vector<int> findex(1, i - 3);
@@ -1802,16 +1770,16 @@ TEST_CASE("testCustomWithMultidimFunction") {
     }
 
     // Thigh connected by hip
-    MobilizedBody::FunctionBased thigh(matter.Ground(),
+    SimTK::MobilizedBody::FunctionBased thigh(matter.Ground(),
             SimTK::Transform(hipInPelvis), SimTK::Body::Rigid(femurMass),
             SimTK::Transform(hipInFemur), nm, functions, coordIndices);
     // Function-based knee connects shank
-    MobilizedBody::Pin shank(thigh, SimTK::Transform(kneeInFemur),
+    SimTK::MobilizedBody::Pin shank(thigh, SimTK::Transform(kneeInFemur),
             SimTK::Body::Rigid(tibiaMass), SimTK::Transform(kneeInTibia));
 
     // Simbody model state setup
     system.realizeTopology();
-    State state = system.getDefaultState();
+    SimTK::State state = system.getDefaultState();
     matter.setUseEulerAngles(state, true);
     system.realizeModel(state);
 
@@ -1841,8 +1809,8 @@ TEST_CASE("testCustomWithMultidimFunction") {
 
     // create custom hip joint
     CustomJoint hip("hip", ground, hipInPelvis,
-            Vec3(0), osim_thigh, hipInFemur,
-            Vec3(0), hipTransform);
+            SimTK::Vec3(0), osim_thigh, hipInFemur,
+            SimTK::Vec3(0), hipTransform);
 
     // Add the thigh body which now also contains the hip joint to the model
     osimModel.addBody(&osim_thigh);
@@ -1861,8 +1829,8 @@ TEST_CASE("testCustomWithMultidimFunction") {
     kneeTransform[2].setFunction(new LinearFunction());
 
     // create custom knee joint
-    CustomJoint knee("knee", osim_thigh, kneeInFemur, Vec3(0), osim_shank,
-            kneeInTibia, Vec3(0), kneeTransform);
+    CustomJoint knee("knee", osim_thigh, kneeInFemur, SimTK::Vec3(0), osim_shank,
+            kneeInTibia, SimTK::Vec3(0), kneeTransform);
 
     // Add the shank body which now also contains the knee joint to the model
     osimModel.addBody(&osim_shank);
@@ -1890,8 +1858,6 @@ TEST_CASE("testCustomWithMultidimFunction") {
 /// Compare custom implementation of Gimbal to a Compound (multi-mobilizer)
 /// Joint version
 TEST_CASE("testCustomVsCompoundJoint") {
-    using namespace SimTK;
-
     cout << endl;
     cout << "=========================================================="
          << endl;
@@ -1919,20 +1885,20 @@ TEST_CASE("testCustomVsCompoundJoint") {
     hipTransform[0].setCoordinateNames(
             OpenSim::Array<std::string>("hip_qZ", 1, 1));
     hipTransform[0].setFunction(new LinearFunction());
-    hipTransform[0].setAxis(Vec3(0, 0, 1));
+    hipTransform[0].setAxis(SimTK::Vec3(0, 0, 1));
     hipTransform[1].setCoordinateNames(
             OpenSim::Array<std::string>("hip_qX", 1, 1));
     hipTransform[1].setFunction(new LinearFunction());
-    hipTransform[1].setAxis(Vec3(1, 0, 0));
+    hipTransform[1].setAxis(SimTK::Vec3(1, 0, 0));
     hipTransform[2].setCoordinateNames(
             OpenSim::Array<std::string>("hip_qY", 1, 1));
     hipTransform[2].setFunction(new LinearFunction());
-    hipTransform[2].setAxis(Vec3(0, 1, 0));
+    hipTransform[2].setAxis(SimTK::Vec3(0, 1, 0));
 
-    Random::Uniform randomAngle(-Pi / 2, Pi / 2);
-    Vec3 oInP(randomAngle.getValue(), randomAngle.getValue(),
+    SimTK::Random::Uniform randomAngle(-SimTK::Pi / 2, SimTK::Pi / 2);
+    SimTK::Vec3 oInP(randomAngle.getValue(), randomAngle.getValue(),
             randomAngle.getValue());
-    Vec3 oInB(randomAngle.getValue(), randomAngle.getValue(),
+    SimTK::Vec3 oInB(randomAngle.getValue(), randomAngle.getValue(),
             randomAngle.getValue());
 
     // create custom hip joint
@@ -1958,8 +1924,8 @@ TEST_CASE("testCustomVsCompoundJoint") {
     kneeTransform[2].setFunction(new LinearFunction());
 
     // create custom knee joint
-    CustomJoint knee("knee", osim_thigh, kneeInFemur, Vec3(0), osim_shank,
-            kneeInTibia, Vec3(0), kneeTransform);
+    CustomJoint knee("knee", osim_thigh, kneeInFemur, SimTK::Vec3(0), osim_shank,
+            kneeInTibia, SimTK::Vec3(0), kneeTransform);
 
     // Add the shank body which now also contains the knee joint to the model
     customModel.addBody(&osim_shank);
@@ -2001,8 +1967,8 @@ TEST_CASE("testCustomVsCompoundJoint") {
     shank2.attachGeometry(new Mesh("tibia.vtp"));
 
     // create custom knee joint
-    CustomJoint knee2("knee2", thigh2, kneeInFemur, Vec3(0), shank2,
-            kneeInTibia, Vec3(0), kneeTransform);
+    CustomJoint knee2("knee2", thigh2, kneeInFemur, SimTK::Vec3(0), shank2,
+            kneeInTibia, SimTK::Vec3(0), kneeTransform);
 
     // Add the shank body which now also contains the knee joint to the model
     compoundModel.addBody(&shank2);
@@ -2022,7 +1988,7 @@ TEST_CASE("testCustomVsCompoundJoint") {
     state1.updQ()[0] = 0.1;
     state1.updQ()[1] = 0.2;
     state1.updQ()[2] = 0.3;
-    state1.updQ()[3] = -Pi / 2;
+    state1.updQ()[3] = -SimTK::Pi / 2;
 
     state2.updQ() = state1.getQ();
 
@@ -2043,8 +2009,6 @@ TEST_CASE("testCustomVsCompoundJoint") {
 } // end of testCustomVsCompoundJoint
 
 TEST_CASE("testEquivalentBodyForceFromGeneralizedForce") {
-    using namespace SimTK;
-
     cout << endl;
     cout << "=================================================================="
             "==="
@@ -2077,14 +2041,14 @@ TEST_CASE("testAddedFreeJointForBodyWithoutJoint") {
     cout << endl;
     cout << "=========================================================="
          << endl;
-    cout << " A Body without a Joint should get a Free (6dof) Joint    "
+    cout << " A SimTK::Body without a Joint should get a Free (6dof) Joint    "
          << endl;
     cout << "=========================================================="
          << endl;
 
     Model model;
     SimTK::Inertia inertia(SimTK::Inertia::brick(SimTK::Vec3(0.5, 0.15, 0.2)));
-    Body* block = new Body("block", 1.0, SimTK::Vec3(0.0), inertia);
+    OpenSim::Body* block = new OpenSim::Body("block", 1.0, SimTK::Vec3(0.0), inertia);
     model.addBody(block);
 
     model.initSystem();
@@ -2115,16 +2079,16 @@ TEST_CASE("testAutomaticJointReversal") {
     Ground& ground = model.updGround();
     ground.upd_frame_geometry().setColor(SimTK::Vec3(1, 1, 0));
 
-    auto pelvis = new Body("pelvis", 10.0, SimTK::Vec3(0),
+    auto pelvis = new OpenSim::Body("pelvis", 10.0, SimTK::Vec3(0),
             SimTK::Inertia::brick(SimTK::Vec3(0.1, 0.15, 0.25)));
 
-    auto thigh = new Body("thigh", femurMass.getMass(),
+    auto thigh = new OpenSim::Body("thigh", femurMass.getMass(),
             femurMass.getMassCenter(), femurMass.getInertia());
 
-    auto shank = new Body("shank", tibiaMass.getMass(),
+    auto shank = new OpenSim::Body("shank", tibiaMass.getMass(),
             tibiaMass.getMassCenter(), tibiaMass.getInertia());
 
-    auto foot = new Body("foot", footMass.getMass(), footMass.getMassCenter(),
+    auto foot = new OpenSim::Body("foot", footMass.getMass(), footMass.getMassCenter(),
             footMass.getInertia());
 
     pelvis->upd_frame_geometry().setColor(SimTK::Vec3(0, 1, 0)); // GREEN
@@ -2188,7 +2152,7 @@ TEST_CASE("testAutomaticJointReversal") {
     SimTK::State& s = model.initSystem();
 
     SimTK::Transform pelvisX = pelvis->getTransformInGround(s);
-    cout << "Pelvis Transform (reverse): " << pelvisX << endl;
+    cout << "Pelvis SimTK::Transform (reverse): " << pelvisX << endl;
 
     model.print("reversedLegWeldJointToGround.osim");
 
@@ -2201,9 +2165,9 @@ TEST_CASE("testAutomaticJointReversal") {
     modelConstrained.finalizeFromProperties();
 
     const Ground& cground = modelConstrained.getGround();
-    const Body& cpelvis =
-            modelConstrained.getComponent<Body>("./bodyset/pelvis");
-    const Body& cfoot = modelConstrained.getComponent<Body>("./bodyset/foot");
+    const OpenSim::Body& cpelvis =
+            modelConstrained.getComponent<OpenSim::Body>("./bodyset/pelvis");
+    const OpenSim::Body& cfoot = modelConstrained.getComponent<OpenSim::Body>("./bodyset/foot");
 
     // free the pelvis
     auto pelvisFree = new FreeJoint(
@@ -2246,7 +2210,7 @@ TEST_CASE("testAutomaticJointReversal") {
     SimTK::State& sc = modelConstrained.initSystem();
 
     SimTK::Transform pelvisXc = cpelvis.getTransformInGround(sc);
-    cout << "Shank Transform (constrained): " << pelvisXc << endl;
+    cout << "Shank SimTK::Transform (constrained): " << pelvisXc << endl;
 
     modelConstrained.print("forwardLegWeldConstraintToGround.osim");
 
@@ -2365,7 +2329,7 @@ TEST_CASE("testAutomaticLoopJointBreaker") {
     model.addJoint(&hip);
 
     // Add OpenSim shank via a knee joint
-    Body shank("shank", tibiaMass.getMass(), tibiaMass.getMassCenter(),
+    OpenSim::Body shank("shank", tibiaMass.getMass(), tibiaMass.getMassCenter(),
             tibiaMass.getInertia());
 
     // Add the shank body to the model
@@ -2382,7 +2346,7 @@ TEST_CASE("testAutomaticLoopJointBreaker") {
     model.addJoint(&knee);
 
     // Add foot body at ankle
-    Body foot("foot", footMass.getMass(), footMass.getMassCenter(),
+    OpenSim::Body foot("foot", footMass.getMass(), footMass.getMassCenter(),
             footMass.getInertia());
 
     // Add foot
@@ -2687,8 +2651,6 @@ TEST_CASE("testMotionTypesForCustomJointCoordinates") {
 /// for a transform axis of a CustomJoint acts as a simple offset of
 /// the Coordinate value with otherwise identical dynamics
 TEST_CASE("testNonzeroInterceptCustomJointVsPin") {
-    using namespace SimTK;
-
     cout << endl;
     cout << "==========================================================="
          << endl;
@@ -2712,8 +2674,8 @@ TEST_CASE("testNonzeroInterceptCustomJointVsPin") {
     pinModel.addBody(thigh1);
 
     // create hip as a pin joint
-    auto hip1 = new PinJoint("hip", pinModel.getGround(), hipInPelvis, Vec3(0),
-            *thigh1, hipInFemur, Vec3(0));
+    auto hip1 = new PinJoint("hip", pinModel.getGround(), hipInPelvis, SimTK::Vec3(0),
+            *thigh1, hipInFemur, SimTK::Vec3(0));
     hip1->updCoordinate().setName("pin_q");
 
     // Add pin hip joint to the model
@@ -2739,7 +2701,7 @@ TEST_CASE("testNonzeroInterceptCustomJointVsPin") {
     hipTransform[2].setFunction(new LinearFunction(1.0, offset));
 
     auto hip2 = new CustomJoint("hip", cjModel.getGround(), hipInPelvis,
-            Vec3(0), *thigh2, hipInFemur, Vec3(0), hipTransform);
+            SimTK::Vec3(0), *thigh2, hipInFemur, SimTK::Vec3(0), hipTransform);
 
     // add CustomJoint "pin" to the model
     cjModel.addJoint(hip2);
@@ -2747,8 +2709,8 @@ TEST_CASE("testNonzeroInterceptCustomJointVsPin") {
     // pinModel.setUseVisualizer(true);
     // cjModel.setUseVisualizer(true);
 
-    State s1 = pinModel.initSystem();
-    State s2 = cjModel.initSystem();
+    SimTK::State s1 = pinModel.initSystem();
+    SimTK::State s2 = cjModel.initSystem();
 
     // Verify the MotionType for both Joints are the same (Rotational)
     auto mt1 = hip1->getCoordinate().getMotionType();
@@ -2759,10 +2721,10 @@ TEST_CASE("testNonzeroInterceptCustomJointVsPin") {
             "CustomJoint's Coordinate MotionType failed to match PinJoint's");
 
     // Set initial conditions of both pendulum models
-    hip1->getCoordinate().setValue(s1, Pi / 3);
+    hip1->getCoordinate().setValue(s1, SimTK::Pi / 3);
     // Subtract the expected offset of the cjModel since we expect the
     // CustomJoint's transformAxis' function to effectively offset the value
-    hip2->getCoordinate().setValue(s2, Pi / 3 - offset);
+    hip2->getCoordinate().setValue(s2, SimTK::Pi / 3 - offset);
 
     // integrate both Models over a standard duration
     integrateOpenSimModel(&pinModel, s1);
@@ -2820,4 +2782,4 @@ TEST_CASE("testJointWithInvalidCoordinatesThrowsOnFinalization")
     }
 
     OPENSIM_THROW_IF(!exceptionThrown, Exception, "no exception was thrown (it should throw on finalization)");
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/SimbodyEngine/UniversalJoint.cpp b/OpenSim/Simulation/SimbodyEngine/UniversalJoint.cpp
index 6caa8cb59..4b5abc121 100644
--- a/OpenSim/Simulation/SimbodyEngine/UniversalJoint.cpp
+++ b/OpenSim/Simulation/SimbodyEngine/UniversalJoint.cpp
@@ -31,7 +31,6 @@
 // STATICS
 //=============================================================================
 using namespace std;
-using namespace SimTK;
 using namespace OpenSim;
 
 //=============================================================================
@@ -41,5 +40,5 @@ using namespace OpenSim;
 void UniversalJoint::extendAddToSystem(SimTK::MultibodySystem& system) const
 {
     Super::extendAddToSystem(system);
-    createMobilizedBody<MobilizedBody::Universal>(system);
-}
+    createMobilizedBody<SimTK::MobilizedBody::Universal>(system);
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/SimbodyEngine/WeldConstraint.cpp b/OpenSim/Simulation/SimbodyEngine/WeldConstraint.cpp
index cd33475c8..e97471b29 100644
--- a/OpenSim/Simulation/SimbodyEngine/WeldConstraint.cpp
+++ b/OpenSim/Simulation/SimbodyEngine/WeldConstraint.cpp
@@ -32,7 +32,6 @@
 // STATICS
 //=============================================================================
 using namespace std;
-using namespace SimTK;
 using namespace OpenSim;
 
 //=============================================================================
@@ -69,14 +68,14 @@ WeldConstraint::WeldConstraint(const std::string &name,
     const PhysicalFrame& frame2,
     const SimTK::Vec3& locationInFrame2, const SimTK::Vec3& orientationInFrame2) :
     WeldConstraint(name, 
-        frame1, Transform(Rotation(BodyRotationSequence,
-            orientationInFrame1[0], XAxis,
-            orientationInFrame1[1], YAxis,
-            orientationInFrame1[2], ZAxis), locationInFrame1),
-        frame2, Transform(Rotation(BodyRotationSequence,
-            orientationInFrame2[0], XAxis,
-            orientationInFrame2[1], YAxis,
-            orientationInFrame2[2], ZAxis), locationInFrame2) )
+        frame1, SimTK::Transform(SimTK::Rotation(SimTK::BodyRotationSequence,
+            orientationInFrame1[0], SimTK::XAxis,
+            orientationInFrame1[1], SimTK::YAxis,
+            orientationInFrame1[2], SimTK::ZAxis), locationInFrame1),
+        frame2, SimTK::Transform(SimTK::Rotation(SimTK::BodyRotationSequence,
+            orientationInFrame2[0], SimTK::XAxis,
+            orientationInFrame2[1], SimTK::YAxis,
+            orientationInFrame2[2], SimTK::ZAxis), locationInFrame2) )
 {}
 
 WeldConstraint::WeldConstraint(const std::string &name,
@@ -134,7 +133,7 @@ void WeldConstraint::
 }
 
 void WeldConstraint::
-    setContactPointForInducedAccelerations(const SimTK::State &s, Vec3 point)
+    setContactPointForInducedAccelerations(const SimTK::State &s, SimTK::Vec3 point)
 {
     // make sure we are at the position stage
     getSystem().realize(s, SimTK::Stage::Position);
@@ -146,7 +145,7 @@ void WeldConstraint::
     // wrt foot (i.e., frame2) because we are passing it in from a
     // prescribed force.
     // We must also get that point position vector wrt ground (i.e., frame1)
-    Vec3 spoint = frame2.findStationLocationInAnotherFrame(s, point, frame1);
+    SimTK::Vec3 spoint = frame2.findStationLocationInAnotherFrame(s, point, frame1);
 
     SimTK::Transform in1(frame1.getTransformInGround(s).R(), spoint);
     SimTK::Transform in2(frame2.getTransformInGround(s).R(), point);
@@ -173,4 +172,4 @@ void WeldConstraint::
     else {
         _internalOffset2->setOffsetTransform(in2);
     }
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/SimbodyEngine/WeldJoint.cpp b/OpenSim/Simulation/SimbodyEngine/WeldJoint.cpp
index 18f181d9d..10fe8ce10 100644
--- a/OpenSim/Simulation/SimbodyEngine/WeldJoint.cpp
+++ b/OpenSim/Simulation/SimbodyEngine/WeldJoint.cpp
@@ -30,7 +30,6 @@
 //=============================================================================
 // STATICS
 //=============================================================================
-using namespace SimTK;
 using namespace OpenSim;
 
 //=============================================================================
@@ -63,4 +62,4 @@ template <> SimTK::MobilizedBody::Weld Joint::createMobilizedBody<SimTK::Mobiliz
 
     return simtkBody;
 }
-} // namespace OpenSim
+} // namespace OpenSim
\ No newline at end of file
diff --git a/OpenSim/Simulation/StatesDocument.cpp b/OpenSim/Simulation/StatesDocument.cpp
index 432b856c6..0d5e545b6 100644
--- a/OpenSim/Simulation/StatesDocument.cpp
+++ b/OpenSim/Simulation/StatesDocument.cpp
@@ -48,7 +48,7 @@ struct SDocUtil {
         varElt.setAttributeValue("type", type);
 
         // Append the variable element
-        varElt.setValueAs<SimTK::Array_<T>>(valArr, precision);
+        varElt.setValueAs<SimTK::Array_<T>>(valArr); //TODO: newer simbody?
         parent.appendNode(varElt);
     }
     //_________________________________________________________________________
@@ -223,7 +223,7 @@ void StatesDocument::formTimeElement(
     }
 
     // Set the text value on the element
-    timeElt.setValueAs<SimTK::Array_<double>>(time, precision);
+    timeElt.setValueAs<SimTK::Array_<double>>(time); //TODO:newer simbody?
 }
 //_____________________________________________________________________________
 // Supported continuous variable type (October 2024): double
diff --git a/OpenSim/Simulation/Test/SimulationComponentsForTesting.h b/OpenSim/Simulation/Test/SimulationComponentsForTesting.h
index 2cffdff1a..86c953ec6 100644
--- a/OpenSim/Simulation/Test/SimulationComponentsForTesting.h
+++ b/OpenSim/Simulation/Test/SimulationComponentsForTesting.h
@@ -65,8 +65,6 @@ public:
 protected:
     void extendAddToSystem(SimTK::MultibodySystem& system) const override
     {
-        using namespace SimTK;
-
         Super::extendAddToSystem(system);
 
         // PARENT TRANSFORM
@@ -78,12 +76,12 @@ protected:
 
         int coordinateIndexForMobility = 0;
 
-        SimTK::Transform childTransform0(Rotation(), Vec3(0));
+        SimTK::Transform childTransform0(SimTK::Rotation(), SimTK::Vec3(0));
 
         SimTK::Body::Massless massless;
 
         // CREATE MOBILIZED BODY for body rotation about body Z
-        MobilizedBody masslessBody1 = createMobilizedBody<MobilizedBody::Pin>(
+        SimTK::MobilizedBody masslessBody1 = createMobilizedBody<SimTK::MobilizedBody::Pin>(
             system.updMatterSubsystem().updMobilizedBody(
                 getParentFrame().getMobilizedBodyIndex()),
             P_Po,
@@ -92,12 +90,12 @@ protected:
             coordinateIndexForMobility);
 
         // Find the joint frame with Z aligned to body X
-        Rotation rotToX(Pi/2, YAxis);
-        SimTK::Transform parentTransform1(rotToX, Vec3(0));
-        SimTK::Transform childTransform1(rotToX, Vec3(0));
+        SimTK::Rotation rotToX(SimTK::Pi/2, SimTK::YAxis);
+        SimTK::Transform parentTransform1(rotToX, SimTK::Vec3(0));
+        SimTK::Transform childTransform1(rotToX, SimTK::Vec3(0));
 
         // CREATE MOBILIZED BODY for body rotation about body X
-        MobilizedBody masslessBody2 = createMobilizedBody<MobilizedBody::Pin>(
+        SimTK::MobilizedBody masslessBody2 = createMobilizedBody<SimTK::MobilizedBody::Pin>(
             masslessBody1,
             parentTransform1,
             massless,
@@ -105,12 +103,12 @@ protected:
             coordinateIndexForMobility);
 
         // Now Find the joint frame with Z aligned to body Y
-        Rotation rotToY(-Pi/2, XAxis);
-        SimTK::Transform parentTransform2(rotToY, Vec3(0));
+        SimTK::Rotation rotToY(-SimTK::Pi/2, SimTK::XAxis);
+        SimTK::Transform parentTransform2(rotToY, SimTK::Vec3(0));
         SimTK::Transform childTransform2(B_Bo.R()*rotToY, B_Bo.p());
 
         // CREATE MOBILIZED BODY for body rotation about body Y
-        MobilizedBody mobBod = createMobilizedBody<MobilizedBody::Pin>(
+        SimTK::MobilizedBody mobBod = createMobilizedBody<SimTK::MobilizedBody::Pin>(
             masslessBody2,
             parentTransform2,
             getChildInternalRigidBody(),
@@ -120,4 +118,4 @@ protected:
 
 }; // end of CompoundJoint
 
-#endif // OPENSIM_SIMULATION_COMPONENTS_FOR_TESTING_H_
+#endif // OPENSIM_SIMULATION_COMPONENTS_FOR_TESTING_H_
\ No newline at end of file
diff --git a/OpenSim/Simulation/Test/testAssemblySolver.cpp b/OpenSim/Simulation/Test/testAssemblySolver.cpp
index 6f4fd5638..7b0a4cf04 100644
--- a/OpenSim/Simulation/Test/testAssemblySolver.cpp
+++ b/OpenSim/Simulation/Test/testAssemblySolver.cpp
@@ -67,8 +67,6 @@ namespace {
     void testAssembleModelWithConstraints(string modelFile)
     {
         double accuracy = 1e-5;
-        using namespace SimTK;
-
         cout << "\n****************************************************************************" << endl;
         cout << " testAssembleModelWithConstraints with "<< modelFile << endl;
         cout << "****************************************************************************\n" << endl;
@@ -91,7 +89,7 @@ namespace {
         //model.setUseVisualizer(true);
         model.set_assembly_accuracy(accuracy);
 
-        State state = model.initSystem();
+        SimTK::State state = model.initSystem();
         model.equilibrateMuscles(state);
 
         cout << "*********** Coordinates after initSystem ******************** "  << endl;
@@ -103,12 +101,12 @@ namespace {
 
         assert(coords.getSize()==coordsInOrder.size());
         // Initial coordinates after initial assembly
-        Vector q0 = state.getQ();
+        SimTK::Vector q0 = state.getQ();
 
         // do assembly again-
         model.assemble(state);
 
-        Vector q0_1 = state.getQ();
+        SimTK::Vector q0_1 = state.getQ();
 
 
         // verify the coordinates do not change within the desired accuracy
@@ -131,13 +129,13 @@ namespace {
                     j.getChildFrame().findTransformInBaseFrame(),
                     SimTK::DecorativeFrame(0.033));
                 viz.addDecoration(j.getChildFrame().getMobilizedBodyIndex(),
-                    Transform(),
+                    SimTK::Transform(),
                     SimTK::DecorativeSphere(0.033));
                 if (j.getChildFrame().getName() == "pelvis"){
-                    SimTK::DecorativeBrick geom(Vec3(0.10, 0.05, 0.20));
-                    geom.setColor(Vec3(0.1, 1.0, 0.1));
+                    SimTK::DecorativeBrick geom(SimTK::Vec3(0.10, 0.05, 0.20));
+                    geom.setColor(SimTK::Vec3(0.1, 1.0, 0.1));
                     viz.addDecoration(j.getChildFrame().getMobilizedBodyIndex(),
-                        Transform(), geom);
+                        SimTK::Transform(), geom);
                 }
             }
 
@@ -146,27 +144,27 @@ namespace {
 
         // Verify that the reaction forces at the constraints are not ridiculously large
         // They should sum to body-weight (more or less)
-        model.getMultibodySystem().realize(state, Stage::Acceleration);
+        model.getMultibodySystem().realize(state, SimTK::Stage::Acceleration);
 
-        /*Vec3 comVel = */model.calcMassCenterVelocity(state);
-        Vec3 comAcc = model.calcMassCenterAcceleration(state);
-        /*SpatialVec momentum = */model.getMatterSubsystem().calcSystemCentralMomentum(state);
+        /*SimTK::Vec3 comVel = */model.calcMassCenterVelocity(state);
+        SimTK::Vec3 comAcc = model.calcMassCenterAcceleration(state);
+        /*SimTK::SpatialVec momentum = */model.getMatterSubsystem().calcSystemCentralMomentum(state);
 
         const ConstraintSet &constraints = model.getConstraintSet();
 
-        Vector_<SpatialVec> constraintBodyForces(constraints.getSize());
-        Vector mobilityForces(0);
+        SimTK::Vector_<SimTK::SpatialVec> constraintBodyForces(constraints.getSize());
+        SimTK::Vector mobilityForces(0);
         double totalYforce = 0;
 
         for(int i=0; i< constraints.getSize(); i++) {
             constraints[i].calcConstraintForces(state, constraintBodyForces, mobilityForces);
             cout << "Constraint " << i << ":  " << constraints[i].getName();
-            cout << " Force = " << constraintBodyForces(1)(1)(1) << endl;
-            //constraintBodyForces.dump("Constraint Body Forces");
+            cout << " SimTK::Force = " << constraintBodyForces(1)(1)(1) << endl;
+            //constraintBodyForces.dump("Constraint SimTK::Body Forces");
             totalYforce += constraintBodyForces(1)(1)(1);
         }
 
-        cout << "Total Vertical Constraint Force:" << totalYforce << " N " << endl;
+        cout << "Total Vertical Constraint SimTK::Force:" << totalYforce << " N " << endl;
 
         double mass = model.getTotalMass(state);
         double bw = -mass*(model.getGravity()[1]);
@@ -204,18 +202,18 @@ namespace {
         state = manager.integrate(0.05);
         model.getMultibodySystem().realize(state, SimTK::Stage::Velocity);
 
-        Vector positionErr = state.getQErr();
+        SimTK::Vector positionErr = state.getQErr();
         // int nPerr = positionErr.size();
         // double pErrMag = positionErr.norm();
 
         // get the configuration at the end of the simulation
-        Vector q1 = state.getQ();
+        SimTK::Vector q1 = state.getQ();
 
         model.updateAssemblyConditions(state);
         // Assemble after the simulation to see how much the assembly changes things
         model.assemble(state);
-        Vector q1_1 = state.getQ();
-        Vector q1ErrVec = (q1_1 - q1);
+        SimTK::Vector q1_1 = state.getQ();
+        SimTK::Vector q1ErrVec = (q1_1 - q1);
         //q1ErrVec.dump("Post simulation: q1_assembled - q1_sim");
         double q1Err = q1ErrVec.norm();
 
@@ -223,48 +221,47 @@ namespace {
         ASSERT_EQUAL(0.0, q1Err/q1.norm(), accuracy);
 
         // recreate system with states from initial defaults
-        State state0 = model.initSystem();
+        SimTK::State state0 = model.initSystem();
 
         // get the configuration after getting a new state from initial defaults
         // to verify that running a simulation doesn't wreck defaults
-        Vector q0_2 = state0.getQ();
+        SimTK::Vector q0_2 = state0.getQ();
 
         // set default (properties) which capture an accurate snapshot of the model
         // post simulation.
         model.setPropertiesFromState(state);
 
         // recreate system with states from post simulation defaults
-        const State& state1 = model.initSystem();
+        const SimTK::State& state1 = model.initSystem();
         // get the configuration from post simulation defaults (properties)
-        Vector q1_2 = state1.getQ();
+        SimTK::Vector q1_2 = state1.getQ();
 
         // double q0Err = (q0_2 - q0_1).norm();
         // double q1Err_1 = (q1_2 - q1_1).norm();
 
-        //cout << "******************* Init System Initial State *******************" << endl;
+        //cout << "******************* Init SimTK::System Initial SimTK::State *******************" << endl;
         for (int i = 0; i < q0_1.size(); i++) {
             cout << "Pre-simulation:" << i << " q0_1 = " << q0_1[i] << ", q0_2 = " << q0_2[i] << endl;
             ASSERT_EQUAL(q0_1[i], q0_2[i], 10*accuracy, __FILE__, __LINE__, "Initial state changed after 2nd call to initSystem");
         }
 
-        cout << "******************* Init System Final State *******************" << endl;
+        cout << "******************* Init SimTK::System Final SimTK::State *******************" << endl;
         for (int i = 0; i < q1_1.size(); i++) {
             cout << "Post-simulation:" << i << " q1_1 = " << q1_1[i] << ", q1_2 = " << q1_2[i] << endl;
-            ASSERT_EQUAL(q1_1[i], q1_2[i], 10 * accuracy, __FILE__, __LINE__, "State differed after a simulation from same init state.");
+            ASSERT_EQUAL(q1_1[i], q1_2[i], 10 * accuracy, __FILE__, __LINE__, "SimTK::State differed after a simulation from same init state.");
         }
         ASSERT(max(abs(q1_1 - q0_1)) > 1e-2, __FILE__, __LINE__, "Check that state changed after simulation FAILED");
     }
 
     double calcLigamentLengthError(const SimTK::State &s, const Model &model)
     {
-        using namespace SimTK;
         double error = 0;
 
         ConstantDistanceConstraint* constraint =
             dynamic_cast<ConstantDistanceConstraint*>(&model.getConstraintSet()[0]);
 
         if(constraint){
-            Vec3 p1inB1, p2inB2, p1inG, p2inG;
+            SimTK::Vec3 p1inB1, p2inB2, p1inG, p2inG;
             p1inB1 = constraint->get_location_body_1();
             p2inB2 = constraint->get_location_body_2();
 
@@ -283,8 +280,6 @@ namespace {
 
     void testAssemblySatisfiesConstraints(string modelFile)
     {
-        using namespace SimTK;
-
         cout << "****************************************************************************" << endl;
         cout << " testAssemblySatisfiesConstraints :: " << modelFile << endl;
         cout << "****************************************************************************\n" << endl;
@@ -309,7 +304,7 @@ namespace {
         }
 
         //model.setUseVisualizer(true);
-        State& state = model.initSystem();
+        SimTK::State& state = model.initSystem();
 
         const CoordinateSet &coords = model.getCoordinateSet();
         cout << "***** Coordinate values (after initSystem including Assembly ********* " << endl;
@@ -319,10 +314,10 @@ namespace {
         }
 
         double cerr = SimTK::Infinity;
-        double kneeAngle = -Pi/3;
+        double kneeAngle = -SimTK::Pi/3;
 
         int N = 100;
-        double lower = -2*Pi/3, upper = Pi/18;
+        double lower = -2*SimTK::Pi/3, upper = SimTK::Pi/18;
         double delta = (upper-lower)/N;
 
         // double qerr = 0;
@@ -342,7 +337,7 @@ namespace {
 }
 
 
-// Measure how long it takes to perform model.setStateVariableValues() on a
+// SimTK::Measure how long it takes to perform model.setStateVariableValues() on a
 // model with constraints to evaluate the effect of assembly in the process.
 //~3.5s for CoordinateStateVariable::setValue() enforcing constraints
 //~0.18s for CoordinateStateVariable::setValue() NOT enforcing constraints
@@ -438,4 +433,4 @@ TEST_CASE("CoordinateCouplerCompoundFunction") {
                 "CoordinateCouplerConstraint failed to constrain the dependent "
                 "coordinate based on a MultivariatePolynomialFunction.");
     }
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/Test/testContactGeometry.cpp b/OpenSim/Simulation/Test/testContactGeometry.cpp
index 80b4284c6..df07eb0d4 100644
--- a/OpenSim/Simulation/Test/testContactGeometry.cpp
+++ b/OpenSim/Simulation/Test/testContactGeometry.cpp
@@ -62,7 +62,7 @@ namespace {
         model->setGravity(gravity_vec);
 
         // Add a Body representing the ball.
-        Body ball;
+        OpenSim::Body ball;
         ball.setName("ball");
         ball.set_mass(mass);
         ball.set_mass_center(SimTK::Vec3(0));
@@ -188,7 +188,7 @@ namespace {
         model->setGravity(gravity_vec);
 
         // Add a Body for the ball.
-        Body ball;
+        OpenSim::Body ball;
         ball.setName("ball");
         ball.setMass(mass);
         ball.setMassCenter(SimTK::Vec3(0));
@@ -378,7 +378,7 @@ namespace {
         // For debugging: model.setUseVisualizer(true);
 
         // Body and Joint.
-        auto* point = new Body("point", mass, SimTK::Vec3(0),
+        auto* point = new OpenSim::Body("point", mass, SimTK::Vec3(0),
                 SimTK::Inertia(1.0));
         auto* hinge = new PinJoint("hinge",
                 model.getGround(), SimTK::Vec3(0), SimTK::Vec3(0),
@@ -421,17 +421,17 @@ namespace {
 
             // Scaffolding for the ball.
             const auto& point = model.getBodySet().get("point");
-            auto* linkOffset = new Body("link_offset", 0, SimTK::Vec3(0),
+            auto* linkOffset = new OpenSim::Body("link_offset", 0, SimTK::Vec3(0),
                     SimTK::Inertia(0.0));
             auto* linkWeld = new WeldJoint("link_weld",
                     point, SimTK::Vec3(0), SimTK::Vec3(0),
-                    // Body is 0.5m to the right and 1m up.
+                    // OpenSim::Body is 0.5m to the right and 1m up.
                     *linkOffset, SimTK::Vec3(-0.5, -1, 0), SimTK::Vec3(0));
             model.addBody(linkOffset);
             model.addJoint(linkWeld);
 
             // Scaffolding for the platform.
-            auto* platformOffset = new Body("platform_offset", 0,
+            auto* platformOffset = new OpenSim::Body("platform_offset", 0,
                     SimTK::Vec3(0), SimTK::Inertia(0));
             auto* platformWeld = new WeldJoint("platform_weld",
                     model.getGround(), SimTK::Vec3(0), SimTK::Vec3(0),
@@ -573,7 +573,7 @@ TEST_CASE("ContactEllipsoid") {
 
     // Create a model with a single body and a FreeJoint.
     Model model;
-    Body* body = new Body("body", mass, SimTK::Vec3(0), SimTK::Inertia(1.0));
+    OpenSim::Body* body = new OpenSim::Body("body", mass, SimTK::Vec3(0), SimTK::Inertia(1.0));
     FreeJoint* free = new FreeJoint("free",
             model.getGround(), SimTK::Vec3(0), SimTK::Vec3(0),
             *body, SimTK::Vec3(0), SimTK::Vec3(0));
diff --git a/OpenSim/Simulation/Test/testExponentialContact.cpp b/OpenSim/Simulation/Test/testExponentialContact.cpp
deleted file mode 100644
index f0081358f..000000000
--- a/OpenSim/Simulation/Test/testExponentialContact.cpp
+++ /dev/null
@@ -1,995 +0,0 @@
-/* -------------------------------------------------------------------------- *
- *                OpenSim:  testExponentialContact.cpp                        *
- * -------------------------------------------------------------------------- *
- * The OpenSim API is a toolkit for musculoskeletal modeling and simulation.  *
- * See http://opensim.stanford.edu and the NOTICE file for more information.  *
- * OpenSim is developed at Stanford University and supported by the US        *
- * National Institutes of Health (U54 GM072970, R24 HD065690) and by DARPA    *
- * through the Warrior Web program.                                           *
- *                                                                            *
- * Copyright (c) 2025 Stanford University and the Authors                     *
- * Author(s): F. C. Anderson                                                  *
- * Contributor(s): Nicholas Bianco                                            *
- *                                                                            *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may    *
- * not use this file except in compliance with the License. You may obtain a  *
- * copy of the License at http://www.apache.org/licenses/LICENSE-2.0.         *
- *                                                                            *
- * Unless required by applicable law or agreed to in writing, software        *
- * distributed under the License is distributed on an "AS IS" BASIS,          *
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *
- * See the License for the specific language governing permissions and        *
- * limitations under the License.                                             *
- * -------------------------------------------------------------------------- */
-#include <iostream>
-#include <OpenSim/Common/IO.h>
-#include <OpenSim/Common/Exception.h>
-#include <OpenSim/Common/Array.h>
-
-#include <OpenSim/Auxiliary/auxiliaryTestFunctions.h>
-
-#include <OpenSim/Simulation/Model/BodySet.h>
-#include <OpenSim/Simulation/Manager/Manager.h>
-#include <OpenSim/Analyses/Kinematics.h>
-#include <OpenSim/Analyses/ForceReporter.h>
-
-#include <OpenSim/Simulation/Model/ContactGeometrySet.h>
-#include <OpenSim/Simulation/Model/ContactHalfSpace.h>
-#include <OpenSim/Simulation/Model/ContactMesh.h>
-#include <OpenSim/Simulation/Model/ElasticFoundationForce.h>
-#include <OpenSim/Simulation/Model/HuntCrossleyForce.h>
-#include <OpenSim/Simulation/Model/ExponentialContactForce.h>
-#include <OpenSim/Simulation/Model/ExternalForce.h>
-#include <OpenSim/Simulation/Model/Model.h>
-#include <OpenSim/Simulation/Model/PhysicalOffsetFrame.h>
-#include <OpenSim/Simulation/SimbodyEngine/FreeJoint.h>
-#include <OpenSim/Simulation/StatesTrajectory.h>
-#include <OpenSim/Simulation/StatesTrajectoryReporter.h>
-#include <OpenSim/Simulation/StatesDocument.h>
-#include <OpenSim/Auxiliary/auxiliaryTestFunctions.h>
-
-#include <OpenSim/Actuators/osimActuators.h>
-
-#include "SimTKsimbody.h"
-#include <catch2/catch_all.hpp>
-
-using namespace SimTK;
-using namespace OpenSim;
-using std::cout;
-using std::endl;
-using std::string;
-using std::vector;
-
-//=============================================================================
-// Class ExponentialContactTester provides a scope and framework for
-// evaluating and testing the ExponentialContactForce class. Using this testing
-// class gets a lot of variables out of the global scope and allows for more
-// structured memory management.
-class ExponentialContactTester
-{
-public:
-    // Initial condition choices
-    enum InitialConditionsChoice{
-        Static = 0,
-        Bounce,
-        Slide,
-        Spin,
-        SpinSlide,
-        SpinTop,
-        Tumble
-    };
-
-    // Constructor
-    ExponentialContactTester() {
-        // Default body stations on the block
-        corner[0] = Vec3( hs, -hs,  hs);
-        corner[1] = Vec3( hs, -hs, -hs);
-        corner[2] = Vec3(-hs, -hs, -hs);
-        corner[3] = Vec3(-hs, -hs,  hs);
-        corner[4] = Vec3( hs,  hs,  hs);
-        corner[5] = Vec3( hs,  hs, -hs);
-        corner[6] = Vec3(-hs,  hs, -hs);
-        corner[7] = Vec3(-hs,  hs,  hs);
-    };
-
-    // Destructor
-    ~ExponentialContactTester() {
-        if (model != nullptr) {
-            //model->disownAllComponents();  // See note just below.
-            delete model;
-        }
-        // If the model still owns its components, the following deletes should
-        // not be called. On the other hand, if all components are disowned,
-        // they must be individually deleted.
-        //if (blockEC) delete blockEC;
-        //for (int i = 0; i < n; i++) {
-        //if (sprEC[i]) delete sprEC[i];
-        //}
-    }
-
-    // Utility
-    void buildModel();
-    OpenSim::Body* addBlock(const std::string& suffix);
-    void addExponentialContact(OpenSim::Body* body);
-    void setInitialConditions(SimTK::State& state,
-        const SimTK::MobilizedBody& body, double dz);
-    void printDiscreteVariableAbstractValue(const string& pathName,
-        const AbstractValue& value) const;
-
-    //-------------------------------------------------------------------------
-    // Member variables
-    //-------------------------------------------------------------------------
-    // Simulation related
-    double integ_accuracy{1.0e-5};
-    double dt_max{0.03};
-    SimTK::Vec3 gravity{SimTK::Vec3(0, -9.8065, 0)};
-    double mass{10.0};
-    double tf{5.0};
-    const static int n{8};
-    const double hs{0.10}; // half of a side of a cube (like a radius)
-    const Vec3 defaultFloorOrigin{ Vec3(0., -0.004, 0.) };
-    const Rotation
-        defaultFloorRot{ Rotation(-convertDegreesToRadians(90.0), XAxis) };
-    Vec3 corner[n];
-    // Command line options and their defaults
-    InitialConditionsChoice whichInit{Slide};
-    bool noDamp{false};
-    // Model and parts
-    Model* model{nullptr};
-    OpenSim::Body* blockEC{nullptr};
-    OpenSim::ExponentialContactForce* sprEC[n]{nullptr};
-    // Expected simulation steps for running the Simulation test case.
-    // Caution: trys and steps may depend on the operating system
-    // (e.g., Windows, Linux, MacOS).
-    static const int expectedTrys{1817};
-    static const int expectedSteps{1247};
-
-    // Reporters
-    StatesTrajectoryReporter* statesReporter{nullptr};
-
-}; // End class ExponentialContactTester declarations
-
-
-//-----------------------------------------------------------------------------
-// Method implementations for ExponentialContactTester
-//-----------------------------------------------------------------------------
-void
-ExponentialContactTester::
-buildModel()
-{
-    // Create the bodies
-    model = new Model();
-    model->setGravity(gravity);
-    model->setName("BouncingBlock_ExponentialContact");
-    blockEC = addBlock("EC");
-    addExponentialContact(blockEC);
-
-    // StatesTrajectory Reporter
-    statesReporter = new StatesTrajectoryReporter();
-    statesReporter->setName("states_reporter");
-    statesReporter->set_report_time_interval(0.1);
-    model->addComponent(statesReporter);
-}
-
-OpenSim::Body*
-ExponentialContactTester::
-addBlock(const std::string& suffix)
-{
-    Ground& ground = model->updGround();
-
-    // Body
-    std::string name = "block" + suffix;
-    OpenSim::Body* block = new OpenSim::Body();
-    block->setName(name);
-    block->set_mass(mass);
-    block->set_mass_center(Vec3(0));
-    block->setInertia(Inertia(1.0));
-
-    // Joint
-    name = "free" + suffix;
-    FreeJoint *free = new
-        FreeJoint(name, ground, Vec3(0), Vec3(0), *block, Vec3(0), Vec3(0));
-    model->addBody(block);
-    model->addJoint(free);
-
-    return block;
-}
-
-void
-ExponentialContactTester::
-addExponentialContact(OpenSim::Body* block)
-{
-    Ground& ground = model->updGround();
-
-    // Contact Plane Transform
-    // The default floor rotation and postion are constants specified in
-    // ExponentialContactTester declaration.
-    Transform floorXForm(defaultFloorRot, defaultFloorOrigin);
-
-    // Contact Parameters
-    SimTK::ExponentialSpringParameters params;  // yields default params
-    if (noDamp) {
-        params.setNormalViscosity(0.0);
-        params.setFrictionViscosity(0.0);
-        params.setInitialMuStatic(0.0);
-    }
-
-    // Place a spring at each of the 8 corners
-    std::string name = "";
-    for (int i = 0; i < n; ++i) {
-        name = "Exp" + std::to_string(i);
-        sprEC[i] = new OpenSim::ExponentialContactForce(floorXForm,
-            *block, corner[i], params);
-        sprEC[i]->setName(name);
-        model->addForce(sprEC[i]);
-    }
-}
-
-// dz allows for the body to be shifted along the z axis. This is useful for
-// displacing the body spring points upward above the floor.
-void
-ExponentialContactTester::
-setInitialConditions(SimTK::State& state, const SimTK::MobilizedBody& body,
-    double dz)
-{
-    SimTK::Rotation R;
-    SimTK::Vec3 pos(0.0, 0.0, dz);
-    SimTK::Vec3 vel(0.0);
-    SimTK::Vec3 angvel(0.0);
-
-    switch (whichInit) {
-    case Static:
-        pos[0] = 0.0;
-        pos[1] = hs;
-        body.setQToFitTranslation(state, pos);
-        break;
-    case Bounce:
-        pos[0] = 0.0;
-        pos[1] = 1.0;
-        body.setQToFitTranslation(state, pos);
-        break;
-    case Slide:
-        pos[0] = 2.0;
-        pos[1] = 2.0 * hs;
-        vel[0] = -4.0;
-        body.setQToFitTranslation(state, pos);
-        body.setUToFitLinearVelocity(state, vel);
-        break;
-    case Spin:
-        pos[0] = 0.0;
-        pos[1] = hs;
-        vel[0] = 0.0;
-        angvel[1] = 8.0 * SimTK::Pi;
-        body.setQToFitTranslation(state, pos);
-        body.setUToFitLinearVelocity(state, vel);
-        body.setUToFitAngularVelocity(state, angvel);
-        break;
-    case SpinSlide:
-        pos[0] = 1.0;
-        pos[1] = hs;
-        vel[0] = -3.0;
-        angvel[1] = 4.0 * SimTK::Pi;
-        body.setQToFitTranslation(state, pos);
-        body.setUToFitLinearVelocity(state, vel);
-        body.setUToFitAngularVelocity(state, angvel);
-        break;
-    case SpinTop:
-        R.setRotationFromAngleAboutNonUnitVector(
-            convertDegreesToRadians(54.74), Vec3(1, 0, 1));
-        pos[0] = 0.0;
-        pos[1] = 2.0*hs;
-        vel[0] = 0.0;
-        angvel[1] = 1.5 * SimTK::Pi;
-        body.setQToFitRotation(state, R);
-        body.setQToFitTranslation(state, pos);
-        body.setUToFitLinearVelocity(state, vel);
-        body.setUToFitAngularVelocity(state, angvel);
-        break;
-    case Tumble:
-        pos[0] = -1.5;
-        pos[1] = 2.0 * hs;
-        vel[0] = -1.0;
-        angvel[2] = 2.0 * SimTK::Pi;
-        body.setQToFitTranslation(state, pos);
-        body.setUToFitLinearVelocity(state, vel);
-        body.setUToFitAngularVelocity(state, angvel);
-        break;
-    default:
-        cout << "Unrecognized set of initial conditions!" << endl;
-    }
-}
-
-void
-ExponentialContactTester::
-printDiscreteVariableAbstractValue(const string& pathName,
-    const AbstractValue& value) const
-{
-    cout << pathName << " = type{" << value.getTypeName() << "} ";
-    cout << value << " = ";
-
-    // Switch depending on the type
-    if (SimTK::Value<double>::isA(value)) {
-        double x = SimTK::Value<double>::downcast(value);
-        cout << x << endl;
-    } else if (SimTK::Value<Vec3>::isA(value)) {
-        Vec3 x = SimTK::Value<Vec3>::downcast(value);
-        cout << x << endl;
-    }
-}
-
-
-//=============================================================================
-// Test Cases
-//=============================================================================
-
-// Execute a simulation of a bouncing block with exponential contact forces,
-// recording states along the way and serializing the states upon completion.
-TEST_CASE("Simulation")
-{
-    // Create the tester, build the tester model, and initialize the state.
-    ExponentialContactTester tester;
-    CHECK_NOTHROW(tester.buildModel());
-    CHECK_NOTHROW(tester.model->buildSystem());
-    SimTK::State& state = tester.model->initializeState();
-
-
-    // Set initial conditions
-    double dz = 1.0;
-    tester.whichInit = ExponentialContactTester::SpinSlide;
-    tester.setInitialConditions(state, tester.blockEC->getMobilizedBody(), dz);
-
-    // Reset the elastic anchor point for each contact instance.
-    // Resetting the anchor points moves the anchor point directly below its
-    // body station on the block. So, initially, there will be no elastic
-    // friction force acting on the block.
-    ExponentialContactForce::resetAnchorPoints(*tester.model, state);
-
-    // Integrate
-    Manager manager(*tester.model);
-    manager.getIntegrator().setMaximumStepSize(tester.dt_max);
-    manager.setIntegratorAccuracy(tester.integ_accuracy);
-    state.setTime(0.0);
-    manager.initialize(state);
-    manager.setWriteToStorage(true);
-    std::clock_t startTime = std::clock();
-    state = manager.integrate(tester.tf);
-    auto runTime = 1.e3 * (std::clock() - startTime) / CLOCKS_PER_SEC;
-
-    // Output
-    int trys = manager.getIntegrator().getNumStepsAttempted();
-    int steps = manager.getIntegrator().getNumStepsTaken();
-    cout << "           trys:  " << trys << endl;
-    cout << "          steps:  " << steps << endl;
-    cout << "       cpu time:  " << runTime << " msec" << endl;
-
-    // Check that the number of trys and steps match the expected values.
-    CHECK(trys <= ExponentialContactTester::expectedTrys);
-    CHECK(steps <= ExponentialContactTester::expectedSteps);
-
-    // Serialize the states
-    int precision = 10;
-    const StatesTrajectory& statesTraj = tester.statesReporter->getStates();
-    StatesDocument statesDocSe = statesTraj.exportToStatesDocument(
-        *tester.model, "sliding simulation", precision);
-    SimTK::String filename01 = "BouncingBlock_ExponentialContact_1.ostates";
-    CHECK_NOTHROW( statesDocSe.serialize(filename01) );
-
-    // Deserialize the states
-    StatesDocument statesDocDe(filename01);
-    Array_<State> statesTrajDeserialized;
-    CHECK_NOTHROW(
-        statesDocDe.deserialize(*tester.model, statesTrajDeserialized));
-
-    // Check that the number of State objects in the trajectories matches
-    CHECK(statesTraj.getSize() == statesTrajDeserialized.size());
-
-    // Copy the model.
-    Model modelCopy(*tester.model);
-    SimTK::String modelFileName = "BouncingBlock_ExponentialContact_Copy.osim";
-    CHECK_NOTHROW(modelCopy.print(modelFileName));
-}
-
-
-// Test that the model can be serialized and deserialized.
-TEST_CASE("Model Serialization")
-{
-    // Create the tester and build the tester model.
-    ExponentialContactTester tester;
-    CHECK_NOTHROW(tester.buildModel());
-    CHECK_NOTHROW(tester.model->buildSystem());
-
-    // Serialize the model with default properties and spring parameters.
-    std::string fileName = "BouncingBlock_ExponentialContact_Default.osim";
-    CHECK_NOTHROW(tester.model->print(fileName));
-
-    // Deserialize the model
-    Model modelCopy(fileName);
-    CHECK_NOTHROW(modelCopy.buildSystem());
-    std::string copyFileName = "BouncingBlock_ExponentialContact_Copy.osim";
-    modelCopy.print(copyFileName);
-
-    // Check that the properties and spring parameters match the original.
-    const ForceSet& fSet0 = tester.model->getForceSet();
-    const ForceSet& fSet1 = modelCopy.getForceSet();
-    int n = fSet1.getSize();
-    for (int i = 0; i < n; ++i) {
-        try {
-            ExponentialContactForce& ec0 =
-                dynamic_cast<ExponentialContactForce&>(fSet0.get(i));
-            ExponentialContactForce& ec1 =
-                dynamic_cast<ExponentialContactForce&>(fSet1.get(i));
-
-            CHECK(ec1.getContactPlaneTransform() ==
-                    ec0.getContactPlaneTransform());
-
-            const Station& s0 = ec0.getStation();
-            const Station& s1 = ec1.getStation();
-            CHECK(s0.getParentFrame().getAbsolutePathString() ==
-                  s1.getParentFrame().getAbsolutePathString());
-            CHECK(s0.get_location() == s1.get_location());
-
-            CHECK(ec1.getParameters() == ec0.getParameters());
-
-        } catch (const std::bad_cast&) {
-            // Nothing should happen here. Execution is just skipping any
-            // OpenSim::Force that is not an ExponentialContactForce.
-        }
-    }
-
-    // Alter the default spring parameters to test re-serialization.
-    double delta = 0.123;
-    Vec3 shape;
-    ExponentialSpringParameters p = tester.sprEC[0]->getParameters();
-    p.getShapeParameters(shape[0], shape[1], shape[2]);
-    p.setShapeParameters(
-        shape[0] + delta, shape[1] + delta, shape[2] + delta);
-    p.setNormalViscosity(p.getNormalViscosity() + delta);
-    p.setMaxNormalForce(p.getMaxNormalForce() + delta);
-    p.setFrictionElasticity(p.getFrictionElasticity() + delta);
-    p.setFrictionViscosity(p.getFrictionViscosity() + delta);
-    p.setSettleVelocity(p.getSettleVelocity() + delta);
-    p.setInitialMuStatic(p.getInitialMuStatic() + delta);
-    p.setInitialMuKinetic(p.getInitialMuKinetic() + delta);
-    n = fSet0.getSize();
-    for (int i = 0; i < n; ++i) {
-        try {
-            ExponentialContactForce& ec =
-                dynamic_cast<ExponentialContactForce&>(fSet0.get(i));
-            ec.setParameters(p);
-
-        } catch (const std::bad_cast&) {
-            // Nothing should happen here. Execution is just skipping any
-            // OpenSim::Force that is not an ExponentialContactForce.
-        }
-    }
-
-    // Serialize the model with altered properties and spring parameters.
-    fileName = "BouncingBlock_ExponentialContact_Altered.osim";
-    CHECK_NOTHROW(tester.model->print(fileName));
-
-    // Deserialize the model
-    Model modelCopy2(fileName);
-    CHECK_NOTHROW(modelCopy2.buildSystem());
-
-    // Check that the re-deserialized model has the correct spring parameters.
-    const ForceSet& fSet2 = modelCopy2.getForceSet();
-    n = fSet2.getSize();
-    for (int i = 0; i < n; ++i) {
-        try {
-            ExponentialContactForce& ec0 =
-                dynamic_cast<ExponentialContactForce&>(fSet0.get(i));
-            ExponentialContactForce& ec2 =
-                dynamic_cast<ExponentialContactForce&>(fSet2.get(i));
-
-            CHECK(ec2.getContactPlaneTransform() ==
-                ec0.getContactPlaneTransform());
-
-            const Station& s0 = ec0.getStation();
-            const Station& s2 = ec2.getStation();
-            CHECK(s0.getParentFrame().getAbsolutePathString() ==
-                  s2.getParentFrame().getAbsolutePathString());
-            CHECK(s0.get_location() == s2.get_location());
-
-            CHECK(ec2.getParameters() == ec0.getParameters());
-
-        } catch (const std::bad_cast&) {
-            // Nothing should happen here. Execution is just skipping any
-            // OpenSim::Force that is not an ExponentialContactForce.
-        }
-    }
-
-}
-
-// Test that the discrete states of an ExponentialContactForce instance can be
-// set and retrieved properly.
-TEST_CASE("Discrete State Accessors")
-{
-    // Create the tester and build the tester model.
-    ExponentialContactTester tester;
-    CHECK_NOTHROW(tester.buildModel());
-    CHECK_NOTHROW(tester.model->buildSystem());
-
-    // Realize the model and get the state.
-    SimTK::State& state = tester.model->initSystem();
-
-    // Check current properties/parameters of all springs are equal.
-    for (int i = 0; i < tester.n; i++) {
-       CHECK_NOTHROW( tester.sprEC[i]->assertPropertiesAndParametersEqual() );
-    }
-
-    // Pick a contact instance to manipulate.
-    ExponentialContactForce& spr = *tester.sprEC[0];
-
-    // Declarations
-    double deltaDbl = 0.1;
-    Vec3 deltaVec3(deltaDbl);
-    double vali{NaN}, valf{NaN};
-    Vec3 veci{NaN}, vecf{NaN};
-
-    // Static Friction Coefficient
-    vali = spr.getMuStatic(state);
-    spr.setMuStatic(state, vali + deltaDbl);
-    valf = spr.getMuStatic(state);
-    CHECK(valf == vali + deltaDbl);
-
-    // Kinetic Friction Coefficient
-    vali = spr.getMuKinetic(state);
-    spr.setMuKinetic(state, vali + deltaDbl);
-    valf = spr.getMuKinetic(state);
-    CHECK(valf == vali + deltaDbl);
-
-    // Sliding
-    // Note that the "sliding" state is an auto-update discrete state and so
-    // is not settable. It is only retrievable. The "sliding" state is
-    // updated by the ExponentialContactForce instance during simulation after
-    // each successful integration step.
-    // There are bounds (0 <= sliding <= 1.0) that can be checked, however.
-    // In addition, retrieving the sldiing state also requires the state to be
-    // realized to Stage::Dynamics or higher, so we can also check that an
-    // exception is thrown if the state is not realized to that stage when a
-    // "get" is attempted.
-    state.setTime(0.0); // Resets the system to Stage::Time
-    CHECK_THROWS(vali = spr.getSliding(state));
-    tester.model->getMultibodySystem().realize(state, SimTK::Stage::Dynamics);
-    vali = spr.getSliding(state);
-    CHECK(vali >= 0.0);
-    CHECK(vali <= 1.0);
-
-    // Elastic Anchor Point
-    // Like sliding, the "anchor" state is an auto-update discrete state and
-    // so it is not settable in a simple way. See comments for "sliding" above.
-    // The position of an anchar point can, however, be set to correspond
-    // exactly to the position of the body station of its spring.
-    // Note - this is also a good check for 1) resetAnchorPoint(),
-    // 2) getAnchorPointPosition(), and 3) getStationPosition().
-    Vec3 vecAnch{NaN}, vecSta{NaN};
-    state.setTime(0.0); // Resets the system to Stage::Time
-    // Check that an exception is thrown if stage is not Stage::Dynamics.
-    CHECK_THROWS(vecAnch = spr.getAnchorPointPosition(state));
-    spr.resetAnchorPoint(state);
-    tester.model->getMultibodySystem().realize(state, SimTK::Stage::Dynamics);
-    vecAnch = spr.getAnchorPointPosition(state, false);
-    vecSta = spr.getStationPosition(state, false);
-    CHECK(vecAnch[0] == vecSta[0]);
-    CHECK(vecAnch[1] == vecSta[1]);
-    CHECK(vecAnch[2] == 0.0);
-}
-
-
-// Test that the contact plane property of an ExponentialContactForce instance
-// can be set and retrieved properly. This property, along with the properties
-// encapsulated in the ExponentialContactForce::Parameters class (see below),
-// is needed to construct an ExponentialContactForce instance.
-// The ExponentialContactForce::Parameters are tested below in the test case
-// "Spring Parameters".
-TEST_CASE("Contact Plane Transform")
-{
-    // Create the tester and build the model.
-    ExponentialContactTester tester;
-    CHECK_NOTHROW(tester.buildModel());
-    CHECK_NOTHROW(tester.model->buildSystem());
-
-    // Check the accessor.
-    SimTK::Transform xformf = tester.sprEC[0]->getContactPlaneTransform();
-    CHECK(xformf.p() == tester.defaultFloorOrigin);
-    CHECK(xformf.R() == tester.defaultFloorRot);
-}
-
-
-// Test that the underlying spring parameters of an ExponentialContactForce
-// instance can be set and retrieved properly. In addition, verify that the
-// corresponding OpenSim properties and the underlying parameters that belong
-// to the SimTK::ExponentialSpringForce instance are kept consistent with
-// one another.
-TEST_CASE("Spring Parameters")
-{
-    // Create the tester and build the tester model.
-    ExponentialContactTester tester;
-    CHECK_NOTHROW(tester.buildModel());
-    CHECK_NOTHROW(tester.model->buildSystem());
-
-    // Check current properties/parameters of all springs are equal.
-    for (int i = 0; i < tester.n; i++) {
-        CHECK_NOTHROW( tester.sprEC[i]->assertPropertiesAndParametersEqual() );
-    }
-
-    // Pick a contact force instance to manipulate.
-    ExponentialContactForce& spr = *tester.sprEC[0];
-
-    // Save the initial parameters.
-    // Note that pi is not a reference to a set of parameters, but an
-    // independent copy of parameters of the contact force instance.
-    const SimTK::ExponentialSpringParameters pi = spr.getParameters();
-
-    // Create a copy of the parameters that will be systematically modified.
-    SimTK::ExponentialSpringParameters pf = pi;
-
-    // Test equality of the Paremeter instances.
-    CHECK(pf == pi);
-
-    // Exponential Shape
-    double delta = 0.1;
-    Vec3 di, df;
-    pf.getShapeParameters(di[0], di[1], di[2]);
-    // d[0]
-    pf.setShapeParameters(di[0] + delta, di[1], di[2]);
-    pf.getShapeParameters(df[0], df[1], df[2]);
-    CHECK(df[0] == di[0] + delta);
-    CHECK(df[1] == di[1]);
-    CHECK(df[2] == di[2]);
-    spr.setParameters(pi);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-    // d[1]
-    pf.setShapeParameters(di[0], di[1] + delta, di[2]);
-    pf.getShapeParameters(df[0], df[1], df[2]);
-    CHECK(df[0] == di[0]);
-    CHECK(df[1] == di[1] + delta);
-    CHECK(df[2] == di[2]);
-    spr.setParameters(pi);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-    // d[2]
-    pf.setShapeParameters(di[0], di[1], di[2] + delta);
-    pf.getShapeParameters(df[0], df[1], df[2]);
-    CHECK(df[0] == di[0]);
-    CHECK(df[1] == di[1]);
-    CHECK(df[2] == di[2] + delta);
-    spr.setParameters(pi);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-    // all at once
-    pf.setShapeParameters(di[0] + delta, di[1] + delta, di[2] + delta);
-    pf.getShapeParameters(df[0], df[1], df[2]);
-    CHECK(df[0] == di[0] + delta);
-    CHECK(df[1] == di[1] + delta);
-    CHECK(df[2] == di[2] + delta);
-    spr.setParameters(pf);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-    spr.setParameters(pi);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-
-    // Normal Viscosity
-    double vali, valf;
-    vali = pi.getNormalViscosity();
-    pf.setNormalViscosity(vali + delta);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-    valf = pf.getNormalViscosity();
-    CHECK(valf == vali + delta);
-    spr.setParameters(pf);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-    spr.setParameters(pi);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-
-    // Max Normal Force
-    vali = pi.getMaxNormalForce();
-    pf.setMaxNormalForce(vali + delta);
-    valf = pf.getMaxNormalForce();
-    CHECK(valf == vali + delta);
-    spr.setParameters(pf);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-    spr.setParameters(pi);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-
-    // Settle Velocity
-    vali = pi.getSettleVelocity();
-    pf.setSettleVelocity(vali + delta);
-    valf = pf.getSettleVelocity();
-    CHECK(valf == vali + delta);
-    spr.setParameters(pf);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-    spr.setParameters(pi);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-
-    // Friction Elasticity
-    vali = pi.getFrictionElasticity();
-    pf.setFrictionElasticity(vali + delta);
-    valf = pf.getFrictionElasticity();
-    CHECK(valf == vali + delta);
-    spr.setParameters(pf);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-    spr.setParameters(pi);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-
-    // Friction Viscosity
-    vali = pi.getFrictionViscosity();
-    pf.setFrictionViscosity(vali + delta);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-    spr.setParameters(pf);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-    spr.setParameters(pi);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-
-    // Settle Velocity
-    vali = pi.getSettleVelocity();
-    pf.setSettleVelocity(vali + delta);
-    valf = pf.getSettleVelocity();
-    CHECK(valf == vali + delta);
-    spr.setParameters(pf);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-    spr.setParameters(pi);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-
-    // Initial Static Coefficient of Friction
-    vali = pi.getInitialMuStatic();
-    pf.setInitialMuStatic(vali + delta);
-    valf = pf.getInitialMuStatic();
-    CHECK(valf == vali + delta);
-    spr.setParameters(pf);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-    spr.setParameters(pi);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-
-    // Initial Kinetic Coefficient of Friction
-    vali = pi.getInitialMuKinetic();
-    pf.setInitialMuKinetic(vali - delta);
-    valf = pf.getInitialMuKinetic();
-    CHECK(valf == vali - delta);
-    spr.setParameters(pf);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-    spr.setParameters(pi);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-
-    // Make a change to mus that should also change muk
-    double musi = pi.getInitialMuStatic();
-    double muki = pi.getInitialMuKinetic();
-    pf.setInitialMuStatic(muki - delta);  // this should enforce muk <= mus
-    double musf = pf.getInitialMuStatic();
-    double mukf = pf.getInitialMuKinetic();
-    CHECK(musf == muki - delta);
-    CHECK(mukf == musf);
-    spr.setParameters(pf);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-    spr.setParameters(pi);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-
-    // Make a change to muk that should also change mus
-    musi = pi.getInitialMuStatic();
-    muki = pi.getInitialMuKinetic();
-    pf.setInitialMuKinetic(musi + delta);  // this should enforce mus >= muk
-    musf = pf.getInitialMuStatic();
-    mukf = pf.getInitialMuKinetic();
-    CHECK(mukf == musi + delta);
-    CHECK(musf == mukf);
-    spr.setParameters(pf);
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-    spr.setParameters(pi); // now back to original
-    CHECK_NOTHROW( spr.assertPropertiesAndParametersEqual() );
-}
-
-// Test copy construction, the copy assignment operator, and move construction
-// before and after the SimTK System has been built.
-TEST_CASE("Construction")
-{
-    // Create the model
-    Model* model = new Model();
-    model->setGravity(Vec3(0, -9.8, 0));
-    model->setName("SimpleBlock");
-
-    // Add a body and joint
-    Ground& ground = model->updGround();
-    OpenSim::Body* block = new OpenSim::Body();
-    block->setName("block");
-    block->set_mass(10.0);
-    block->set_mass_center(Vec3(0));
-    block->setInertia(Inertia(1.0));
-    FreeJoint* free = new
-        FreeJoint("free", ground, Vec3(0), Vec3(0), *block, Vec3(0), Vec3(0));
-    model->addBody(block);
-    model->addJoint(free);
-
-    // Add ExponentialContactForce instances
-    Vec3 floorOrigin(0., -0.004, 0.);
-    SimTK::ExponentialSpringParameters params;
-    Real elasticity0 = params.getFrictionElasticity();
-    // ---- params1
-    Real elasticity1 = elasticity0 + 0.1;
-    params.setFrictionElasticity(elasticity1);
-    // ---- transform1
-    Real angle1 = convertDegreesToRadians(85.0);
-    Rotation floorRot1(-angle1, XAxis);
-    Transform floorXForm1(floorRot1, floorOrigin);
-    Vec3 v1(0.1, 0.1, 0.1);
-    // ----frc1
-    ExponentialContactForce* frc1 = new
-        ExponentialContactForce(floorXForm1, *block, v1, params);
-    frc1->setName("ExpFrc1");
-    model->addForce(frc1);
-    // ---- params2
-    Real elasticity2 = elasticity0 + 0.2;
-    params.setFrictionElasticity(elasticity2);
-    // ---- transform2
-    Real angle2 = convertDegreesToRadians(95.0);
-    Rotation floorRot2(-angle2, XAxis);
-    Transform floorXForm2(floorRot2, floorOrigin);
-    Vec3 v2(-0.1, -0.1, -0.1);
-    // ---- frc2
-    ExponentialContactForce* frc2 = new
-        ExponentialContactForce(floorXForm2, *block, v2, params);
-    frc2->setName("ExpFrc2");
-    model->addForce(frc2);
-
-    // All properties, except for the station, can be copied/assigned
-    // because none of the contact forces wrap an instantiated
-    // ExponentialSpringForce.
-    ExponentialContactForce* frc1Copy = new ExponentialContactForce(*frc1);
-    frc1Copy->setName("ExpFrc1Copy");
-    CHECK(frc1Copy->getParameters().getFrictionElasticity() == elasticity1);
-    CHECK(frc1Copy->getContactPlaneTransform() == floorXForm1);
-
-    // Copy Assignment
-    // All properties and the station can be assigned because frcDefault
-    // doesn't wrap an instantiated SimTK::ExponentialSpringForce.
-    ExponentialContactForce* frcDefault = new ExponentialContactForce();
-    CHECK(frcDefault->getParameters().getFrictionElasticity() == elasticity0);
-    CHECK_FALSE(SimTK::Test::numericallyEqual(
-            frcDefault->getContactPlaneTransform(), floorXForm1, 1))  ;
-    *frcDefault = *frc1;
-    CHECK(frcDefault->getParameters().getFrictionElasticity() == elasticity1);
-    CHECK(frcDefault->getContactPlaneTransform() == floorXForm1);
-    delete frcDefault;
-
-    // TODO: We cannot copy assign after the underlying ExponentialSpringForce
-    // instances have been added to the model because the compiler-generated
-    // assignment breaks the Station's Socket connection to the PhysicalFrame.
-    // Copy assignment when the springs have been added to the model
-    // *frc1 = *frc2;
-    // CHECK(frc1->getParameters().getFrictionElasticity() == elasticity2);
-    // CHECK(frc1->getContactPlaneTransform() == floorXForm2);
-
-    // Build the system
-    model->buildSystem();
-
-    // Perform similar checks again.
-    *frc1 = *frc1Copy;
-    CHECK(frc1->getParameters().getFrictionElasticity() == elasticity1);
-    CHECK(frc1->getContactPlaneTransform() == floorXForm1);
-    *frc1 = *frc2;
-    CHECK(frc1->getParameters().getFrictionElasticity() == elasticity2);
-    CHECK(frc1->getContactPlaneTransform() == floorXForm2);
-    ExponentialContactForce* frc2Copy = new ExponentialContactForce(*frc2);
-    frc2Copy->setName("ExpFrc2Copy");
-    CHECK(frc2Copy->getParameters().getFrictionElasticity() == elasticity2);
-    CHECK(frc2Copy->getContactPlaneTransform() == floorXForm2);
-
-    // Check that no segfaults occur when deleting the original and its copy.
-    frcDefault = new ExponentialContactForce();
-    CHECK(frcDefault->getParameters().getFrictionElasticity() == elasticity0);
-    CHECK_FALSE(SimTK::Test::numericallyEqual(
-            frcDefault->getContactPlaneTransform(), floorXForm1, 1));
-    ExponentialContactForce* frcDefaultCopy =
-        new ExponentialContactForce(*frcDefault);
-    CHECK(frcDefaultCopy->getParameters().getFrictionElasticity() == elasticity0);
-    CHECK_FALSE(SimTK::Test::numericallyEqual(
-            frcDefaultCopy->getContactPlaneTransform(), floorXForm1, 1));
-    delete frcDefault;
-    delete frcDefaultCopy;
-
-    // Move Construction
-    params.setFrictionElasticity(elasticity1);
-    ExponentialContactForce* frc3 =
-        new ExponentialContactForce(floorXForm1, *block, v1, params);
-    frc3->setName("ExpFrc3");
-    ExponentialContactForce* frc3Move =
-        new ExponentialContactForce(std::move(*frc3));
-    CHECK(frc3Move->getParameters().getFrictionElasticity() == elasticity1);
-    CHECK(frc3Move->getContactPlaneTransform() == floorXForm1);
-    model->addForce(frc3);
-    model->buildSystem();
-    ExponentialContactForce* frc3MoveAfterBuild =
-        new ExponentialContactForce(std::move(*frc3));
-    CHECK(frc3MoveAfterBuild->getParameters().getFrictionElasticity() == elasticity1);
-    CHECK(frc3MoveAfterBuild->getContactPlaneTransform() == floorXForm1);
-    delete frc3Move;
-    delete frc3MoveAfterBuild;
-
-    // Clean up
-    // frc1 and frc2 are already deleted by the model destructor
-    delete frc1Copy;
-    delete frc2Copy;
-    delete model;
-}
-
-
-/* The following code is not currently used in the test suite, but it is a
-// good example of how to set/get discrete variables at a low level, which
-// may be useful if deeper testing is warranted.
-
-// The only types that are handled are double and Vec3 at this point.
-// The significant changes in how Discrete Variables are handled are:
-//      1. Values are now not assumed to be doubles but are AbstractValues.
-//      2. Discrete variables allocated external to OpenSim are permitted.
-//      3. Discrete variables may be accessed via the Component API by
-//      specifying the path (e.g., path = "/forceset/Exp0/anchor").
-void
-ExponentialContactTester::
-testDiscreteVariables(State& state, const ForceSet& fSet) {
-
-    // Get the names
-    OpenSim::Array<std::string> names = fSet.getDiscreteVariableNames();
-
-    // Loop
-    int n = names.size();
-    for (int i = 0; i < n; ++i) {
-
-        // Print values for debugging purposes.
-        AbstractValue& valAbstract =
-            fSet.updDiscreteVariableAbstractValue(state, names[i]);
-        //printDiscreteVariableAbstractValue(names[i], valAbstract);
-
-        // Declarations
-        double tol = 1.0e-6;
-        double deltaDbl = 0.1;
-        Vec3 deltaVec3(deltaDbl);
-        double valStartDbl{NaN};
-        Vec3 valStartVec3{NaN};
-
-        // Perturb
-        if (SimTK::Value<double>::isA(valAbstract)) {
-            SimTK::Value<double>& valDbl =
-                SimTK::Value<double>::updDowncast(valAbstract);
-            valStartDbl = valDbl;
-            valDbl = valStartDbl + deltaDbl;
-        } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
-            SimTK::Value<Vec3>& valVec3 =
-                SimTK::Value<Vec3>::updDowncast(valAbstract);
-            valStartVec3 = valVec3.get();
-            valVec3 = valStartVec3 + deltaVec3;
-        }
-        //printDiscreteVariableAbstractValue(names[i], valAbstract);
-
-        // Check that the value changed correctly
-        if (SimTK::Value<double>::isA(valAbstract)) {
-            SimTK::Value<double>& valDbl =
-                SimTK::Value<double>::updDowncast(valAbstract);
-            ASSERT_EQUAL(valDbl.get(), valStartDbl + deltaDbl, tol);
-        } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
-            SimTK::Value<Vec3>& valVec3 =
-                SimTK::Value<Vec3>::updDowncast(valAbstract);
-            ASSERT_EQUAL(valVec3.get(), valStartVec3 + deltaVec3, tol);
-        }
-
-        // Restore the starting value
-        if (SimTK::Value<double>::isA(valAbstract)) {
-            SimTK::Value<double>& valDbl =
-                SimTK::Value<double>::updDowncast(valAbstract);
-            valDbl = valStartDbl;
-        } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
-            SimTK::Value<Vec3>& valVec3 =
-                SimTK::Value<Vec3>::updDowncast(valAbstract);
-            valVec3 = valStartVec3;
-        }
-        //printDiscreteVariableAbstractValue(names[i], valAbstract);
-
-        // Check that the value was correctly restored
-        if (SimTK::Value<double>::isA(valAbstract)) {
-            SimTK::Value<double>& valDbl =
-                SimTK::Value<double>::updDowncast(valAbstract);
-            ASSERT_EQUAL(valDbl.get(), valStartDbl, tol);
-        } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
-            SimTK::Value<Vec3>& valVec3 =
-                SimTK::Value<Vec3>::updDowncast(valAbstract);
-            ASSERT_EQUAL(valVec3.get(), valStartVec3, tol);
-        }
-
-    }
-
-}
-*/
diff --git a/OpenSim/Simulation/Test/testForceProducer.cpp b/OpenSim/Simulation/Test/testForceProducer.cpp
index 0c07915d9..756176ac9 100644
--- a/OpenSim/Simulation/Test/testForceProducer.cpp
+++ b/OpenSim/Simulation/Test/testForceProducer.cpp
@@ -387,7 +387,7 @@ TEST_CASE("ForceProducer (ExampleForceProducer)")
 
         // step 1) build a model with "equivalent" `ForceProducer` and `Force` implementations
         Model model;
-        auto* body          = new Body{"body", 1.0, SimTK::Vec3{0.0}, SimTK::Inertia{1.0}};
+        auto* body          = new OpenSim::Body{"body", 1.0, SimTK::Vec3{0.0}, SimTK::Inertia{1.0}};
         auto* joint         = new FreeJoint{"joint", model.getGround(), *body};
         auto* force         = new MockForce{*body, joint->get_coordinates(0)};
         auto* forceProducer = new MockForceProducer{*body, joint->get_coordinates(0)};
@@ -425,7 +425,7 @@ TEST_CASE("ForceProducer (ExampleForceProducer)")
         // should check when it wants to APPLY forces to the multibody system (i.e. during
         // `ForceProducer::computeForce` override to satisfy the `OpenSim::Force` API)
         Model model;
-        auto* body          = new Body{"body", 1.0, SimTK::Vec3{0.0}, SimTK::Inertia{1.0}};
+        auto* body          = new OpenSim::Body{"body", 1.0, SimTK::Vec3{0.0}, SimTK::Inertia{1.0}};
         auto* joint         = new FreeJoint{"joint", model.getGround(), *body};
         auto* forceProducer = new MockForceProducer{*body, joint->get_coordinates(0)};
         forceProducer->set_appliesForce(false);  // should disable force application
diff --git a/OpenSim/Simulation/Test/testFrames.cpp b/OpenSim/Simulation/Test/testFrames.cpp
index 480cd223c..2f434b9cb 100644
--- a/OpenSim/Simulation/Test/testFrames.cpp
+++ b/OpenSim/Simulation/Test/testFrames.cpp
@@ -360,7 +360,7 @@ TEST_CASE("PhysicalOffsetFrameOnPhysicalOffsetFrameOrder")
 
     // Now attach them such that offsetFrameProximal is attached to rod2 of
     // the pendulum and offsetFrameDistal is attached to offsetFrameProximal
-    const Body& rod2 = pendulum.getComponent<Body>("./bodyset/rod2");
+    const OpenSim::Body& rod2 = pendulum.getComponent<OpenSim::Body>("./bodyset/rod2");
     offsetFrameProximal->setParentFrame(rod2);
     offsetFrameDistal->setParentFrame(*offsetFrameProximal);
 
@@ -437,7 +437,7 @@ TEST_CASE("FilterByFrameType")
 
     i = 0;
     std::cout << "\nList all Bodies in the model." << std::endl;
-    for (auto& component : pendulumWFrame->getComponentList<Body>()) {
+    for (auto& component : pendulumWFrame->getComponentList<OpenSim::Body>()) {
         std::cout << "frame[" << ++i << "] is " << component.getName()
             << " of type " << typeid(component).name() << std::endl;
     }
diff --git a/OpenSim/Simulation/Test/testInitState.cpp b/OpenSim/Simulation/Test/testInitState.cpp
index f959e8733..650e6db38 100644
--- a/OpenSim/Simulation/Test/testInitState.cpp
+++ b/OpenSim/Simulation/Test/testInitState.cpp
@@ -40,7 +40,6 @@ using namespace std;
 
 TEST_CASE("testStates")
 {
-    using namespace SimTK;
     LoadOpenSimLibrary("osimActuators");
     //==========================================================================
     // Setup OpenSim model
@@ -51,16 +50,16 @@ TEST_CASE("testStates")
 
     model.addController( controller );
     // original default state
-    State& state = model.initSystem();
+    SimTK::State& state = model.initSystem();
 
     // hold on to original default continuous state variables
-    Vector y1 = state.getY();
+    SimTK::Vector y1 = state.getY();
     y1 = state.getY();
     //y1.dump("y1: Initial state:");
 
     // update state to contain muscle states that yield muscle equilibrium
     model.equilibrateMuscles(state);
-    state.getY().dump("y1: State after equilibrateMuscles:");
+    state.getY().dump("y1: SimTK::State after equilibrateMuscles:");
     //==========================================================================
     // Compute the force and torque at the specified times.
     Manager manager(model);
@@ -71,20 +70,20 @@ TEST_CASE("testStates")
     manager.integrate(0.05);
 
     // continuous state variables after simulation
-    Vector y2 = state.getY();
-    //y2.dump("y2: State after integration:");
+    SimTK::Vector y2 = state.getY();
+    //y2.dump("y2: SimTK::State after integration:");
 
     // reset model working state to default state
-    State& state2 = model.initializeState();
+    SimTK::State& state2 = model.initializeState();
 
     // another version of default continuous state variables 
     // should be unaffected by simulation of the system
-    Vector y3 = state2.getY();
+    SimTK::Vector y3 = state2.getY();
     //y3.dump("y3: Model reset to Initial state:");
 
     // update state to contain muscle states that yield muscle equilibrium
     model.equilibrateMuscles(state2);
-    state.getY().dump("y3: State after equilibrateMuscles:");
+    state.getY().dump("y3: SimTK::State after equilibrateMuscles:");
     //==========================================================================
     // Compute the force and torque at the specified times.
     Manager manager2(model);
@@ -96,9 +95,9 @@ TEST_CASE("testStates")
 
     // get the default continuous state variables updated
     // from the state after the simulation
-    Vector y4 = state2.getY();
+    SimTK::Vector y4 = state2.getY();
     
-    //y4.dump("y4: Default State after second simulation:");
+    //y4.dump("y4: Default SimTK::State after second simulation:");
 
     for (int i = 0; i < y1.size(); i++) 
     {
@@ -110,5 +109,4 @@ TEST_CASE("testStates")
             "Model failed to properly update default state after simulation.");
     }
     ASSERT(max(abs(y1-y2)) > 1e-4);
-}
-
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/Test/testInverseKinematicsSolver.cpp b/OpenSim/Simulation/Test/testInverseKinematicsSolver.cpp
index 2d0f4a3e6..474f5145e 100644
--- a/OpenSim/Simulation/Test/testInverseKinematicsSolver.cpp
+++ b/OpenSim/Simulation/Test/testInverseKinematicsSolver.cpp
@@ -42,8 +42,8 @@ namespace {
     Model* constructPendulumWithMarkers() {
         Model* pendulum = new Model();
         pendulum->setName("pendulum");
-        Body* ball =
-            new Body("ball", 1.0, SimTK::Vec3(0), SimTK::Inertia::sphere(0.05));
+        OpenSim::Body* ball =
+            new OpenSim::Body("ball", 1.0, SimTK::Vec3(0), SimTK::Inertia::sphere(0.05));
         pendulum->addBody(ball);
 
         // PinJoint hinge is 1m above ground origin and 1m above the ball in the 
@@ -145,16 +145,16 @@ namespace {
     {
         std::unique_ptr<Model> leg{ new Model() };
         leg->setName("leg");
-        Body* thigh =
-            new Body("thigh", 5.0, SimTK::Vec3(0),
+        OpenSim::Body* thigh =
+            new OpenSim::Body("thigh", 5.0, SimTK::Vec3(0),
                     SimTK::Inertia::cylinderAlongY(0.1, 0.5) );
         leg->addBody(thigh);
-        Body* shank =
-            new Body("shank", 2.0, SimTK::Vec3(0),
+        OpenSim::Body* shank =
+            new OpenSim::Body("shank", 2.0, SimTK::Vec3(0),
                     SimTK::Inertia::cylinderAlongY(0.04, 0.4) );
         leg->addBody(shank);
-        Body* foot =
-            new Body("foot", 1.0, SimTK::Vec3(0),
+        OpenSim::Body* foot =
+            new OpenSim::Body("foot", 1.0, SimTK::Vec3(0),
                 SimTK::Inertia::cylinderAlongY(0.02, 0.1));
         leg->addBody(foot);
 
diff --git a/OpenSim/Simulation/Test/testManager.cpp b/OpenSim/Simulation/Test/testManager.cpp
index df658d7d8..8ebe69839 100644
--- a/OpenSim/Simulation/Test/testManager.cpp
+++ b/OpenSim/Simulation/Test/testManager.cpp
@@ -42,7 +42,7 @@ namespace {
         model.setName("ball");
         model.setGravity(SimTK::Vec3(0, -9.81, 0));
 
-        auto ball = new Body("ball", 0.7, SimTK::Vec3(0.1),
+        auto ball = new OpenSim::Body("ball", 0.7, SimTK::Vec3(0.1),
             SimTK::Inertia::sphere(0.5));
         model.addBody(ball);
 
@@ -127,7 +127,7 @@ TEST_CASE("Station calculations with Manager") {
     Model pendulum;
     pendulum.setName("pendulum");
 
-    auto rod = new Body("rod", 0.54321, SimTK::Vec3(0.1, 0.5, 0.2),
+    auto rod = new OpenSim::Body("rod", 0.54321, SimTK::Vec3(0.1, 0.5, 0.2),
         SimTK::Inertia::cylinderAlongY(0.025, 0.55));
     pendulum.addBody(rod);
 
@@ -201,7 +201,7 @@ TEST_CASE("State changes between integration") {
     Station* myStation = new Station();
     const SimTK::Vec3 point(0);
     myStation->set_location(point);
-    myStation->setParentFrame(model.getComponent<Body>("/bodyset/ball"));
+    myStation->setParentFrame(model.getComponent<OpenSim::Body>("/bodyset/ball"));
     model.addModelComponent(myStation);
 
     SimTK::State& state = model.initSystem();
diff --git a/OpenSim/Simulation/Test/testModelInterface.cpp b/OpenSim/Simulation/Test/testModelInterface.cpp
index 150002150..434a1bea4 100644
--- a/OpenSim/Simulation/Test/testModelInterface.cpp
+++ b/OpenSim/Simulation/Test/testModelInterface.cpp
@@ -77,7 +77,7 @@ void testModelFinalizePropertiesAndConnections()
         ASSERT(model.isObjectUpToDateWithProperties());
 
         // make an edit through model's ComponentList access
-        for (auto& body : model.updComponentList<Body>()) {
+        for (auto& body : model.updComponentList<OpenSim::Body>()) {
             body.upd_mass_center() = SimTK::Vec3(0);
             break;
         }
@@ -121,7 +121,7 @@ void testModelFinalizePropertiesAndConnections()
         auto& sys = model.getSystem();
 
         auto elbowInHumerus = new PhysicalOffsetFrame("elbow_in_humerus",
-            model.getComponent<Body>("./bodyset/r_humerus"),
+            model.getComponent<OpenSim::Body>("./bodyset/r_humerus"),
             SimTK::Transform(SimTK::Vec3(0, -0.33, 0)) );
 
         model.addComponent(elbowInHumerus);
@@ -167,7 +167,7 @@ void testModelTopologyErrors()
 
     // create and offset for the elbow joint in the humerus
     auto elbowInHumerus = new PhysicalOffsetFrame("elbow_in_humerus",
-        model.getComponent<Body>("./bodyset/r_humerus"),
+        model.getComponent<OpenSim::Body>("./bodyset/r_humerus"),
         SimTK::Transform(SimTK::Vec3(0, -0.33, 0)));
 
     model.addComponent(elbowInHumerus);
diff --git a/OpenSim/Simulation/Test/testMomentArms.cpp b/OpenSim/Simulation/Test/testMomentArms.cpp
index ab9af5757..d63858b59 100644
--- a/OpenSim/Simulation/Test/testMomentArms.cpp
+++ b/OpenSim/Simulation/Test/testMomentArms.cpp
@@ -24,7 +24,7 @@
 //=============================================================================
 // testMomentArms loads various OpenSim models to compute and test moment arms
 // results from these models to the definition r*f = Tau , where r is the 
-// moment-arm about a coordinate, f is the scaler magnitude of the Force and 
+// moment-arm about a coordinate, f is the scaler magnitude of the SimTK::Force and 
 // Tau is the resulting generalized force. 
 //
 //  Tests Include:
@@ -143,7 +143,7 @@ void testMomentArmsAcrossCompoundJoint()
 {
     Model model;
 
-    Body* leg = new Body("leg", 10., SimTK::Vec3(0,1,0), SimTK::Inertia(1,1,1));
+    OpenSim::Body* leg = new OpenSim::Body("leg", 10., SimTK::Vec3(0,1,0), SimTK::Inertia(1,1,1));
     model.addComponent(leg);
 
     CompoundJoint* hip = new CompoundJoint("hip",
@@ -171,8 +171,6 @@ void testMomentArmsAcrossCompoundJoint()
 //==========================================================================================================
 double computeMomentArmFromDefinition(const SimTK::State &s, const GeometryPath &path, const Coordinate &coord)
 {
-    using namespace SimTK;
-
     //Compute r = dl/dtheta
     SimTK::State s_ma = s;
     coord.setClamped(s_ma, false);
@@ -211,10 +209,8 @@ double computeMomentArmFromDefinition(const SimTK::State &s, const GeometryPath
 SimTK::Vector computeGenForceScaling(const Model &osimModel, const SimTK::State &s, const Coordinate &coord, 
                               const Array<string> &coupledCoords)
 {
-    using namespace SimTK;
-
     //Local modifiable copy of the state
-    State s_ma = s;
+    SimTK::State s_ma = s;
 
     osimModel.getMultibodySystem().realize(s_ma, SimTK::Stage::Instance);
 
@@ -233,14 +229,14 @@ SimTK::Vector computeGenForceScaling(const Model &osimModel, const SimTK::State
     
     // Now calculate C. by checking how speeds of other coordinates change
     // normalized by how much the speed of the coordinate of interest changed. 
-    const Vector C = s_ma.getU() / coord.getSpeedValue(s_ma); 
+    const SimTK::Vector C = s_ma.getU() / coord.getSpeedValue(s_ma); 
     
     // Compute the scaling matrix for converting gen_forces to torques
     // Unlike C, ignore all coupling that are not explicit coordinate
     // coupling that defines theta = sum(q_i) or q_i = w_i*theta.
     // Also do not consider coupled torques for coordinates not spanned by 
     // the path of interest.
-    Vector W(osimModel.getNumSpeeds(), 0.0);
+    SimTK::Vector W(osimModel.getNumSpeeds(), 0.0);
 
     for(int i=0; i< osimModel.getCoordinateSet().getSize(); i++){
         Coordinate &ac = osimModel.getCoordinateSet()[i];
@@ -250,9 +246,9 @@ SimTK::Vector computeGenForceScaling(const Model &osimModel, const SimTK::State
         // and not translational (cannot contribute to torque)
         if(found && (ac.getMotionType() != Coordinate::Translational) 
                 && (ac.getJoint().getName() != "tib_pat_r") ){
-            MobilizedBodyIndex modbodIndex = ac.getBodyIndex();
-            const MobilizedBody& mobod = osimModel.getMatterSubsystem().getMobilizedBody(modbodIndex);
-            SpatialVec Hcol = mobod.getHCol(s, SimTK::MobilizerUIndex(0)); //ac.getMobilizerQIndex())); // get nth column of H
+            SimTK::MobilizedBodyIndex modbodIndex = ac.getBodyIndex();
+            const SimTK::MobilizedBody& mobod = osimModel.getMatterSubsystem().getMobilizedBody(modbodIndex);
+            SimTK::SpatialVec Hcol = mobod.getHCol(s, SimTK::MobilizerUIndex(0)); //ac.getMobilizerQIndex())); // get nth column of H
 
             /*double thetaScale = */Hcol[0].norm(); // magnitude of the rotational part of this column of H
             
@@ -273,8 +269,6 @@ void testMomentArmDefinitionForModel(const string &filename, const string &coord
                                     const string &muscleName, SimTK::Vec2 rom,
                                     double mass, string errorMessage)
 {
-    using namespace SimTK;
-
     bool passesDefinition = true;
     bool passesDynamicConsistency = true;
 
@@ -295,7 +289,7 @@ void testMomentArmDefinitionForModel(const string &filename, const string &coord
     if( mass >= 0.0){
         for(int i=0; i<osimModel.updBodySet().getSize(); i++){
             osimModel.updBodySet()[i].setMass(mass);
-            Inertia inertia(mass);
+            SimTK::Inertia inertia(mass);
             osimModel.updBodySet()[i].setInertia(inertia);
         }
     }
@@ -352,7 +346,7 @@ void testMomentArmDefinitionForModel(const string &filename, const string &coord
         double ma = maSolver.solve(s, coord, muscle.getGeometryPath());
         double ma_dldtheta = computeMomentArmFromDefinition(s, muscle.getGeometryPath(), coord);
 
-        cout << "r's = " << ma << "::" << ma_dldtheta <<"  at q = " << coord.getValue(s)*180/Pi; 
+        cout << "r's = " << ma << "::" << ma_dldtheta <<"  at q = " << coord.getValue(s)*180/SimTK::Pi; 
 
         try {
             // Verify that the definition of the moment-arm is satisfied
@@ -366,23 +360,23 @@ void testMomentArmDefinitionForModel(const string &filename, const string &coord
         if (mass!=0 ) {
             muscle.overrideActuation(s, true);
             muscle.setOverrideActuation(s, 10);
-            osimModel.getMultibodySystem().realize(s, Stage::Acceleration);
+            osimModel.getMultibodySystem().realize(s, SimTK::Stage::Acceleration);
 
             double force = muscle.getActuation(s);
         
             // Get muscle's applied body forces 
-            const Vector_<SpatialVec>& appliedBodyForces = osimModel.getMultibodySystem().getRigidBodyForces(s, Stage::Dynamics);
-            //appliedBodyForces.dump("Applied Body Force resulting from muscle");
+            const SimTK::Vector_<SimTK::SpatialVec>& appliedBodyForces = osimModel.getMultibodySystem().getRigidBodyForces(s, SimTK::Stage::Dynamics);
+            //appliedBodyForces.dump("Applied SimTK::Body SimTK::Force resulting from muscle");
 
             // And any applied mobility (gen) forces due to gearing (moving path point)
-            const Vector& appliedGenForce = osimModel.getMultibodySystem().getMobilityForces(s, Stage::Dynamics);       
+            const SimTK::Vector& appliedGenForce = osimModel.getMultibodySystem().getMobilityForces(s, SimTK::Stage::Dynamics);       
 
             // Get current system accelerations
-            const Vector& knownUDots = s.getUDot();
+            const SimTK::Vector& knownUDots = s.getUDot();
             //knownUDots.dump("Acceleration due to ECU muscle:");
 
             // Convert body forces to equivalent mobility forces (joint torques)
-            Vector equivalentGenForce(s.getNU(), 0.0);
+            SimTK::Vector equivalentGenForce(s.getNU(), 0.0);
             osimModel.getMultibodySystem().getMatterSubsystem().calcTreeEquivalentMobilityForces(s, 
                 appliedBodyForces, equivalentGenForce);
             if(s.getSystemStage() < SimTK::Stage::Dynamics)
@@ -392,22 +386,22 @@ void testMomentArmDefinitionForModel(const string &filename, const string &coord
             equivalentGenForce += appliedGenForce;
 
             // Determine the contribution of constraints (if any) to the effective torque
-            Vector_<SimTK::SpatialVec> constraintForcesInParent;
-            Vector constraintMobilityForces;
+            SimTK::Vector_<SimTK::SpatialVec> constraintForcesInParent;
+            SimTK::Vector constraintMobilityForces;
 
             // Get all forces applied to model by constraints
             osimModel.getMultibodySystem().getMatterSubsystem().calcConstraintForcesFromMultipliers(s, -s.getMultipliers(), 
                 constraintForcesInParent, constraintMobilityForces);
         
             // Perform inverse dynamics
-            Vector ivdGenForces;
+            SimTK::Vector ivdGenForces;
             osimModel.getMultibodySystem().getMatterSubsystem().calcResidualForceIgnoringConstraints(s,
                 constraintMobilityForces, constraintForcesInParent, knownUDots, ivdGenForces);
             
-            //constraintForcesInParent.dump("Constraint Body Forces");
+            //constraintForcesInParent.dump("Constraint SimTK::Body Forces");
             //constraintMobilityForces.dump("Constraint Mobility Forces");
 
-            Vector W = computeGenForceScaling(osimModel, s, coord, coupledCoordNames);
+            SimTK::Vector W = computeGenForceScaling(osimModel, s, coord, coupledCoordNames);
 
             double equivalentMuscleTorque = ~W*equivalentGenForce;
             double equivalentIvdMuscleTorque = ~W*(ivdGenForces); //+constraintMobilityForces);
@@ -441,4 +435,4 @@ void testMomentArmDefinitionForModel(const string &filename, const string &coord
     // Minimum requirement to pass is that calculated moment-arm satisfies either
     // dL/dTheta definition or is at least dynamically consistent, in which dL/dTheta is not
     ASSERT(passesDefinition || passesDynamicConsistency, __FILE__, __LINE__, errorMessage);
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/Test/testMuscleMetabolicsProbes.cpp b/OpenSim/Simulation/Test/testMuscleMetabolicsProbes.cpp
index 9da77d650..ec24bf4af 100644
--- a/OpenSim/Simulation/Test/testMuscleMetabolicsProbes.cpp
+++ b/OpenSim/Simulation/Test/testMuscleMetabolicsProbes.cpp
@@ -68,7 +68,6 @@ const bool DISPLAY_ERROR_CALCULATIONS = false;
 const bool OUTPUT_FILES               = false;
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 
@@ -369,13 +368,13 @@ void generateUmbergerMuscleData(const std::string& muscleName,
     // the properties of the block are irrelevant.
     const double blockMass       = 1.0;
     const double blockSideLength = 0.1;
-    Inertia blockInertia = blockMass * Inertia::brick(Vec3(blockSideLength/2));
-    OpenSim::Body *block = new OpenSim::Body("block", blockMass, Vec3(0),
+    SimTK::Inertia blockInertia = blockMass * SimTK::Inertia::brick(SimTK::Vec3(blockSideLength/2));
+    OpenSim::Body *block = new OpenSim::Body("block", blockMass, SimTK::Vec3(0),
                                              blockInertia);
 
     // Create slider joint between ground and block.
-    SliderJoint* prismatic = new SliderJoint("prismatic", ground, Vec3(0), Vec3(0),
-                                                *block, Vec3(0), Vec3(0));
+    SliderJoint* prismatic = new SliderJoint("prismatic", ground, SimTK::Vec3(0), SimTK::Vec3(0),
+                                                *block, SimTK::Vec3(0), SimTK::Vec3(0));
     prismatic->updCoordinate().setName("xTranslation");
     model.addBody(block);
     model.addJoint(prismatic);
@@ -383,8 +382,8 @@ void generateUmbergerMuscleData(const std::string& muscleName,
     // Create muscle attached to ground and block.
     UmbergerMuscle *muscle = new UmbergerMuscle(muscleName, maxIsometricForce,
         optimalFiberLength, width, Arel, Brel, FmaxEccentric);
-    muscle->addNewPathPoint("muscle-ground", ground, Vec3(0));
-    muscle->addNewPathPoint("muscle-block",  *block, Vec3(0));
+    muscle->addNewPathPoint("muscle-ground", ground, SimTK::Vec3(0));
+    muscle->addNewPathPoint("muscle-block",  *block, SimTK::Vec3(0));
     model.addForce(muscle);
 
     // Attach muscle controller.
@@ -437,7 +436,7 @@ void generateUmbergerMuscleData(const std::string& muscleName,
         cout << "\n\nResults for " << muscleName << " shortening test" << endl;
         for (int i=0; i<4*w; ++i) {cout << "=";} cout << endl;
         cout << setw(w) << "Velocity"
-             << setw(w) << "Force"
+             << setw(w) << "SimTK::Force"
              << setw(w) << "Mech power"
              << setw(w) << "Total rate" << endl;
         for (int i=0; i<4*w; ++i) {cout << "=";} cout << endl;
@@ -477,7 +476,7 @@ void compareUmbergerProbeToPublishedResults()
         cout << "\n\nAbsolute errors for soleus shortening test" << endl;
         for (int i=0; i<4*w; ++i) {cout << "=";} cout << endl;
         cout << setw(w) << "Velocity"
-             << setw(w) << "e(Force)"
+             << setw(w) << "e(SimTK::Force)"
              << setw(w) << "e(Mech power)"
              << setw(w) << "e(Total rate)" << endl;
         for (int i=0; i<4*w; ++i) {cout << "=";} cout << endl;
@@ -553,7 +552,7 @@ void compareUmbergerProbeToPublishedResults()
         cout << "\n\nAbsolute errors for rectus femoris shortening test" << endl;
         for (int i=0; i<4*w; ++i) {cout << "=";} cout << endl;
         cout << setw(w) << "Velocity"
-             << setw(w) << "e(Force)"
+             << setw(w) << "e(SimTK::Force)"
              << setw(w) << "e(Mech power)"
              << setw(w) << "e(Total rate)" << endl;
         for (int i=0; i<4*w; ++i) {cout << "=";} cout << endl;
@@ -659,14 +658,14 @@ void testProbesUsingMillardMuscleSimulation()
     // Create block.
     const double blockMass       = 1.0;
     const double blockSideLength = 0.1;
-    Inertia blockInertia = blockMass * Inertia::brick(Vec3(blockSideLength/2));
-    OpenSim::Body *block = new OpenSim::Body("block", blockMass, Vec3(0),
+    SimTK::Inertia blockInertia = blockMass * SimTK::Inertia::brick(SimTK::Vec3(blockSideLength/2));
+    OpenSim::Body *block = new OpenSim::Body("block", blockMass, SimTK::Vec3(0),
                                              blockInertia);
     block->attachGeometry(new Mesh("block.vtp"));
 
     // Create slider joint between ground and block.
-    SliderJoint* prismatic = new SliderJoint("prismatic", ground, Vec3(0), Vec3(0),
-                                                *block, Vec3(0), Vec3(0));
+    SliderJoint* prismatic = new SliderJoint("prismatic", ground, SimTK::Vec3(0), SimTK::Vec3(0),
+                                                *block, SimTK::Vec3(0), SimTK::Vec3(0));
     auto& prisCoord = prismatic->updCoordinate();
     prisCoord.setName("xTranslation");
     prisCoord.setRangeMin(-1);
@@ -694,15 +693,15 @@ void testProbesUsingMillardMuscleSimulation()
 
     Millard2012EquilibriumMuscle *muscle1 = new Millard2012EquilibriumMuscle(
         "muscle1", 100, optimalFiberLength, tendonSlackLength, 0);
-    muscle1->addNewPathPoint("m1_ground", ground, Vec3(-anchorDistance,0,0));
-    muscle1->addNewPathPoint("m1_block",  *block, Vec3(-blockSideLength/2,0,0));
+    muscle1->addNewPathPoint("m1_ground", ground, SimTK::Vec3(-anchorDistance,0,0));
+    muscle1->addNewPathPoint("m1_block",  *block, SimTK::Vec3(-blockSideLength/2,0,0));
     muscle1->setDefaultActivation(desiredActivation);
     model.addForce(muscle1);
 
     Millard2012EquilibriumMuscle *muscle2 = new Millard2012EquilibriumMuscle(
         "muscle2", 100, optimalFiberLength, tendonSlackLength, 0);
-    muscle2->addNewPathPoint("m2_ground", ground, Vec3(anchorDistance,0,0));
-    muscle2->addNewPathPoint("m2_block",  *block, Vec3(blockSideLength/2,0,0));
+    muscle2->addNewPathPoint("m2_ground", ground, SimTK::Vec3(anchorDistance,0,0));
+    muscle2->addNewPathPoint("m2_block",  *block, SimTK::Vec3(blockSideLength/2,0,0));
     muscle2->setDefaultActivation(desiredActivation);
     model.addForce(muscle2);
 
@@ -875,7 +874,7 @@ void testProbesUsingMillardMuscleSimulation()
     model.addProbe(umbergerTotal_m1);
     umbergerTotal_m1->setName("umbergerTotal_m1");
     umbergerTotal_m1->setOperation("integrate");
-    umbergerTotal_m1->setInitialConditions(Vector(Vec1(0)));
+    umbergerTotal_m1->setInitialConditions(SimTK::Vector(SimTK::Vec1(0)));
     umbergerTotal_m1->addMuscle(muscle1->getName(), 0.5);
     cout << setw(w) << ++probeCounter << ") Added Umberger2010 probe: "
          << "total energy liberation (muscle 1)" << endl;
@@ -885,7 +884,7 @@ void testProbesUsingMillardMuscleSimulation()
     model.addProbe(umbergerTotal_m2);
     umbergerTotal_m2->setName("umbergerTotal_m2");
     umbergerTotal_m2->setOperation("integrate");
-    umbergerTotal_m2->setInitialConditions(Vector(Vec1(0)));
+    umbergerTotal_m2->setInitialConditions(SimTK::Vector(SimTK::Vec1(0)));
     umbergerTotal_m2->addMuscle(muscle2->getName(), 0.5);
     cout << setw(w) << ++probeCounter << ") Added Umberger2010 probe: "
          << "total energy liberation (muscle 2)" << endl;
@@ -895,7 +894,7 @@ void testProbesUsingMillardMuscleSimulation()
     model.addProbe(umbergerTotal_both);
     umbergerTotal_both->setName("umbergerTotal_both");
     umbergerTotal_both->setOperation("integrate");
-    umbergerTotal_both->setInitialConditions(Vector(Vec1(0)));
+    umbergerTotal_both->setInitialConditions(SimTK::Vector(SimTK::Vec1(0)));
     umbergerTotal_both->addMuscle(muscle1->getName(), 0.5);
     umbergerTotal_both->addMuscle(muscle2->getName(), 0.5);
     cout << setw(w) << ++probeCounter << ") Added Umberger2010 probe: "
@@ -907,7 +906,7 @@ void testProbesUsingMillardMuscleSimulation()
     umbergerTotalAllPieces_both->setName("umbergerTotalAllPieces_both");
     umbergerTotalAllPieces_both->setOperation("integrate");
     umbergerTotalAllPieces_both->set_report_total_metabolics_only(false);
-    umbergerTotalAllPieces_both->setInitialConditions(Vector(Vec4(0)));
+    umbergerTotalAllPieces_both->setInitialConditions(SimTK::Vector(SimTK::Vec4(0)));
     umbergerTotalAllPieces_both->addMuscle(muscle1->getName(), 0.5);
     umbergerTotalAllPieces_both->addMuscle(muscle2->getName(), 0.5);
     cout << setw(w) << ++probeCounter << ") Added Umberger2010 probe: "
@@ -980,7 +979,7 @@ void testProbesUsingMillardMuscleSimulation()
     model.addProbe(bhargavaTotal_m1);
     bhargavaTotal_m1->setName("bhargavaTotal_m1");
     bhargavaTotal_m1->setOperation("integrate");
-    bhargavaTotal_m1->setInitialConditions(Vector(Vec1(0)));
+    bhargavaTotal_m1->setInitialConditions(SimTK::Vector(SimTK::Vec1(0)));
     bhargavaTotal_m1->addMuscle(muscle1->getName(), 0.5, 40, 133, 74, 111);
     cout << setw(w) << ++probeCounter << ") Added Bhargava2004 probe: "
          << "total energy liberation (muscle 1)" << endl;
@@ -990,7 +989,7 @@ void testProbesUsingMillardMuscleSimulation()
     model.addProbe(bhargavaTotal_m2);
     bhargavaTotal_m2->setName("bhargavaTotal_m2");
     bhargavaTotal_m2->setOperation("integrate");
-    bhargavaTotal_m2->setInitialConditions(Vector(Vec1(0)));
+    bhargavaTotal_m2->setInitialConditions(SimTK::Vector(SimTK::Vec1(0)));
     bhargavaTotal_m2->addMuscle(muscle2->getName(), 0.5, 40, 133, 74, 111);
     cout << setw(w) << ++probeCounter << ") Added Bhargava2004 probe: "
          << "total energy liberation (muscle 2)" << endl;
@@ -1000,7 +999,7 @@ void testProbesUsingMillardMuscleSimulation()
     model.addProbe(bhargavaTotal_both);
     bhargavaTotal_both->setName("bhargavaTotal_both");
     bhargavaTotal_both->setOperation("integrate");
-    bhargavaTotal_both->setInitialConditions(Vector(Vec1(0)));
+    bhargavaTotal_both->setInitialConditions(SimTK::Vector(SimTK::Vec1(0)));
     bhargavaTotal_both->addMuscle(muscle1->getName(), 0.5, 40, 133, 74, 111);
     bhargavaTotal_both->addMuscle(muscle2->getName(), 0.5, 40, 133, 74, 111);
     cout << setw(w) << ++probeCounter << ") Added Bhargava2004 probe: "
@@ -1012,7 +1011,7 @@ void testProbesUsingMillardMuscleSimulation()
     bhargavaTotalAllPieces_both->setName("bhargavaTotalAllPieces_both");
     bhargavaTotalAllPieces_both->setOperation("integrate");
     bhargavaTotalAllPieces_both->set_report_total_metabolics_only(false);
-    bhargavaTotalAllPieces_both->setInitialConditions(Vector(Vec4(0)));
+    bhargavaTotalAllPieces_both->setInitialConditions(SimTK::Vector(SimTK::Vec4(0)));
     bhargavaTotalAllPieces_both->addMuscle(muscle1->getName(),0.5,40,133,74,111);
     bhargavaTotalAllPieces_both->addMuscle(muscle2->getName(),0.5,40,133,74,111);
     cout << setw(w) << ++probeCounter << ") Added Bhargava2004 probe: "
@@ -1406,4 +1405,4 @@ int main()
 
     cout << "testMuscleMetabolicsProbes passed\n" << endl;
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/Test/testNestedModelComponents.cpp b/OpenSim/Simulation/Test/testNestedModelComponents.cpp
index 86d6a02d1..03edb326c 100644
--- a/OpenSim/Simulation/Test/testNestedModelComponents.cpp
+++ b/OpenSim/Simulation/Test/testNestedModelComponents.cpp
@@ -24,7 +24,7 @@
 /*=============================================================================
 
 The purpose of these tests is to verify that ModelComponents can be nested in
-another ModelComponent and still compose a valid Model and resulting System.
+another ModelComponent and still compose a valid Model and resulting SimTK::System.
 
 Tests Include:
     1. Pendulum Model with nested Device derived from ModelComponent: In this
@@ -34,7 +34,7 @@ Tests Include:
     2. Pendulum Model with a Device that is a Model: In this case, 
        ModelComponents are part of a device Model and that Model is nested in
        a bigger (the top-level) Model. As in 1., the ModelComponents inside
-       the nested Model should be handled appropriately to form a valid System.
+       the nested Model should be handled appropriately to form a valid SimTK::System.
 
 //=============================================================================*/
 #include <OpenSim/Simulation/Model/Model.h>
@@ -56,8 +56,7 @@ class Device : public ModelComponent {
 template<class C>
 void testPendulumModelWithNestedJoints()
 {
-    using namespace SimTK;
-    Vec3 tolerance(SimTK::Eps);
+    SimTK::Vec3 tolerance(SimTK::Eps);
 
     cout << "Running testPendulumModelWithNestedJoints<" << 
         typeid(C).name() << ">" << endl;
@@ -71,8 +70,8 @@ void testPendulumModelWithNestedJoints()
 
     // Build the device
     // Create bodies 
-    auto* cuffA = new OpenSim::Body("cuffA", 1.0, Vec3(0), Inertia(0.5));
-    auto* cuffB = new OpenSim::Body("cuffB", 1.0, Vec3(0), Inertia(0.5));
+    auto* cuffA = new OpenSim::Body("cuffA", 1.0, SimTK::Vec3(0), SimTK::Inertia(0.5));
+    auto* cuffB = new OpenSim::Body("cuffB", 1.0, SimTK::Vec3(0), SimTK::Inertia(0.5));
 
     // add Bodies to the device
     device->addComponent(cuffA);
@@ -100,7 +99,7 @@ void testPendulumModelWithNestedJoints()
     anchorA->connectSocket_parent_frame(rod1);
     anchorB->connectSocket_parent_frame(rod2);
 
-    State& s = pendulum->initSystem();
+    SimTK::State& s = pendulum->initSystem();
 }
 
 int main()
@@ -126,4 +125,4 @@ int main()
     cout << "Done. All cases passed." << endl;
 
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/Test/testPoints.cpp b/OpenSim/Simulation/Test/testPoints.cpp
index d54019e87..541d4ade7 100644
--- a/OpenSim/Simulation/Test/testPoints.cpp
+++ b/OpenSim/Simulation/Test/testPoints.cpp
@@ -140,7 +140,7 @@ void testStationOnOffsetFrame()
     Model pendulum;
     pendulum.setName("pendulum3D");
 
-    auto rod1 = new Body("rod1", 0.54321, SimTK::Vec3(0.1, 0.5, 0.2),
+    auto rod1 = new OpenSim::Body("rod1", 0.54321, SimTK::Vec3(0.1, 0.5, 0.2),
         SimTK::Inertia::cylinderAlongY(0.025, 0.55));
     rod1->attachGeometry(new Cylinder(0.025, 0.55));
 
diff --git a/OpenSim/Simulation/Test/testPrescribedForce.cpp b/OpenSim/Simulation/Test/testPrescribedForce.cpp
index ee8e4aca8..c4b9cd3e3 100644
--- a/OpenSim/Simulation/Test/testPrescribedForce.cpp
+++ b/OpenSim/Simulation/Test/testPrescribedForce.cpp
@@ -26,8 +26,8 @@
 //  as a force and torque on the body, with the point force application also a function
 //  Tests Include:
 //      1. No force
-//      2. Force on the body
-//      3. Force at a point
+//      2. SimTK::Force on the body
+//      3. SimTK::Force at a point
 //      4. Torque on a body
 //      4. Forces from a file.
 //     Add tests here
@@ -114,8 +114,6 @@ void testPrescribedForce(OpenSim::Function* forceX, OpenSim::Function* forceY, O
                  OpenSim::Function* torqueX, OpenSim::Function* torqueY, OpenSim::Function* torqueZ,
                  vector<SimTK::Real>& times, vector<SimTK::Vec3>& accelerations, vector<SimTK::Vec3>& angularAccelerations)
 {
-    using namespace SimTK;
-
     //==========================================================================================================
     // Setup OpenSim model
     Model *osimModel = new Model;
@@ -125,7 +123,7 @@ void testPrescribedForce(OpenSim::Function* forceX, OpenSim::Function* forceY, O
     ball.setName("ball");
     ball.setMass(0);
     // Add joints
-    FreeJoint free("free", ground, Vec3(0), Vec3(0), ball, Vec3(0), Vec3(0));
+    FreeJoint free("free", ground, SimTK::Vec3(0), SimTK::Vec3(0), ball, SimTK::Vec3(0), SimTK::Vec3(0));
 
     // Rename coordinates for a free joint
     for(int i=0; i<free.numCoordinates(); i++){
@@ -165,7 +163,7 @@ void testPrescribedForce(OpenSim::Function* forceX, OpenSim::Function* forceY, O
     // Check that serialization/deserialization is working correctly as well
     osimModel = new Model("TestPrescribedForceModel.osim");
     SimTK::State& osim_state = osimModel->initSystem();
-    osimModel->getMultibodySystem().realize(osim_state, Stage::Position );
+    osimModel->getMultibodySystem().realize(osim_state, SimTK::Stage::Position );
 
     //==========================================================================================================
     // Compute the force and torque at the specified times.
@@ -174,9 +172,9 @@ void testPrescribedForce(OpenSim::Function* forceX, OpenSim::Function* forceY, O
     for (unsigned int i = 0; i < times.size(); ++i)
     {
         osim_state.updTime() = times[i];
-        osimModel->getMultibodySystem().realize(osim_state, Stage::Acceleration);
-        Vec3 accel = body.findStationAccelerationInGround(osim_state, Vec3(0));
-        Vec3 angularAccel = body.getAccelerationInGround(osim_state)[0];
+        osimModel->getMultibodySystem().realize(osim_state, SimTK::Stage::Acceleration);
+        SimTK::Vec3 accel = body.findStationAccelerationInGround(osim_state, SimTK::Vec3(0));
+        SimTK::Vec3 angularAccel = body.getAccelerationInGround(osim_state)[0];
 
         ASSERT_EQUAL(accelerations[i], accel, integ_accuracy);
         ASSERT_EQUAL(angularAccelerations[i], angularAccel, integ_accuracy);
@@ -185,39 +183,35 @@ void testPrescribedForce(OpenSim::Function* forceX, OpenSim::Function* forceY, O
 
 void testNoForce()
 {
-    using namespace SimTK;
-
-    vector<Real> times;
-    vector<Vec3> accel;
-    vector<Vec3> angularAccel;
+    vector<SimTK::Real> times;
+    vector<SimTK::Vec3> accel;
+    vector<SimTK::Vec3> angularAccel;
     times.push_back(0.0);
     accel.push_back(gravity_vec);
-    angularAccel.push_back(Vec3(0));
+    angularAccel.push_back(SimTK::Vec3(0));
     times.push_back(0.5);
     accel.push_back(gravity_vec);
-    angularAccel.push_back(Vec3(0));
+    angularAccel.push_back(SimTK::Vec3(0));
     times.push_back(1.0);
     accel.push_back(gravity_vec);
-    angularAccel.push_back(Vec3(0));
+    angularAccel.push_back(SimTK::Vec3(0));
     testPrescribedForce(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, times, accel, angularAccel);
 }
 
 void testForceAtOrigin()
 {
-    using namespace SimTK;
-
-    vector<Real> times;
-    vector<Vec3> accel;
-    vector<Vec3> angularAccel;
+    vector<SimTK::Real> times;
+    vector<SimTK::Vec3> accel;
+    vector<SimTK::Vec3> angularAccel;
     times.push_back(0.0);
-    accel.push_back(gravity_vec+Vec3(1.0/ballMass.getMass(), 0, 0));
-    angularAccel.push_back(Vec3(0));
+    accel.push_back(gravity_vec+SimTK::Vec3(1.0/ballMass.getMass(), 0, 0));
+    angularAccel.push_back(SimTK::Vec3(0));
     times.push_back(0.5);
-    accel.push_back(gravity_vec+Vec3(0.5/ballMass.getMass(), 0.5/ballMass.getMass(), 0));
-    angularAccel.push_back(Vec3(0));
+    accel.push_back(gravity_vec+SimTK::Vec3(0.5/ballMass.getMass(), 0.5/ballMass.getMass(), 0));
+    angularAccel.push_back(SimTK::Vec3(0));
     times.push_back(1.0);
-    accel.push_back(gravity_vec+Vec3(0, 1/ballMass.getMass(), 0));
-    angularAccel.push_back(Vec3(0));
+    accel.push_back(gravity_vec+SimTK::Vec3(0, 1/ballMass.getMass(), 0));
+    angularAccel.push_back(SimTK::Vec3(0));
     PiecewiseLinearFunction *forceX = new PiecewiseLinearFunction(), *forceY = new PiecewiseLinearFunction(), *forceZ = new PiecewiseLinearFunction();
     forceX->addPoint(0, 1);
     forceX->addPoint(1, 0);
@@ -229,15 +223,13 @@ void testForceAtOrigin()
 
 void testForceAtPoint()
 {
-    using namespace SimTK;
-
-    Mat33 invInertia = ballMass.getInertia().toMat33().invert();
-    vector<Real> times;
-    vector<Vec3> accel;
-    vector<Vec3> angularAccel;
+    SimTK::Mat33 invInertia = ballMass.getInertia().toMat33().invert();
+    vector<SimTK::Real> times;
+    vector<SimTK::Vec3> accel;
+    vector<SimTK::Vec3> angularAccel;
     times.push_back(0.0);
-    accel.push_back(gravity_vec+Vec3(1.0/ballMass.getMass(), 0, 0));
-    angularAccel.push_back(invInertia*(Vec3(1, -1, 0)%Vec3(1.0, 0, 0)));
+    accel.push_back(gravity_vec+SimTK::Vec3(1.0/ballMass.getMass(), 0, 0));
+    angularAccel.push_back(invInertia*(SimTK::Vec3(1, -1, 0)%SimTK::Vec3(1.0, 0, 0)));
     PiecewiseLinearFunction *forceX = new PiecewiseLinearFunction(), *forceY = new PiecewiseLinearFunction(), *forceZ = new PiecewiseLinearFunction();
     forceX->addPoint(0, 1);
     forceY->addPoint(0, 0);
@@ -251,18 +243,16 @@ void testForceAtPoint()
 
 void testTorque()
 {
-    using namespace SimTK;
-
-    Mat33 invInertia = ballMass.getInertia().toMat33().invert();
-    vector<Real> times;
-    vector<Vec3> accel;
-    vector<Vec3> angularAccel;
+    SimTK::Mat33 invInertia = ballMass.getInertia().toMat33().invert();
+    vector<SimTK::Real> times;
+    vector<SimTK::Vec3> accel;
+    vector<SimTK::Vec3> angularAccel;
     times.push_back(0.0);
     accel.push_back(gravity_vec);
-    angularAccel.push_back(invInertia*Vec3(1, 0.5, 0));
+    angularAccel.push_back(invInertia*SimTK::Vec3(1, 0.5, 0));
     PiecewiseLinearFunction *torqueX = new PiecewiseLinearFunction(), *torqueY = new PiecewiseLinearFunction(), *torqueZ = new PiecewiseLinearFunction();
     torqueX->addPoint(0, 1);
     torqueY->addPoint(0, 0.5);
     torqueZ->addPoint(0, 0);
     testPrescribedForce(NULL, NULL, NULL, NULL, NULL, NULL, torqueX, torqueY, torqueZ, times, accel, angularAccel);
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/Test/testReportersWithModel.cpp b/OpenSim/Simulation/Test/testReportersWithModel.cpp
index 58d778188..baa86ca05 100644
--- a/OpenSim/Simulation/Test/testReportersWithModel.cpp
+++ b/OpenSim/Simulation/Test/testReportersWithModel.cpp
@@ -30,7 +30,6 @@
 #include <OpenSim/Simulation/SimbodyEngine/SliderJoint.h>
 
 using namespace std;
-using namespace SimTK;
 using namespace OpenSim;
 
 void testConsoleReporterLabels() {
@@ -38,11 +37,11 @@ void testConsoleReporterLabels() {
     Model model;
     model.setName("world");
 
-    auto* ball = new OpenSim::Body("ball", 1., Vec3(0), Inertia(0));
+    auto* ball = new OpenSim::Body("ball", 1., SimTK::Vec3(0), SimTK::Inertia(0));
     model.addBody(ball);
 
-    auto* slider = new SliderJoint("slider", model.getGround(), Vec3(0),
-        Vec3(0,0,Pi/2.), *ball, Vec3(0), Vec3(0,0,Pi/2.));
+    auto* slider = new SliderJoint("slider", model.getGround(), SimTK::Vec3(0),
+        SimTK::Vec3(0,0,SimTK::Pi/2.), *ball, SimTK::Vec3(0), SimTK::Vec3(0,0,SimTK::Pi/2.));
     model.addJoint(slider);
 
     // Create ConsoleReporter, and connect Outputs without and with alias.
@@ -52,7 +51,7 @@ void testConsoleReporterLabels() {
     reporter->addToReport(slider->getCoordinate().getOutput("value"), "height");
     model.addComponent(reporter);
 
-    State& state = model.initSystem();
+    SimTK::State& state = model.initSystem();
     Manager manager(model);
     state.setTime(0.0);
     manager.initialize(state);
@@ -87,11 +86,11 @@ void testTableReporterLabels() {
     Model model;
     model.setName("world");
 
-    auto* ball = new OpenSim::Body("ball", 1., Vec3(0), Inertia(0));
+    auto* ball = new OpenSim::Body("ball", 1., SimTK::Vec3(0), SimTK::Inertia(0));
     model.addBody(ball);
 
-    auto* slider = new SliderJoint("slider", model.getGround(), Vec3(0),
-        Vec3(0,0,Pi/2.), *ball, Vec3(0), Vec3(0,0,Pi/2.));
+    auto* slider = new SliderJoint("slider", model.getGround(), SimTK::Vec3(0),
+        SimTK::Vec3(0,0,SimTK::Pi/2.), *ball, SimTK::Vec3(0), SimTK::Vec3(0,0,SimTK::Pi/2.));
     slider->updCoordinate().setName("sliderCoord");
     model.addJoint(slider);
 
@@ -103,7 +102,7 @@ void testTableReporterLabels() {
     model.addComponent(reporter);
 
     // Simulate.
-    State& state = model.initSystem();
+    SimTK::State& state = model.initSystem();
     Manager manager(model);
     state.setTime(0.0);
     manager.initialize(state);
@@ -121,4 +120,4 @@ int main() {
         SimTK_SUBTEST(testConsoleReporterLabels);
         SimTK_SUBTEST(testTableReporterLabels);
     SimTK_END_TEST();
-};
+};
\ No newline at end of file
diff --git a/OpenSim/Simulation/Test/testSimulationUtilities.cpp b/OpenSim/Simulation/Test/testSimulationUtilities.cpp
index 4dc7cb895..925d76c03 100644
--- a/OpenSim/Simulation/Test/testSimulationUtilities.cpp
+++ b/OpenSim/Simulation/Test/testSimulationUtilities.cpp
@@ -50,7 +50,7 @@ void testSimulate() {
     // Create a simple model consisting of an unconstrained ball.
     Model model;
     model.setGravity(Vec3(0, -gravity, 0));
-    auto ball = new Body("ball", 1., Vec3(0), SimTK::Inertia::sphere(1.));
+    auto ball = new OpenSim::Body("ball", 1., Vec3(0), SimTK::Inertia::sphere(1.));
     model.addBody(ball);
     auto freeJoint = new FreeJoint("freeJoint", model.getGround(), *ball);
     model.addJoint(freeJoint);
diff --git a/OpenSim/Simulation/Test/testStatesDocument.cpp b/OpenSim/Simulation/Test/testStatesDocument.cpp
index 386048e2c..7f9a016ea 100644
--- a/OpenSim/Simulation/Test/testStatesDocument.cpp
+++ b/OpenSim/Simulation/Test/testStatesDocument.cpp
@@ -30,8 +30,6 @@
 #include <OpenSim/Simulation/Manager/Manager.h>
 #include <OpenSim/Simulation/Model/PointToPointSpring.h>
 #include <catch2/catch_all.hpp>
-
-using namespace SimTK;
 using namespace OpenSim;
 using std::cout;
 using std::endl;
@@ -49,25 +47,25 @@ const double padFactor = 1.0 + SimTK::SignificantReal;
 
 //-----------------------------------------------------------------------------
 // Create a force component derived from PointToPointSpring that adds a
-// discrete state of each supported type (bool, int, double, Vec2, Vec3,
-// Vec4, Vec5, Vec6).
+// discrete state of each supported type (bool, int, double, SimTK::Vec2, SimTK::Vec3,
+// SimTK::Vec4, SimTK::Vec5, SimTK::Vec6).
 class ExtendedPointToPointSpring : public OpenSim::PointToPointSpring
 {
     OpenSim_DECLARE_CONCRETE_OBJECT(ExtendedPointToPointSpring,
         OpenSim::PointToPointSpring);
 
 private:
-    // Subsystem index
-    SubsystemIndex indexSS;
+    // SimTK::Subsystem index
+    SimTK::SubsystemIndex indexSS;
     // Indexes of discrete variables
-    DiscreteVariableIndex indexBool;
-    DiscreteVariableIndex indexInt;
-    DiscreteVariableIndex indexDbl;
-    DiscreteVariableIndex indexVec2;
-    DiscreteVariableIndex indexVec3;
-    DiscreteVariableIndex indexVec4;
-    DiscreteVariableIndex indexVec5;
-    DiscreteVariableIndex indexVec6;
+    SimTK::DiscreteVariableIndex indexBool;
+    SimTK::DiscreteVariableIndex indexInt;
+    SimTK::DiscreteVariableIndex indexDbl;
+    SimTK::DiscreteVariableIndex indexVec2;
+    SimTK::DiscreteVariableIndex indexVec3;
+    SimTK::DiscreteVariableIndex indexVec4;
+    SimTK::DiscreteVariableIndex indexVec5;
+    SimTK::DiscreteVariableIndex indexVec6;
     // Names of discrete variables
     string nameBool{"dvBool"};
     string nameInt{"dvInt"};
@@ -85,7 +83,7 @@ public:
     // Constructor
     // @param which Specify which discrete state name (0 to 7) to append the
     // suffix to.
-    // @param suffix String to append to the discrete state name.
+    // @param suffix SimTK::String to append to the discrete state name.
     // @param omit Specify the discrete state to omit.
     ExtendedPointToPointSpring(const PhysicalFrame& body1, SimTK::Vec3 point1,
         const PhysicalFrame& body2, SimTK::Vec3 point2,
@@ -131,14 +129,14 @@ public:
         // For exception testing purposes, the member variable 'omit' is used
         // to omit one state.
         bool allocate = false;
-        if(omit!=0) addDiscreteVariable(nameBool, Stage::Position, allocate);
-        if(omit!=1) addDiscreteVariable(nameInt, Stage::Position, allocate);
-        if(omit!=2) addDiscreteVariable(nameDbl, Stage::Position, allocate);
-        if(omit!=3) addDiscreteVariable(nameVec2, Stage::Position, allocate);
-        if(omit!=4) addDiscreteVariable(nameVec3, Stage::Position, allocate);
-        if(omit!=5) addDiscreteVariable(nameVec4, Stage::Position, allocate);
-        if(omit!=6) addDiscreteVariable(nameVec5, Stage::Position, allocate);
-        if(omit!=7) addDiscreteVariable(nameVec6, Stage::Position, allocate);
+        if(omit!=0) addDiscreteVariable(nameBool, SimTK::Stage::Position, allocate);
+        if(omit!=1) addDiscreteVariable(nameInt, SimTK::Stage::Position, allocate);
+        if(omit!=2) addDiscreteVariable(nameDbl, SimTK::Stage::Position, allocate);
+        if(omit!=3) addDiscreteVariable(nameVec2, SimTK::Stage::Position, allocate);
+        if(omit!=4) addDiscreteVariable(nameVec3, SimTK::Stage::Position, allocate);
+        if(omit!=5) addDiscreteVariable(nameVec4, SimTK::Stage::Position, allocate);
+        if(omit!=6) addDiscreteVariable(nameVec5, SimTK::Stage::Position, allocate);
+        if(omit!=7) addDiscreteVariable(nameVec6, SimTK::Stage::Position, allocate);
     }
 
     void
@@ -150,8 +148,8 @@ public:
         ExtendedPointToPointSpring* mutableThis =
             const_cast<ExtendedPointToPointSpring*>(this);
 
-        // Get the Subsystem
-        const DefaultSystemSubsystem& fsub = getModel().getDefaultSubsystem();
+        // Get the SimTK::Subsystem
+        const SimTK::DefaultSystemSubsystem& fsub = getModel().getDefaultSubsystem();
         mutableThis->indexSS = fsub.getMySubsystemIndex();
 
         // 0 Bool
@@ -159,7 +157,7 @@ public:
             bool dvBool{false};
             mutableThis->indexBool =
                 s.allocateAutoUpdateDiscreteVariable(indexSS,
-                Stage::Velocity, new Value<bool>(dvBool), Stage::Dynamics);
+                SimTK::Stage::Velocity, new SimTK::Value<bool>(dvBool), SimTK::Stage::Dynamics);
             initializeDiscreteVariableIndexes(nameBool, indexSS, indexBool);
         }
 
@@ -168,7 +166,7 @@ public:
             int dvInt{0};
             mutableThis->indexInt =
                 s.allocateAutoUpdateDiscreteVariable(indexSS,
-                    Stage::Velocity, new Value<int>(dvInt), Stage::Dynamics);
+                    SimTK::Stage::Velocity, new SimTK::Value<int>(dvInt), SimTK::Stage::Dynamics);
             initializeDiscreteVariableIndexes(nameInt, indexSS, indexInt);
         }
 
@@ -177,52 +175,52 @@ public:
             double dvDbl{0.0};
             mutableThis->indexDbl =
                 s.allocateAutoUpdateDiscreteVariable(indexSS,
-                Stage::Velocity, new Value<double>(dvDbl), Stage::Dynamics);
+                SimTK::Stage::Velocity, new SimTK::Value<double>(dvDbl), SimTK::Stage::Dynamics);
             initializeDiscreteVariableIndexes(nameDbl, indexSS, indexDbl);
         }
 
-        // 3 Vec2
+        // 3 SimTK::Vec2
         if(omit != 3) {
-            Vec2 dvVec2(0.1, 0.2);
+            SimTK::Vec2 dvVec2(0.1, 0.2);
             mutableThis->indexVec2 =
                 s.allocateAutoUpdateDiscreteVariable(indexSS,
-                Stage::Velocity, new Value<Vec2>(dvVec2), Stage::Dynamics);
+                SimTK::Stage::Velocity, new SimTK::Value<SimTK::Vec2>(dvVec2), SimTK::Stage::Dynamics);
             initializeDiscreteVariableIndexes(nameVec2, indexSS, indexVec2);
         }
 
-        // 4 Vec3
+        // 4 SimTK::Vec3
         if(omit != 4) {
-            Vec3 dvVec3(0.1, 0.2, 0.3);
+            SimTK::Vec3 dvVec3(0.1, 0.2, 0.3);
             mutableThis->indexVec3 =
                 s.allocateAutoUpdateDiscreteVariable(indexSS,
-                Stage::Velocity, new Value<Vec3>(dvVec3), Stage::Dynamics);
+                SimTK::Stage::Velocity, new SimTK::Value<SimTK::Vec3>(dvVec3), SimTK::Stage::Dynamics);
             initializeDiscreteVariableIndexes(nameVec3, indexSS, indexVec3);
         }
 
-        // 5 Vec4
+        // 5 SimTK::Vec4
         if(omit != 5) {
-            Vec4 dvVec4(0.1, 0.2, 0.3, 0.4);
+            SimTK::Vec4 dvVec4(0.1, 0.2, 0.3, 0.4);
             mutableThis->indexVec4 =
                 s.allocateAutoUpdateDiscreteVariable(indexSS,
-                Stage::Velocity, new Value<Vec4>(dvVec4), Stage::Dynamics);
+                SimTK::Stage::Velocity, new SimTK::Value<SimTK::Vec4>(dvVec4), SimTK::Stage::Dynamics);
             initializeDiscreteVariableIndexes(nameVec4, indexSS, indexVec4);
         }
 
-        // 6 Vec5
+        // 6 SimTK::Vec5
         if(omit != 6) {
-            Vec5 dvVec5(0.1, 0.2, 0.3, 0.4, 0.5);
+            SimTK::Vec5 dvVec5(0.1, 0.2, 0.3, 0.4, 0.5);
             mutableThis->indexVec5 =
                 s.allocateAutoUpdateDiscreteVariable(indexSS,
-                Stage::Velocity, new Value<Vec5>(dvVec5), Stage::Dynamics);
+                SimTK::Stage::Velocity, new SimTK::Value<SimTK::Vec5>(dvVec5), SimTK::Stage::Dynamics);
             initializeDiscreteVariableIndexes(nameVec5, indexSS, indexVec5);
         }
 
-        // 7 Vec6
+        // 7 SimTK::Vec6
         if(omit != 7) {
-            Vec6 dvVec6(0.1, 0.2, 0.3, 0.4, 0.5, 0.6);
+            SimTK::Vec6 dvVec6(0.1, 0.2, 0.3, 0.4, 0.5, 0.6);
             mutableThis->indexVec6 =
                 s.allocateAutoUpdateDiscreteVariable(indexSS,
-                Stage::Velocity, new Value<Vec6>(dvVec6), Stage::Dynamics);
+                SimTK::Stage::Velocity, new SimTK::Value<SimTK::Vec6>(dvVec6), SimTK::Stage::Dynamics);
             initializeDiscreteVariableIndexes(nameVec6, indexSS, indexVec6);
         }
     }
@@ -262,18 +260,18 @@ public:
             state.markDiscreteVarUpdateValueRealized(indexSS, indexDbl);
         }
 
-        // 3 Vec2
+        // 3 SimTK::Vec2
         if (omit != 3) {
-            Vec2& v2 = SimTK::Value<Vec2>::downcast(
+            SimTK::Vec2& v2 = SimTK::Value<SimTK::Vec2>::downcast(
                 state.updDiscreteVarUpdateValue(indexSS, indexVec2));
             v2[0] = u[0];
             v2[1] = u[1];
             state.markDiscreteVarUpdateValueRealized(indexSS, indexVec2);
         }
 
-        // 4 Vec3
+        // 4 SimTK::Vec3
         if (omit != 4) {
-            Vec3& v3 = SimTK::Value<Vec3>::downcast(
+            SimTK::Vec3& v3 = SimTK::Value<SimTK::Vec3>::downcast(
                 state.updDiscreteVarUpdateValue(indexSS, indexVec3));
             v3[0] = u[0];
             v3[1] = u[1];
@@ -281,9 +279,9 @@ public:
             state.markDiscreteVarUpdateValueRealized(indexSS, indexVec3);
         }
 
-        // 5 Vec4
+        // 5 SimTK::Vec4
         if (omit != 5) {
-            Vec4& v4 = SimTK::Value<Vec4>::downcast(
+            SimTK::Vec4& v4 = SimTK::Value<SimTK::Vec4>::downcast(
                 state.updDiscreteVarUpdateValue(indexSS, indexVec4));
             v4[0] = u[0];
             v4[1] = u[1];
@@ -292,9 +290,9 @@ public:
             state.markDiscreteVarUpdateValueRealized(indexSS, indexVec4);
         }
 
-        // 6 Vec5
+        // 6 SimTK::Vec5
         if (omit != 6) {
-            Vec5& v5 = SimTK::Value<Vec5>::downcast(
+            SimTK::Vec5& v5 = SimTK::Value<SimTK::Vec5>::downcast(
                 state.updDiscreteVarUpdateValue(indexSS, indexVec5));
             v5[0] = u[0];
             v5[1] = u[1];
@@ -304,9 +302,9 @@ public:
             state.markDiscreteVarUpdateValueRealized(indexSS, indexVec5);
         }
 
-        // 7 Vec6
+        // 7 SimTK::Vec6
         if (omit != 7) {
-            Vec6& v6 = SimTK::Value<Vec6>::downcast(
+            SimTK::Vec6& v6 = SimTK::Value<SimTK::Vec6>::downcast(
                 state.updDiscreteVarUpdateValue(indexSS, indexVec6));
             v6[0] = u[0];
             v6[1] = u[1];
@@ -328,7 +326,7 @@ public:
 /**
 Compute the maximum error that can result from rounding a value at a
 specified precision. This method assumes a base-10 representation of the value.
-@param value Value to be rounded.
+@param value SimTK::Value to be rounded.
 @param precision Number of significant figures that will be retained in the
 value.
 @return Maximum rounding error.
@@ -348,14 +346,14 @@ computeMaxRoundingError(double value, int precision) {
 /**
 Compute the expected error that will occur as a result of rounding a value at
 a specified precision.
-@param value Value to be rounded.
+@param value SimTK::Value to be rounded.
 @param precision Number of significant figures that will be retained in the
 value.
 @return Expected rounding error.
 */
 double
 computeRoundingError(const double& value, int precision) {
-    int p = clamp(1, precision, SimTK::LosslessNumDigitsReal);
+    int p = (int)clamp(1.0, (double)precision, SimTK::LosslessNumDigitsReal); //TODO: newer simbody?
     SimTK::String valueStr(value, precision);
     double valueDbl;
     if(!valueStr.tryConvertToDouble(valueDbl))
@@ -367,15 +365,15 @@ computeRoundingError(const double& value, int precision) {
 // Test for equality of the continuous variables in two state trajectories.
 void
 testEqualityForContinuousVariables(const Model& model,
-    const Array_<State>& trajA, const Array_<State>& trajB, int precision)
+    const SimTK::Array_<SimTK::State>& trajA, const SimTK::Array_<SimTK::State>& trajB, int precision)
 {
     // Continuous variables are gathered efficiently without using any
     // OpenSim::Component methods by using state.getQ(), state.getU(), and
     // state.getZ().
     double tol;
     double tA, tB;
-    const State* stateA = trajA.cbegin();
-    const State* stateB = trajB.cbegin();
+    const SimTK::State* stateA = trajA.cbegin();
+    const SimTK::State* stateB = trajB.cbegin();
 
     // Loop over time
     for(int iTime=0; stateA!=trajA.cend(); ++iTime, ++stateA, ++stateB) {
@@ -398,24 +396,24 @@ testEqualityForContinuousVariables(const Model& model,
 
         // Q
         double diff;
-        const Vector& qA = stateA->getQ();
-        const Vector& qB = stateB->getQ();
+        const SimTK::Vector& qA = stateA->getQ();
+        const SimTK::Vector& qB = stateB->getQ();
         int nq = qA.size();
         for (int i = 0; i < nq; ++i) {
             tol = padFactor * computeRoundingError(qA[i], precision);
             CHECK_THAT(qB[i], Catch::Matchers::WithinAbs(qA[i], tol));
         }
         // U
-        const Vector& uA = stateA->getU();
-        const Vector& uB = stateB->getU();
+        const SimTK::Vector& uA = stateA->getU();
+        const SimTK::Vector& uB = stateB->getU();
         int nu = uA.size();
         for (int i = 0; i < nu; ++i) {
             tol = padFactor * computeRoundingError(uA[i], precision);
             CHECK_THAT(uB[i], Catch::Matchers::WithinAbs(uA[i], tol));
         }
         // Z
-        const Vector& zA = stateA->getZ();
-        const Vector& zB = stateB->getZ();
+        const SimTK::Vector& zA = stateA->getZ();
+        const SimTK::Vector& zB = stateB->getZ();
         int nz = zA.size();
         for (int i = 0; i < nz; ++i) {
             tol = padFactor * computeRoundingError(zA[i], precision);
@@ -428,10 +426,10 @@ testEqualityForContinuousVariables(const Model& model,
 // Test for equality of a scalar variable in two state trajectories.
 template <class T>
 void
-checkScalar(const Array_<T>& a, const Array_<T>& b, int precision)
+checkScalar(const SimTK::Array_<T>& a, const SimTK::Array_<T>& b, int precision)
 {
     double tol;
-    Array_<T> dvA, dvB;
+    SimTK::Array_<T> dvA, dvB;
     for (size_t i = 0; i < (size_t)dvA.size(); ++i) {
         tol = padFactor*computeRoundingError(a[i], precision);
         CHECK_THAT(b[i], Catch::Matchers::WithinAbs(a[i], tol));
@@ -439,10 +437,10 @@ checkScalar(const Array_<T>& a, const Array_<T>& b, int precision)
 }
 
 //_____________________________________________________________________________
-// Test for equality of a Vector variable in two state trajectories.
+// Test for equality of a SimTK::Vector variable in two state trajectories.
 template <class T>
 void
-checkVector(const Array_<T>& a, const Array_<T>& b, int precision)
+checkVector(const SimTK::Array_<T>& a, const SimTK::Array_<T>& b, int precision)
 {
     double tol;
     for (size_t i = 0; i < (size_t)a.size(); ++i) {
@@ -465,7 +463,7 @@ checkVector(const Array_<T>& a, const Array_<T>& b, int precision)
 // compared in this unit test.
 void
 testEqualityForDiscreteVariables(const Model& model,
-    const Array_<State>& trajA, const Array_<State>& trajB, int precision)
+    const SimTK::Array_<SimTK::State>& trajA, const SimTK::Array_<SimTK::State>& trajB, int precision)
 {
     // Loop over the named variables
     OpenSim::Array<std::string> paths = model.getDiscreteVariableNames();
@@ -478,63 +476,63 @@ testEqualityForDiscreteVariables(const Model& model,
 
         // Get the trajectory for the discrete variable
         if (SimTK::Value<bool>::isA(abstractVal)) {
-            Array_<bool> dvA, dvB;
+            SimTK::Array_<bool> dvA, dvB;
             model.getDiscreteVariableTrajectory<bool>(paths[i], trajA, dvA);
             model.getDiscreteVariableTrajectory<bool>(paths[i], trajB, dvB);
             for (size_t j = 0; j < (size_t)dvA.size(); ++j)
                 CHECK(dvB[j] == dvA[j]);
         }
         else if (SimTK::Value<int>::isA(abstractVal)) {
-            Array_<int> dvA, dvB;
+            SimTK::Array_<int> dvA, dvB;
             model.getDiscreteVariableTrajectory<int>(paths[i], trajA, dvA);
             model.getDiscreteVariableTrajectory<int>(paths[i], trajB, dvB);
             for (size_t j = 0; j < (size_t)dvA.size(); ++j)
                 CHECK(dvB[j] == dvA[j]);
         }
         else if (SimTK::Value<float>::isA(abstractVal)) {
-            Array_<float> dvA, dvB;
+            SimTK::Array_<float> dvA, dvB;
             model.getDiscreteVariableTrajectory<float>(paths[i], trajA, dvA);
             model.getDiscreteVariableTrajectory<float>(paths[i], trajB, dvB);
             checkScalar<float>(dvA, dvB, precision);
         }
         else if (SimTK::Value<double>::isA(abstractVal)) {
-            Array_<double> dvA, dvB;
+            SimTK::Array_<double> dvA, dvB;
             model.getDiscreteVariableTrajectory<double>(paths[i], trajA, dvA);
             model.getDiscreteVariableTrajectory<double>(paths[i], trajB, dvB);
             checkScalar<double>(dvA, dvB, precision);
         }
-        else if (SimTK::Value<Vec2>::isA(abstractVal)) {
-            Array_<Vec2> dvA, dvB;
-            model.getDiscreteVariableTrajectory<Vec2>(paths[i], trajA, dvA);
-            model.getDiscreteVariableTrajectory<Vec2>(paths[i], trajB, dvB);
-            checkVector<Vec2>(dvA, dvB, precision);
-        }
-        else if (SimTK::Value<Vec3>::isA(abstractVal)) {
-            Array_<Vec3> dvA, dvB;
-            model.getDiscreteVariableTrajectory<Vec3>(paths[i], trajA, dvA);
-            model.getDiscreteVariableTrajectory<Vec3>(paths[i], trajB, dvB);
-            checkVector<Vec3>(dvA, dvB, precision);
-        }
-        else if (SimTK::Value<Vec4>::isA(abstractVal)) {
-            Array_<Vec4> dvA, dvB;
-            model.getDiscreteVariableTrajectory<Vec4>(paths[i], trajA, dvA);
-            model.getDiscreteVariableTrajectory<Vec4>(paths[i], trajB, dvB);
-            checkVector<Vec4>(dvA, dvB, precision);
-        }
-        else if (SimTK::Value<Vec5>::isA(abstractVal)) {
-            Array_<Vec5> dvA, dvB;
-            model.getDiscreteVariableTrajectory<Vec5>(paths[i], trajA, dvA);
-            model.getDiscreteVariableTrajectory<Vec5>(paths[i], trajB, dvB);
-            checkVector<Vec5>(dvA, dvB, precision);
-        }
-        else if (SimTK::Value<Vec6>::isA(abstractVal)) {
-            Array_<Vec6> dvA, dvB;
-            model.getDiscreteVariableTrajectory<Vec6>(paths[i], trajA, dvA);
-            model.getDiscreteVariableTrajectory<Vec6>(paths[i], trajB, dvB);
-            checkVector<Vec6>(dvA, dvB, precision);
+        else if (SimTK::Value<SimTK::Vec2>::isA(abstractVal)) {
+            SimTK::Array_<SimTK::Vec2> dvA, dvB;
+            model.getDiscreteVariableTrajectory<SimTK::Vec2>(paths[i], trajA, dvA);
+            model.getDiscreteVariableTrajectory<SimTK::Vec2>(paths[i], trajB, dvB);
+            checkVector<SimTK::Vec2>(dvA, dvB, precision);
+        }
+        else if (SimTK::Value<SimTK::Vec3>::isA(abstractVal)) {
+            SimTK::Array_<SimTK::Vec3> dvA, dvB;
+            model.getDiscreteVariableTrajectory<SimTK::Vec3>(paths[i], trajA, dvA);
+            model.getDiscreteVariableTrajectory<SimTK::Vec3>(paths[i], trajB, dvB);
+            checkVector<SimTK::Vec3>(dvA, dvB, precision);
+        }
+        else if (SimTK::Value<SimTK::Vec4>::isA(abstractVal)) {
+            SimTK::Array_<SimTK::Vec4> dvA, dvB;
+            model.getDiscreteVariableTrajectory<SimTK::Vec4>(paths[i], trajA, dvA);
+            model.getDiscreteVariableTrajectory<SimTK::Vec4>(paths[i], trajB, dvB);
+            checkVector<SimTK::Vec4>(dvA, dvB, precision);
+        }
+        else if (SimTK::Value<SimTK::Vec5>::isA(abstractVal)) {
+            SimTK::Array_<SimTK::Vec5> dvA, dvB;
+            model.getDiscreteVariableTrajectory<SimTK::Vec5>(paths[i], trajA, dvA);
+            model.getDiscreteVariableTrajectory<SimTK::Vec5>(paths[i], trajB, dvB);
+            checkVector<SimTK::Vec5>(dvA, dvB, precision);
+        }
+        else if (SimTK::Value<SimTK::Vec6>::isA(abstractVal)) {
+            SimTK::Array_<SimTK::Vec6> dvA, dvB;
+            model.getDiscreteVariableTrajectory<SimTK::Vec6>(paths[i], trajA, dvA);
+            model.getDiscreteVariableTrajectory<SimTK::Vec6>(paths[i], trajB, dvB);
+            checkVector<SimTK::Vec6>(dvA, dvB, precision);
         }
         else {
-            String msg = "Unrecognized type: " + abstractVal.getTypeName();
+            SimTK::String msg = "Unrecognized type: " + abstractVal.getTypeName();
             SimTK_ASSERT(false, msg.c_str());
         }
     }
@@ -552,13 +550,13 @@ testEqualityForDiscreteVariables(const Model& model,
 // deserialized, or compared.
 void
 testEqualityForModelingOptions(const Model& model,
-    const Array_<State>& trajA, const Array_<State>& trajB, int precision)
+    const SimTK::Array_<SimTK::State>& trajA, const SimTK::Array_<SimTK::State>& trajB, int precision)
 {
     // Loop over the named variables
     OpenSim::Array<std::string> paths = model.getModelingOptionNames();
     int nPaths = paths.getSize();
     for (int i = 0; i < nPaths; ++i) {
-        Array_<int> moA, moB;
+        SimTK::Array_<int> moA, moB;
         model.getModelingOptionTrajectory<int>(paths[i], trajA, moA);
         model.getModelingOptionTrajectory<int>(paths[i], trajB, moB);
         for (size_t j = 0; j<(size_t)moA.size(); ++j) CHECK(moB[j] == moA[j]);
@@ -572,7 +570,7 @@ testEqualityForModelingOptions(const Model& model,
 // has not been serialized.
 void
 testStateEquality(const Model& model,
-    const Array_<State>& trajA, const Array_<State>& trajB, int precision)
+    const SimTK::Array_<SimTK::State>& trajA, const SimTK::Array_<SimTK::State>& trajB, int precision)
 {
     testEqualityForContinuousVariables(model, trajA, trajB, precision);
     testEqualityForDiscreteVariables(model, trajA, trajB, precision);
@@ -587,27 +585,27 @@ buildModel(int whichDiscreteState = -1,
 
     // Create an empty model
     Model* model = new Model();
-    Vec3 gravity(0.0, -10.0, 0.0);
+    SimTK::Vec3 gravity(0.0, -10.0, 0.0);
     model->setGravity(gravity);
     model->setName("BlockOnASpringFreeJoint");
 
     // Add bodies and joints
     OpenSim::Ground& ground = model->updGround();
 
-    // Body
+    // SimTK::Body
     std::string name = "block";
     OpenSim::Body* block = new OpenSim::Body();
     double mass = 10.0;
     block->setName(name);
     block->set_mass(mass);
-    block->set_mass_center(Vec3(0));
-    block->setInertia(Inertia(1.0));
+    block->set_mass_center(SimTK::Vec3(0));
+    block->setInertia(SimTK::Inertia(1.0));
     model->addBody(block);
 
     // Joint
     name = "free";
     FreeJoint *free = new
-        FreeJoint(name, ground, Vec3(0), Vec3(0), *block, Vec3(0), Vec3(0));
+        FreeJoint(name, ground, SimTK::Vec3(0), SimTK::Vec3(0), *block, SimTK::Vec3(0), SimTK::Vec3(0));
     model->addJoint(free);
 
     // Point-To-Point Spring
@@ -616,8 +614,8 @@ buildModel(int whichDiscreteState = -1,
     double kp = 1000.0; // Stiffness
     double kv = 100.0;  // Viscosity (under-damped)
     double restlength = 0.0;
-    Vec3 origin(0.0);
-    Vec3 insertion(0.1, 0.1, 0.025);
+    SimTK::Vec3 origin(0.0);
+    SimTK::Vec3 insertion(0.1, 0.1, 0.025);
     ExtendedPointToPointSpring* spring = new ExtendedPointToPointSpring(
         ground, origin, *block, insertion, kp, restlength,
         whichDiscreteState, discreteStateSuffix, omit);
@@ -656,9 +654,9 @@ simulate(Model* model) {
     state = manager.integrate(tf);
 
     // Return a copy of the underlying state array, after repackaging it
-    // as a SimTK::Array_<State>.
-    const vector<State>& trajectory = reporter->getVectorOfStateObjects();
-    const Array_<State> traj(trajectory);
+    // as a SimTK::Array_<SimTK::State>.
+    const vector<SimTK::State>& trajectory = reporter->getVectorOfStateObjects();
+    const SimTK::Array_<SimTK::State> traj(trajectory);
     return traj;
 }
 
@@ -673,7 +671,7 @@ TEST_CASE("Serialization and Deserialization")
     // to worry about the reporter (or any other object) going out of scope
     // or being deleted.
     Model *model = buildModel();
-    Array_<State> traj = simulate(model);
+    SimTK::Array_<SimTK::State> traj = simulate(model);
 
     // Serialize
     SimTK::String filename = "BlockOnASpring.ostates";
@@ -686,7 +684,7 @@ TEST_CASE("Serialization and Deserialization")
 
         // (A) Deserialize
         StatesDocument docA(filename);
-        Array_<State> trajA;
+        SimTK::Array_<SimTK::State> trajA;
         docA.deserialize(*model, trajA);
 
         // Check the note and the precision.
@@ -696,10 +694,10 @@ TEST_CASE("Serialization and Deserialization")
         // Check size
         REQUIRE(traj.size() == traj.size());
 
-        // Realize both state trajectories to Stage::Report
+        // Realize both state trajectories to SimTK::Stage::Report
         for (size_t i = 0; i < (size_t)trajA.size(); ++i) {
-            model->getSystem().realize(traj[i], Stage::Report);
-            model->getSystem().realize(trajA[i], Stage::Report);
+            model->getSystem().realize(traj[i], SimTK::Stage::Report);
+            model->getSystem().realize(trajA[i], SimTK::Stage::Report);
         }
 
         // Are state trajectories A and B the same?
@@ -713,7 +711,7 @@ TEST_CASE("Exceptions")
 {
     // Build the default model and run a simulation
     Model *model = buildModel();
-    Array_<State> traj = simulate(model);
+    SimTK::Array_<SimTK::State> traj = simulate(model);
 
     // Serialize the default model
     SimTK::String filename = "BlockOnASpring.ostates";
@@ -726,7 +724,7 @@ TEST_CASE("Exceptions")
     const string& name = model->getName();
     model->setName(name + "_diff");
     StatesDocument docA(filename);
-    Array_<State> trajA;
+    SimTK::Array_<SimTK::State> trajA;
     CHECK_THROWS(docA.deserialize(*model, trajA),
         "Model names should not match.");
     model->setName(name); // return the original name
@@ -740,12 +738,12 @@ TEST_CASE("Exceptions")
         // Build a model that is different only with respect to one name of a
         // specified discrete state.
         Model* modelB = buildModel(which, suffix);
-        Array_<State> trajDoNotNeed = simulate(modelB);
+        SimTK::Array_<SimTK::State> trajDoNotNeed = simulate(modelB);
 
         // Deserialize using modelB
         // This should fail when name of a discrete state has been changed.
         StatesDocument docB(filename);
-        Array_<State> trajB;
+        SimTK::Array_<SimTK::State> trajB;
         CHECK_THROWS(docB.deserialize(*modelB, trajB),
             "Discrete state should not be found");
 
@@ -760,11 +758,11 @@ TEST_CASE("Exceptions")
         // Build a model that is different only in that one discrete state
         // is omitted.
         Model* modelC = buildModel(which, suffix, omit);
-        Array_<State> trajDoNotNeed = simulate(modelC);
+        SimTK::Array_<SimTK::State> trajDoNotNeed = simulate(modelC);
 
         // Deserialize using modelC
         StatesDocument docC(filename);
-        Array_<State> trajC;
+        SimTK::Array_<SimTK::State> trajC;
         CHECK_THROWS(docC.deserialize(*modelC, trajC),
             "Expected number of discrete states should be wrong");
 
diff --git a/OpenSim/Simulation/Test/testStatesTrajectory.cpp b/OpenSim/Simulation/Test/testStatesTrajectory.cpp
index aa150dc55..ace43b22e 100644
--- a/OpenSim/Simulation/Test/testStatesTrajectory.cpp
+++ b/OpenSim/Simulation/Test/testStatesTrajectory.cpp
@@ -29,8 +29,6 @@
 #include <OpenSim/Auxiliary/auxiliaryTestFunctions.h>
 
 using namespace OpenSim;
-using namespace SimTK;
-
 // Small to-do's:
 // TODO nondecreasing or increasing? might affect upper_bound/lower_bound.
 // TODO detailed exceptions when integrity checks fail.
@@ -45,9 +43,9 @@ const std::string statesStoFname = "testStatesTrajectory_readStorage_states.sto"
 const std::string pre40StoFname = "std_subject01_walk1_states.sto";
 
 // Helper function to get a state variable value from a storage file.
-Real getStorageEntry(const Storage& sto,
+SimTK::Real getStorageEntry(const Storage& sto,
         const int timeIndex, const std::string& columnName) {
-    Real value;
+    SimTK::Real value;
     const int columnIndex = sto.getStateIndex(columnName);
     sto.getData(timeIndex, columnIndex, value);
     return value;
@@ -341,7 +339,7 @@ void testFromStatesStorageInconsistentModel(const std::string &stoFilepath) {
                 );
 
         // No exception if allowing missing columns.
-        // The unspecified states are set to NaN (for at least two random
+        // The unspecified states are set to SimTK::NaN (for at least two random
         // states).
         auto states = StatesTrajectory::createFromStatesStorage(
                 model, stoMissingCols, true);
@@ -528,7 +526,7 @@ void testCopying() {
 
     {
         StatesTrajectory statesCopyConstruct(states);
-        // Ideally we'd check for equality (operator==()), but State does not
+        // Ideally we'd check for equality (operator==()), but SimTK::State does not
         // have an equality operator.
         SimTK_TEST_EQ((int)statesCopyConstruct.getSize(), (int)states.getSize());
         for (size_t i = 0; i < states.getSize(); ++i) {
@@ -808,4 +806,4 @@ int main() {
         SimTK_SUBTEST(testExport);
 
     SimTK_END_TEST();
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Simulation/Test/testStationDefinedFrame.cpp b/OpenSim/Simulation/Test/testStationDefinedFrame.cpp
index 88358d621..1b64ff314 100644
--- a/OpenSim/Simulation/Test/testStationDefinedFrame.cpp
+++ b/OpenSim/Simulation/Test/testStationDefinedFrame.cpp
@@ -69,10 +69,10 @@ namespace {
     }
 
     // helper: emplaces a `T` within `model`'s bodyset
-    template<typename T = Body, typename... Args>
+    template<typename T = OpenSim::Body, typename... Args>
     T& EmplaceBody(Model& model, Args&&... args)
     {
-        static_assert(std::is_base_of<Body, T>::value, "T must inherit from Body");
+        static_assert(std::is_base_of<OpenSim::Body, T>::value, "T must inherit from Body");
         return EmplaceGeneric<T>(model, std::mem_fn(&Model::addBody), std::forward<Args>(args)...);
     }
 
diff --git a/OpenSim/Tests/AddComponents/testAddComponents.cpp b/OpenSim/Tests/AddComponents/testAddComponents.cpp
index 5f585906d..0ca88362b 100644
--- a/OpenSim/Tests/AddComponents/testAddComponents.cpp
+++ b/OpenSim/Tests/AddComponents/testAddComponents.cpp
@@ -37,7 +37,6 @@
 #include <ctime>    // for clock()
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 /////////////////////////////////////////////////
@@ -71,22 +70,22 @@ void addComponentsToModel(Model& osimModel)
     // Create Frames to attach Geometry to
     // Left brick
     OpenSim::PhysicalFrame* leftAnchorFrame = 
-        new PhysicalOffsetFrame(ground, Transform(Vec3(0, 0.05, 0.35)));
+        new PhysicalOffsetFrame(ground, SimTK::Transform(SimTK::Vec3(0, 0.05, 0.35)));
     leftAnchorFrame->setName("LeftAnchor");
     osimModel.addComponent(leftAnchorFrame);
     // Right brick
     OpenSim::PhysicalFrame* rightAnchorFrame = 
-        new PhysicalOffsetFrame(ground, Transform(Vec3(0, 0.05, -0.35)));
+        new PhysicalOffsetFrame(ground, SimTK::Transform(SimTK::Vec3(0, 0.05, -0.35)));
     rightAnchorFrame->setName("RightAnchor");
     osimModel.addComponent(rightAnchorFrame);
     // Cylinder
     OpenSim::PhysicalFrame* cylFrame = 
-        new PhysicalOffsetFrame(ground, Transform(Vec3(-.2, 0.0, 0.)));
+        new PhysicalOffsetFrame(ground, SimTK::Transform(SimTK::Vec3(-.2, 0.0, 0.)));
     cylFrame->setName("CylAnchor");
     osimModel.addComponent(cylFrame);
     // Ellipsoid
     OpenSim::PhysicalFrame* ellipsoidFrame = 
-        new PhysicalOffsetFrame(ground, Transform(Vec3(-.6, 0.6, 0.)));
+        new PhysicalOffsetFrame(ground, SimTK::Transform(SimTK::Vec3(-.6, 0.6, 0.)));
     ellipsoidFrame->setName("EllipsoidAnchor");
     osimModel.addComponent(ellipsoidFrame);
 
@@ -104,8 +103,8 @@ void addComponentsToModel(Model& osimModel)
     // transform anchors to be placed at the two extremes of the sliding block (to come)
 
     // scale the anchors
-    leftAnchorGeometry->set_scale_factors(Vec3(5, 1, 1));
-    rightAnchorGeometry->set_scale_factors(Vec3(5, 1, 1));
+    leftAnchorGeometry->set_scale_factors(SimTK::Vec3(5, 1, 1));
+    rightAnchorGeometry->set_scale_factors(SimTK::Vec3(5, 1, 1));
     // position the anchors
     leftAnchorFrame->attachGeometry(leftAnchorGeometry);
     rightAnchorFrame->attachGeometry(rightAnchorGeometry);
@@ -119,9 +118,9 @@ void addComponentsToModel(Model& osimModel)
     ellipsoidFrame->attachGeometry(ellipsoidGeometry);
 
     // BLOCK BODY
-    Vec3 blockMassCenter(0);
-    Inertia blockInertia =
-        blockMass*Inertia::brick(blockSideLength, blockSideLength, blockSideLength);
+    SimTK::Vec3 blockMassCenter(0);
+    SimTK::Inertia blockInertia =
+        blockMass*SimTK::Inertia::brick(blockSideLength, blockSideLength, blockSideLength);
 
     // Create a new block body with the specified properties
     OpenSim::Body *block = new OpenSim::Body("block", blockMass, blockMassCenter, blockInertia);
@@ -136,7 +135,7 @@ void addComponentsToModel(Model& osimModel)
 
     // Create a new free joint with 6 degrees-of-freedom (coordinates) between
     // the block and ground frames
-    Vec3 locationInParent(0, blockSideLength / 2, 0),
+    SimTK::Vec3 locationInParent(0, blockSideLength / 2, 0),
         orientationInParent(0), locationInBody(0), orientationInBody(0);
     FreeJoint *blockToGround =
         new FreeJoint("blockToGround", ground, locationInParent, orientationInParent,
@@ -155,7 +154,7 @@ void addComponentsToModel(Model& osimModel)
 
     // GRAVITY
     // Obtain the default acceleration due to gravity
-    Vec3 gravity = osimModel.getGravity();
+    SimTK::Vec3 gravity = osimModel.getGravity();
 
     // Define non-zero default states for the free joint
     blockToGround->updCoordinate(FreeJoint::Coord::TranslationX)
@@ -172,8 +171,8 @@ void addComponentsToModel(Model& osimModel)
     /////////////////////////////////////////////
     // DEFINE CONSTRAINTS IMPOSED ON THE MODEL //
     /////////////////////////////////////////////
-    Vec3 pointOnGround(0, blockSideLength / 2, 0);
-    Vec3 pointOnBlock(0, 0, 0);
+    SimTK::Vec3 pointOnGround(0, blockSideLength / 2, 0);
+    SimTK::Vec3 pointOnBlock(0, 0, 0);
 
     // Create a new constant distance constraint
     ConstantDistanceConstraint *constDist =
@@ -199,11 +198,11 @@ void addComponentsToModel(Model& osimModel)
 
     // Specify the paths for the two muscles
     // Path for muscle 1
-    muscle1->addNewPathPoint("muscle1-point1", ground, Vec3(0.0, 0.05, -0.35));
-    muscle1->addNewPathPoint("muscle1-point2", *block, Vec3(0.0, 0.0, -0.05));
+    muscle1->addNewPathPoint("muscle1-point1", ground, SimTK::Vec3(0.0, 0.05, -0.35));
+    muscle1->addNewPathPoint("muscle1-point2", *block, SimTK::Vec3(0.0, 0.0, -0.05));
     // Path for muscle 2
-    muscle2->addNewPathPoint("muscle2-point1", ground, Vec3(0.0, 0.05, 0.35));
-    muscle2->addNewPathPoint("muscle2-point2", *block, Vec3(0.0, 0.0, 0.05));
+    muscle2->addNewPathPoint("muscle2-point1", ground, SimTK::Vec3(0.0, 0.05, 0.35));
+    muscle2->addNewPathPoint("muscle2-point2", *block, SimTK::Vec3(0.0, 0.0, 0.05));
 
     // Add the two muscles (as forces) to the model
     osimModel.addComponent(muscle1);
@@ -213,7 +212,7 @@ void addComponentsToModel(Model& osimModel)
     // Define contact geometry
     // Create new floor contact halfspace
     ContactHalfSpace *floor =
-        new ContactHalfSpace(Vec3(0), Vec3(0, 0, -0.5*SimTK_PI), ground, "floor");
+        new ContactHalfSpace(SimTK::Vec3(0), SimTK::Vec3(0, 0, -0.5*SimTK_PI), ground, "floor");
     // Create new cube contact mesh
     OpenSim::ContactMesh *cube =
         new OpenSim::ContactMesh("blockMesh.obj", SimTK::Vec3(0), SimTK::Vec3(0), *block, "cube");
@@ -359,7 +358,7 @@ int main()
         // Initialize the system and get the default state
         SimTK::State& si = osimModel.initSystem();
 
-        osimModel.getMultibodySystem().realize(si, Stage::Velocity);
+        osimModel.getMultibodySystem().realize(si, SimTK::Stage::Velocity);
 
         // Compute initial conditions for muscles
         osimModel.equilibrateMuscles(si);
@@ -403,4 +402,4 @@ int main()
     cout << "OpenSim testAddComponents completed successfully." << endl;
 
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Tests/ConstantCurvatureExample/testConstantCurvature.cpp b/OpenSim/Tests/ConstantCurvatureExample/testConstantCurvature.cpp
index 1d2e82627..0638c1cf0 100644
--- a/OpenSim/Tests/ConstantCurvatureExample/testConstantCurvature.cpp
+++ b/OpenSim/Tests/ConstantCurvatureExample/testConstantCurvature.cpp
@@ -35,16 +35,12 @@
 // #define VISUALIZE
 
 #include "OpenSim/OpenSim.h"
-
-using namespace SimTK;
 using namespace OpenSim;
 
 void testJacobians1() {
-    using namespace SimTK;
-
     double d = 0.2;
-    Vec3 q(0.5, 0.5, 0.5);
-    Vec3 qDot(0.1, 0.2, 0.3);
+    SimTK::Vec3 q(0.5, 0.5, 0.5);
+    SimTK::Vec3 qDot(0.1, 0.2, 0.3);
 
     ////////////////////////////////////////////////////////
     // Test the ordinary Jacobian
@@ -125,11 +121,9 @@ void testJacobians1() {
 }
 
 void testJacobians2() {
-    using namespace SimTK;
-
     double d = 1.0;
-    Vec3 q(0.50464766, 0.55085949, 0.0018320994);
-    Vec3 qDot(0.44693263, 0.76950436, 0.0065713527);
+    SimTK::Vec3 q(0.50464766, 0.55085949, 0.0018320994);
+    SimTK::Vec3 qDot(0.44693263, 0.76950436, 0.0065713527);
 
     ////////////////////////////////////////////////////////
     // Test the ordinary Jacobian
@@ -210,11 +204,9 @@ void testJacobians2() {
 }
 
 void testJacobians3() {
-    using namespace SimTK;
-
     double d = 1.0;
 
-    Vec3 q(0.79846287622439227, 1.5707963210265892, -0.015968884371590844);
+    SimTK::Vec3 q(0.79846287622439227, 1.5707963210265892, -0.015968884371590844);
     // Check that this doesn't fire any asserts or crash
     Mat63 J = ConstantCurvatureJoint::getConstantCurveJacobian(q, d);
     (void)J; // keep compiler from complaining
@@ -240,7 +232,7 @@ int main() {
     double springViscosity = 2.0;
 
     // Create display geometry.
-    Brick bodyGeometry(Vec3(0.1, 0.1, 0.1));
+    Brick bodyGeometry(SimTK::Vec3(0.1, 0.1, 0.1));
     bodyGeometry.setColor(Gray);
 
     // Add a console reporter to print the muscle fiber force and elbow angle.
@@ -249,7 +241,7 @@ int main() {
 
     for (int i = 0; i < numBodies; i++) {
         OpenSim::Body* body = new OpenSim::Body("body_" + std::to_string(i), 1,
-                Vec3(0), Inertia(0.1, 0.1, 0.1));
+                SimTK::Vec3(0), SimTK::Inertia(0.1, 0.1, 0.1));
 
         model.addBody(body);
         bodies.push_back(body);
@@ -257,7 +249,7 @@ int main() {
         // Attach an ellipsoid to a frame located at the center of each body.
         PhysicalOffsetFrame* visualCenter =
                 new PhysicalOffsetFrame("body_viz_center_" + std::to_string(i),
-                        *body, Transform(Vec3(0)));
+                        *body, SimTK::Transform(SimTK::Vec3(0)));
         body->addComponent(visualCenter);
         visualCenter->attachGeometry(bodyGeometry.clone());
 
@@ -265,10 +257,10 @@ int main() {
         ConstantCurvatureJoint* joint;
         if (i > 0) {
             joint = new ConstantCurvatureJoint("ccj" + std::to_string(i),
-                    *(bodies[i - 1]), *(bodies[i]), Vec3(0, 0, 0), 1.0);
+                    *(bodies[i - 1]), *(bodies[i]), SimTK::Vec3(0, 0, 0), 1.0);
         } else {
             joint = new ConstantCurvatureJoint("ccj" + std::to_string(i),
-                    model.getGround(), *(bodies[i]), Vec3(0, 0, 0), 1.0);
+                    model.getGround(), *(bodies[i]), SimTK::Vec3(0, 0, 0), 1.0);
         }
         joint->updCoordinate(ConstantCurvatureJoint::Coord::RotationX)
                 .setName("joint_" + std::to_string(i) + "_x");
@@ -334,7 +326,7 @@ int main() {
     model.addComponent(reporter);
 
     // Configure the model.
-    State& state = model.initSystem();
+    SimTK::State& state = model.initSystem();
 
     static_cast<ConstantCurvatureJoint*>(joints[0])
             ->getCoordinate(ConstantCurvatureJoint::Coord::RotationZ)
@@ -355,4 +347,4 @@ int main() {
     simulate(model, state, 20.0);
 
     return 0;
-};
+};
\ No newline at end of file
diff --git a/OpenSim/Tests/README/testREADME.cpp b/OpenSim/Tests/README/testREADME.cpp
index 171021b1e..da466b574 100644
--- a/OpenSim/Tests/README/testREADME.cpp
+++ b/OpenSim/Tests/README/testREADME.cpp
@@ -44,7 +44,6 @@
 
 /// [README]
 #include <OpenSim/OpenSim.h>
-using namespace SimTK;
 using namespace OpenSim;
 
 int main() {
@@ -59,25 +58,25 @@ int main() {
     // ellipsoid with radii of 0.1, 0.5 and 0.1, in the x, y and z directions,
     // respectively.
     OpenSim::Body* humerus = new OpenSim::Body(
-        "humerus", 1, Vec3(0), Inertia(0.052, 0.004, 0.052));
+        "humerus", 1, SimTK::Vec3(0), SimTK::Inertia(0.052, 0.004, 0.052));
     OpenSim::Body* radius  = new OpenSim::Body(
-        "radius",  1, Vec3(0), Inertia(0.052, 0.004, 0.052));
+        "radius",  1, SimTK::Vec3(0), SimTK::Inertia(0.052, 0.004, 0.052));
 
     // Connect the bodies with pin joints. Assume each body is 1 m long.
     PinJoint* shoulder = new PinJoint("shoulder",
             // Parent body, location in parent, orientation in parent.
-            model.getGround(), Vec3(0), Vec3(0),
+            model.getGround(), SimTK::Vec3(0), SimTK::Vec3(0),
             // Child body, location in child, orientation in child.
-            *humerus, Vec3(0, 0.5, 0), Vec3(0));
+            *humerus, SimTK::Vec3(0, 0.5, 0), SimTK::Vec3(0));
     PinJoint* elbow = new PinJoint("elbow",
-            *humerus, Vec3(0, -0.5, 0), Vec3(0),
-            *radius, Vec3(0, 0.5, 0), Vec3(0));
+            *humerus, SimTK::Vec3(0, -0.5, 0), SimTK::Vec3(0),
+            *radius, SimTK::Vec3(0, 0.5, 0), SimTK::Vec3(0));
 
     // Add a muscle that flexes the elbow.
     Millard2012EquilibriumMuscle* biceps = new
         Millard2012EquilibriumMuscle("biceps", 100, 0.6, 0.55, 0);
-    biceps->addNewPathPoint("origin",    *humerus, Vec3(0, 0.3, 0));
-    biceps->addNewPathPoint("insertion", *radius,  Vec3(0, 0.2, 0));
+    biceps->addNewPathPoint("origin",    *humerus, SimTK::Vec3(0, 0.3, 0));
+    biceps->addNewPathPoint("insertion", *radius,  SimTK::Vec3(0, 0.2, 0));
 
     // Add a controller that specifies the excitation of the muscle.
     PrescribedController* brain = new PrescribedController();
@@ -106,19 +105,19 @@ int main() {
     bodyGeometry.setColor(Gray);
     // Attach an ellipsoid to a frame located at the center of each body.
     PhysicalOffsetFrame* humerusCenter = new PhysicalOffsetFrame(
-        "humerusCenter", *humerus, Transform(Vec3(0)));
+        "humerusCenter", *humerus, SimTK::Transform(SimTK::Vec3(0)));
     humerus->addComponent(humerusCenter);
     humerusCenter->attachGeometry(bodyGeometry.clone());
     PhysicalOffsetFrame* radiusCenter = new PhysicalOffsetFrame(
-        "radiusCenter", *radius, Transform(Vec3(0)));
+        "radiusCenter", *radius, SimTK::Transform(SimTK::Vec3(0)));
     radius->addComponent(radiusCenter);
     radiusCenter->attachGeometry(bodyGeometry.clone());
 
     // Configure the model.
-    State& state = model.initSystem();
+    SimTK::State& state = model.initSystem();
     // Fix the shoulder at its default angle and begin with the elbow flexed.
     shoulder->getCoordinate().setLocked(state, true);
-    elbow->getCoordinate().setValue(state, 0.5 * Pi);
+    elbow->getCoordinate().setValue(state, 0.5 * SimTK::Pi);
     model.equilibrateMuscles(state);
 
     // Configure the visualizer.
@@ -134,4 +133,4 @@ int main() {
 
     return 0;
 };
-/// [README]
+/// [README]
\ No newline at end of file
diff --git a/OpenSim/Tests/SimpleOptimizationExample/testSimpleOptimizationExample.cpp b/OpenSim/Tests/SimpleOptimizationExample/testSimpleOptimizationExample.cpp
index caa19862a..e0e9e8427 100644
--- a/OpenSim/Tests/SimpleOptimizationExample/testSimpleOptimizationExample.cpp
+++ b/OpenSim/Tests/SimpleOptimizationExample/testSimpleOptimizationExample.cpp
@@ -30,27 +30,26 @@
 #include <OpenSim/Auxiliary/auxiliaryTestFunctions.h>
 
 using namespace OpenSim;
-using namespace SimTK;
 using namespace std;
 
 // step count for troubleshooting
 int stepCount = 0;
 
-double bestSoFar = Infinity;
+double bestSoFar = SimTK::Infinity;
 
 class ExampleOptimizationSystem : public OptimizerSystem {
    public:
 
        /* Constructor class. Parameters passed are accessed in the objectiveFunc() class. */
-       ExampleOptimizationSystem(int numParameters, State& s, Model& aModel): 
+       ExampleOptimizationSystem(int numParameters, SimTK::State& s, Model& aModel): 
              OptimizerSystem(numParameters), 
              si(s),
              osimModel(aModel){}
                 
-    int objectiveFunc(  const Vector &newControls, bool new_coefficients, Real& f ) const override {
+    int objectiveFunc(  const SimTK::Vector &newControls, bool new_coefficients, SimTK::Real& f ) const override {
 
         // make a copy of out initial states
-        State s = si;
+        SimTK::State s = si;
 
         // Update the coordinate value of r_elbow_flex
         OpenSim::Coordinate& elbowFlexCoord = osimModel.updCoordinateSet().get("r_elbow_flex");
@@ -82,7 +81,7 @@ class ExampleOptimizationSystem : public OptimizerSystem {
    }    
 
 private:
-    State& si;
+    SimTK::State& si;
     Model& osimModel;
  };
 
@@ -101,7 +100,7 @@ int main()
         Model osimModel("Arm26_Optimize.osim");
         
         // Initialize the system and get the state representing the state system
-        State& si = osimModel.initSystem();
+        SimTK::State& si = osimModel.initSystem();
 
         // initialize the starting shoulder angle
         const CoordinateSet& coords = osimModel.getCoordinateSet();
@@ -116,19 +115,19 @@ int main()
         }
         OpenSim::Coordinate& elbowFlexCoord = osimModel.updCoordinateSet().get("r_elbow_flex");
         elbowFlexCoord.setValue(si, 1.0);
-        //osimModel.getMultibodySystem().realize(si, Stage::Velocity);
+        //osimModel.getMultibodySystem().realize(si, SimTK::Stage::Velocity);
         // Make sure the muscles states are in equilibrium
         osimModel.equilibrateMuscles(si);
         
         // Initialize the optimizer system we've defined.
         ExampleOptimizationSystem sys(1, si, osimModel);
-        Real f = NaN;
+        SimTK::Real f = SimTK::NaN;
         
         /* Define initial values and bounds for the controls to optimize */
 
-        Vector controls(1, 1.0); // 1 radian for default value
-        Vector lower_bounds(1, elbowFlexCoord.getRangeMin());
-        Vector upper_bounds(1, elbowFlexCoord.getRangeMax());
+        SimTK::Vector controls(1, 1.0); // 1 radian for default value
+        SimTK::Vector lower_bounds(1, elbowFlexCoord.getRangeMin());
+        SimTK::Vector upper_bounds(1, elbowFlexCoord.getRangeMax());
 
         sys.setParameterLimits( lower_bounds, upper_bounds );
         
@@ -158,4 +157,4 @@ int main()
     
     // End of main() routine.
     return 0;
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Tools/Test/testControllers.cpp b/OpenSim/Tools/Test/testControllers.cpp
index 632f37931..d7cc637b7 100644
--- a/OpenSim/Tools/Test/testControllers.cpp
+++ b/OpenSim/Tools/Test/testControllers.cpp
@@ -71,8 +71,6 @@ TEST_CASE("Test Controller interface") {
 }
 
 TEST_CASE("testControlSetControllerOnBlock") {
-    using namespace SimTK;
-
     // Create a new OpenSim model
     Model osimModel;
     osimModel.setName("osimModel");
@@ -82,8 +80,8 @@ TEST_CASE("testControlSetControllerOnBlock") {
 
     // Create a 20 kg, 0.1 m^3 block body
     double blockMass = 20.0, blockSideLength = 0.1;
-    Vec3 blockMassCenter(0), groundOrigin(0), blockInGround(0, blockSideLength/2, 0);
-    Inertia blockInertia = Inertia::brick(blockSideLength, blockSideLength, blockSideLength);
+    SimTK::Vec3 blockMassCenter(0), groundOrigin(0), blockInGround(0, blockSideLength/2, 0);
+    SimTK::Inertia blockInertia = SimTK::Inertia::brick(blockSideLength, blockSideLength, blockSideLength);
 
     OpenSim::Body block("block", blockMass, blockMassCenter, blockMass*blockInertia);
 
@@ -164,8 +162,6 @@ TEST_CASE("testControlSetControllerOnBlock") {
 }
 
 TEST_CASE("testPrescribedControllerOnBlock") {
-    using namespace SimTK;
-
     auto enabled = GENERATE(true, false);
 
     // Create a new OpenSim model
@@ -177,8 +173,8 @@ TEST_CASE("testPrescribedControllerOnBlock") {
 
     // Create a 20 kg, 0.1 m^3 block body
     double blockMass = 20.0, blockSideLength = 0.1;
-    Vec3 blockMassCenter(0), groundOrigin(0), blockInGround(0, blockSideLength/2, 0);
-    Inertia blockInertia = Inertia::brick(blockSideLength, blockSideLength, blockSideLength);
+    SimTK::Vec3 blockMassCenter(0), groundOrigin(0), blockInGround(0, blockSideLength/2, 0);
+    SimTK::Inertia blockInertia = SimTK::Inertia::brick(blockSideLength, blockSideLength, blockSideLength);
 
     OpenSim::Body block("block", blockMass, blockMassCenter, blockMass*blockInertia);
 
@@ -260,8 +256,6 @@ TEST_CASE("testPrescribedControllerOnBlock") {
 }
 
 TEST_CASE("testCorrectionControllerOnBlock") {
-    using namespace SimTK;
-
     // Create a new OpenSim model
     Model osimModel;
     osimModel.setName("osimModel");
@@ -271,8 +265,8 @@ TEST_CASE("testCorrectionControllerOnBlock") {
 
     // Create a 20 kg, 0.1 m^3 block body
     double blockMass = 20.0, blockSideLength = 0.1;
-    Vec3 blockMassCenter(0), groundOrigin(0), blockInGround(0, blockSideLength/2, 0);
-    Inertia blockInertia = Inertia::brick(blockSideLength, blockSideLength, blockSideLength);
+    SimTK::Vec3 blockMassCenter(0), groundOrigin(0), blockInGround(0, blockSideLength/2, 0);
+    SimTK::Inertia blockInertia = SimTK::Inertia::brick(blockSideLength, blockSideLength, blockSideLength);
 
     OpenSim::Body block("block", blockMass, blockMassCenter, blockMass*blockInertia);
 
@@ -310,8 +304,6 @@ TEST_CASE("testCorrectionControllerOnBlock") {
 
 
 TEST_CASE("testPrescribedControllerFromFile") {
-    using namespace SimTK;
-
     std::string modelFile = "arm26.osim";
     std::string actuatorsFile = "arm26_Reserve_Actuators.xml";
     std::string controlsFile = "arm26_controls.xml";
diff --git a/OpenSim/Tools/Test/testExternalLoads.cpp b/OpenSim/Tools/Test/testExternalLoads.cpp
index 105ec2551..ff97b0a11 100644
--- a/OpenSim/Tools/Test/testExternalLoads.cpp
+++ b/OpenSim/Tools/Test/testExternalLoads.cpp
@@ -78,10 +78,8 @@ void addLoadToStorage(Storage &forceStore, SimTK::Vec3 force, SimTK::Vec3 point,
 
 TEST_CASE("ExternalLoads")
 {
-    using namespace SimTK;
-
     Model model("Pendulum.osim");
-    State &s = model.initSystem();
+    SimTK::State &s = model.initSystem();
 
     // Simulate gravity 
     double init_t =-1e-8;
@@ -90,12 +88,12 @@ TEST_CASE("ExternalLoads")
     double dt = final_t/nsteps;
 
     //initial state
-    double q_init = Pi/4;
+    double q_init = SimTK::Pi/4;
     model.updCoordinateSet()[0].setValue(s, q_init);
 
-    Vector_<double> q_grav(nsteps+1);
+    SimTK::Vector_<double> q_grav(nsteps+1);
 
-    // Integrator and integration manager
+    // SimTK::Integrator and integration manager
     double integ_accuracy = 1e-6;
     Manager manager(model);
     manager.setIntegratorAccuracy(integ_accuracy);
@@ -113,10 +111,10 @@ TEST_CASE("ExternalLoads")
     // Simulate the same system without gravity but with an equivalent external load
     OpenSim::Body &pendulum = model.getBodySet().get(model.getNumBodies()-1);
     string pendBodyName = pendulum.getName();
-    Vec3 comInB = pendulum.getMassCenter();
+    SimTK::Vec3 comInB = pendulum.getMassCenter();
 
     Storage forceStore;
-    addLoadToStorage(forceStore,  pendulum.getMass()*model.getGravity(),  comInB, Vec3(0, 0, 0));
+    addLoadToStorage(forceStore,  pendulum.getMass()*model.getGravity(),  comInB, SimTK::Vec3(0, 0, 0));
     forceStore.setName("test_external_loads.sto");
     forceStore.print(forceStore.getName());
 
@@ -158,8 +156,8 @@ TEST_CASE("ExternalLoads")
     manager2.initialize(s2);
 
     // Simulate with the external force applied instead of gravity
-    Vector_<double> q_xf(nsteps+1);
-    Vector_<Vec3> pcom_xf(nsteps+1);
+    SimTK::Vector_<double> q_xf(nsteps+1);
+    SimTK::Vector_<SimTK::Vec3> pcom_xf(nsteps+1);
 
     for(int i = 0; i < nsteps+1; i++){
         manager2.integrate(dt*i);
@@ -168,7 +166,7 @@ TEST_CASE("ExternalLoads")
 
     //q_xf.dump("Coords due to external force point expressed in pendulum.");
 
-    Vector err = q_xf-q_grav;
+    SimTK::Vector err = q_xf-q_grav;
     double norm_err = err.norm();
 
     // kinematics should match to within integ accuracy
@@ -223,7 +221,7 @@ TEST_CASE("ExternalLoads")
     manager3.initialize(s3);
 
     // Simulate with the external force applied instead of gravity
-    Vector_<double> q_xf2(nsteps+1);
+    SimTK::Vector_<double> q_xf2(nsteps+1);
 
     for(int i = 0; i < nsteps+1; i++){
         manager3.integrate(dt*i);
@@ -242,17 +240,15 @@ TEST_CASE("ExternalLoads")
 // Ensure the default values for the ExternalForce properties work as expected.
 TEST_CASE("ExternalLoads Default Properties")
 {
-    using namespace SimTK;
-
     Model model("Pendulum.osim");
 
     auto& pendulum = model.getBodySet().get(model.getNumBodies()-1);
     string pendBodyName = pendulum.getName();
-    Vec3 comInB = pendulum.getMassCenter();
+    SimTK::Vec3 comInB = pendulum.getMassCenter();
 
     Storage forceStore;
     addLoadToStorage(forceStore,  pendulum.getMass()*model.getGravity(),
-            comInB, Vec3(0, 0, 0));
+            comInB, SimTK::Vec3(0, 0, 0));
     forceStore.setName("test_external_load_default_properties.sto");
     forceStore.print(forceStore.getName());
 
@@ -309,4 +305,4 @@ TEST_CASE("ExternalLoads Can Be Copied")
 
     OpenSim::Model copy{model};   // create an independent copy containing the `OpenSim::ExternalLoads`
     copy.finalizeConnections();   // should work (wasn't when this test was written)
-}
+}
\ No newline at end of file
diff --git a/OpenSim/Tools/Test/testVisualization.cpp b/OpenSim/Tools/Test/testVisualization.cpp
index 47024c9ae..87b70abe0 100644
--- a/OpenSim/Tools/Test/testVisualization.cpp
+++ b/OpenSim/Tools/Test/testVisualization.cpp
@@ -31,8 +31,6 @@
 
 using namespace OpenSim;
 using namespace std;
-using namespace SimTK;
-
 void testVisModel(Model& model, const std::string filename_for_standard);
 Model createModel4AppearanceTest();
 void populate_doublePendulumPrimitives(SimTK::Array_<DecorativeGeometry>&); 
@@ -102,14 +100,14 @@ public:
     void setPrintTransforms(bool toPrint) { printTransform = toPrint;}
 private:
     std::stringstream printout;
-    bool printTransform = false; // Flag to indicate whether or not to output transform as String
+    bool printTransform = false; // Flag to indicate whether or not to output transform as SimTK::String
     std::string printCommonProps(const DecorativeGeometry& dg){
         std::stringstream oneDGStream;
         oneDGStream << " bodyId:" << dg.getBodyId() << " color:" << dg.getColor() << " indexOnBody:"
             << dg.getIndexOnBody() << " Opacity:" << dg.getOpacity() << " Rep:" << dg.getRepresentation() << " Scale:"
             << dg.getScaleFactors();
         if (printTransform)
-            oneDGStream << " Transform:" << dg.getTransform();
+            oneDGStream << " SimTK::Transform:" << dg.getTransform();
         return oneDGStream.str();
     }
 
@@ -220,7 +218,7 @@ Model createModel4AppearanceTest()
     //DecorativeGeometry default is Rep : 3 shaded in std file
     modelWithGroundOnly.updGround().attachGeometry(unitSphere);
     // Create offset frame and add to model
-    SimTK::Transform translate(Vec3(1.0, 0., 0.));
+    SimTK::Transform translate(SimTK::Vec3(1.0, 0., 0.));
     PhysicalOffsetFrame* oframe = new PhysicalOffsetFrame(ground, translate);
     modelWithGroundOnly.addComponent(oframe);
     // Change color and opacity
@@ -228,14 +226,14 @@ Model createModel4AppearanceTest()
     offsetSphere->upd_Appearance().set_color(SimTK::Cyan);
     offsetSphere->upd_Appearance().set_opacity(0.5);
     oframe->attachGeometry(offsetSphere);
-    PhysicalOffsetFrame* ooframe = new PhysicalOffsetFrame(ground, Vec3(2.0, 0., 0.));
+    PhysicalOffsetFrame* ooframe = new PhysicalOffsetFrame(ground, SimTK::Vec3(2.0, 0., 0.));
     modelWithGroundOnly.addComponent(ooframe);
     // invisible Sphere
     Sphere* ooffsetSphere = unitSphere->clone();
     // Hidden   
     ooffsetSphere->upd_Appearance().set_visible(false);
     ooframe->attachGeometry(ooffsetSphere);
-    PhysicalOffsetFrame* oooframe = new PhysicalOffsetFrame(ground, Vec3(3.0, 0., 0.));
+    PhysicalOffsetFrame* oooframe = new PhysicalOffsetFrame(ground, SimTK::Vec3(3.0, 0., 0.));
     modelWithGroundOnly.addComponent(oooframe);
     // Wireframe Sphere
     Sphere* oooffsetSphere = unitSphere->clone();
@@ -280,11 +278,11 @@ bool testVisModelAgainstStandard(Model& model, const SimTK::Array_<DecorativeGeo
             geometryToDisplay[i].implementGeometry(dgiTextFromModel);
             if (!(dgiTextFromStandard.getAsString() == dgiTextFromModel.getAsString()))
                 throw  OpenSim::Exception("failed comparing " + dgiTextFromStandard.getAsString() + "vs." + dgiTextFromModel.getAsString());
-            // Compare transforms, this has to be more lenient than String comparison due to roundoff
+            // Compare transforms, this has to be more lenient than SimTK::String comparison due to roundoff
             SimTK::Mat44 diffTransform = nextGeom->getTransform().toMat44() - geometryToDisplay[i].getTransform().toMat44();
-            // std::cout << "Transform from standard: "
+            // std::cout << "SimTK::Transform from standard: "
             //      << nextGeom->getTransform().toMat44() << std::endl;
-            // std::cout << "Transform from model: "
+            // std::cout << "SimTK::Transform from model: "
             //      << geometryToDisplay[i].getTransform().toMat44() << std::endl;
             double norm = diffTransform.norm();
             SimTK_TEST_EQ(norm, 0.)
@@ -308,13 +306,13 @@ void populate_doublePendulumPrimitives(SimTK::Array_<DecorativeGeometry>& stdPri
     stdPrimitives.push_back(
         DecorativeFrame(1.0).setBodyId(1).setColor(SimTK::White).setIndexOnBody(0).setScale(0.2)
         .setOpacity(1).setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(SimTK::Transform(Vec3{ 0., .25, 0 })));
+        .setTransform(SimTK::Transform(SimTK::Vec3{ 0., .25, 0 })));
     // Cylinder rod1
     stdPrimitives.push_back(
         DecorativeMeshFile("cylinder.vtp").setBodyId(1).setColor(SimTK::White)
-        .setIndexOnBody(0).setScaleFactors(Vec3{ 0.02,0.5,0.02 }).setOpacity(1)
+        .setIndexOnBody(0).setScaleFactors(SimTK::Vec3{ 0.02,0.5,0.02 }).setOpacity(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(SimTK::Transform(Vec3{ 0., .25, 0 })));
+        .setTransform(SimTK::Transform(SimTK::Vec3{ 0., .25, 0 })));
     // Frame rod 1
     stdPrimitives.push_back(
         DecorativeFrame(1.0).setBodyId(1).setColor(SimTK::White)
@@ -331,13 +329,13 @@ void populate_doublePendulumPrimitives(SimTK::Array_<DecorativeGeometry>& stdPri
         DecorativeFrame(1.0).setBodyId(2).setColor(SimTK::White)
         .setIndexOnBody(0).setScale(0.2).setOpacity(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(SimTK::Transform(Vec3{ 0., .25, 0 })));
+        .setTransform(SimTK::Transform(SimTK::Vec3{ 0., .25, 0 })));
     // Cylinder rod2
     stdPrimitives.push_back(
         DecorativeMeshFile("cylinder.vtp").setBodyId(2).setColor(SimTK::White)
-        .setIndexOnBody(0).setScaleFactors(Vec3{ 0.02,0.5,0.02 }).setOpacity(1)
+        .setIndexOnBody(0).setScaleFactors(SimTK::Vec3{ 0.02,0.5,0.02 }).setOpacity(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(SimTK::Transform(Vec3{ 0., .25, 0 })));
+        .setTransform(SimTK::Transform(SimTK::Vec3{ 0., .25, 0 })));
     // Frame body 2
     stdPrimitives.push_back(
         DecorativeFrame(1.0).setBodyId(2).setColor(SimTK::White)
@@ -346,7 +344,7 @@ void populate_doublePendulumPrimitives(SimTK::Array_<DecorativeGeometry>& stdPri
     // Block rod 2
     stdPrimitives.push_back(
         DecorativeMeshFile("block.vtp").setBodyId(2).setColor(SimTK::White)
-        .setIndexOnBody(0).setScaleFactors(Vec3{ 1, 1.5, 2 }).setOpacity(1)
+        .setIndexOnBody(0).setScaleFactors(SimTK::Vec3{ 1, 1.5, 2 }).setOpacity(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface));
 
     // Two more offset frames and 2 for the Joint
@@ -354,22 +352,22 @@ void populate_doublePendulumPrimitives(SimTK::Array_<DecorativeGeometry>& stdPri
         DecorativeFrame(1).setBodyId(0).setColor(SimTK::White)
         .setIndexOnBody(0).setScale(0.2).setOpacity(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(SimTK::Transform(Vec3{ 0., 0, 0 })));
+        .setTransform(SimTK::Transform(SimTK::Vec3{ 0., 0, 0 })));
     stdPrimitives.push_back(
         DecorativeFrame(1).setBodyId(1).setColor(SimTK::White)
         .setIndexOnBody(0).setScale(0.2).setOpacity(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(SimTK::Transform(Vec3{ 0., .5, 0 })));
+        .setTransform(SimTK::Transform(SimTK::Vec3{ 0., .5, 0 })));
     stdPrimitives.push_back(
         DecorativeFrame(1).setBodyId(1).setColor(SimTK::White)
         .setIndexOnBody(0).setScale(0.2).setOpacity(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(SimTK::Transform(Vec3{ 0., 0, 0 })));
+        .setTransform(SimTK::Transform(SimTK::Vec3{ 0., 0, 0 })));
     stdPrimitives.push_back(
         DecorativeFrame(1).setBodyId(2).setColor(SimTK::White)
         .setIndexOnBody(0).setScale(0.2).setOpacity(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(SimTK::Transform(Vec3{ 0., .5, 0 })));
+        .setTransform(SimTK::Transform(SimTK::Vec3{ 0., .5, 0 })));
 
 }
 
@@ -385,12 +383,12 @@ void populate_composedTransformPrimitives(SimTK::Array_<DecorativeGeometry>& std
         DecorativeFrame(1.0).setBodyId(1).setColor(SimTK::White)
         .setIndexOnBody(0).setScale(0.2).setOpacity(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(SimTK::Transform(Vec3{ 0.3, 0.3, 0.3 })));
+        .setTransform(SimTK::Transform(SimTK::Vec3{ 0.3, 0.3, 0.3 })));
     stdPrimitives.push_back(
         DecorativeMeshFile("block.vtp").setBodyId(1).setColor(SimTK::White)
-        .setIndexOnBody(0).setScaleFactors(Vec3{ 1, 2, 3 }).setOpacity(1)
+        .setIndexOnBody(0).setScaleFactors(SimTK::Vec3{ 1, 2, 3 }).setOpacity(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(SimTK::Transform(Vec3{ 0.3, 0.3, 0.3 })));
+        .setTransform(SimTK::Transform(SimTK::Vec3{ 0.3, 0.3, 0.3 })));
 
     stdPrimitives.push_back(
         DecorativeFrame(1.0).setBodyId(1).setColor(SimTK::White)
@@ -402,12 +400,12 @@ void populate_composedTransformPrimitives(SimTK::Array_<DecorativeGeometry>& std
         DecorativeFrame(1.0).setBodyId(0).setColor(SimTK::White)
         .setIndexOnBody(0).setScale(0.2).setOpacity(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(SimTK::Transform(Vec3{ 0., 0.05, 0. })));
+        .setTransform(SimTK::Transform(SimTK::Vec3{ 0., 0.05, 0. })));
     stdPrimitives.push_back(
         DecorativeFrame(1.0).setBodyId(1).setColor(SimTK::White)
         .setIndexOnBody(0).setScale(0.2).setOpacity(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(SimTK::Transform(Vec3{ 0., 0.5, 0. })));
+        .setTransform(SimTK::Transform(SimTK::Vec3{ 0., 0.5, 0. })));
 }
 
 void populate_contactModelPrimitives(SimTK::Array_<DecorativeGeometry>& stdPrimitives) {
@@ -417,7 +415,7 @@ void populate_contactModelPrimitives(SimTK::Array_<DecorativeGeometry>& stdPrimi
         DecorativeFrame(1.0).setBodyId(0).setColor(SimTK::White)
         .setIndexOnBody(0).setScale(0.2).setOpacity(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface));
-    // Frame for Ball Body
+    // Frame for Ball SimTK::Body
     stdPrimitives.push_back(
         DecorativeFrame(1.0).setBodyId(1).setColor(SimTK::White)
         .setIndexOnBody(0).setScale(0.2).setOpacity(1)
@@ -438,18 +436,18 @@ void populate_contactModelPrimitives(SimTK::Array_<DecorativeGeometry>& stdPrimi
         DecorativeMesh(mesh).setBodyId(0).setColor(SimTK::Cyan)
         .setIndexOnBody(-1).setOpacity(1).setScale(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawWireframe)
-        .setTransform(SimTK::Transform(Vec3{ 1, 2, 0. })));
+        .setTransform(SimTK::Transform(SimTK::Vec3{ 1, 2, 0. })));
     stdPrimitives.push_back(
         DecorativeMesh(mesh).setBodyId(1).setColor(SimTK::Cyan)
         .setIndexOnBody(-1).setOpacity(1).setScale(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawWireframe)
-        .setTransform(SimTK::Transform(Vec3{ 1, 1, 0. })));
+        .setTransform(SimTK::Transform(SimTK::Vec3{ 1, 1, 0. })));
     // ContactSphere
     stdPrimitives.push_back(
         DecorativeSphere(0.25).setBodyId(1).setColor(SimTK::Cyan)
         .setIndexOnBody(-1).setOpacity(1).setScale(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawWireframe)
-        .setTransform(SimTK::Transform(Vec3{ 0, 1, 0. })));
+        .setTransform(SimTK::Transform(SimTK::Vec3{ 0, 1, 0. })));
     // ContactHalfSpace as thin block
     SimTK::Transform transform;
     transform.updR().setRotationFromAngleAboutZ(.5);
@@ -457,7 +455,7 @@ void populate_contactModelPrimitives(SimTK::Array_<DecorativeGeometry>& stdPrimi
         DecorativeBrick({ 0.0005,0.5,0.5 }).setBodyId(0).setColor(SimTK::Cyan)
         .setIndexOnBody(-1).setOpacity(0.7).setScale(1)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(transform * Transform(Vec3(0.0005, 0, 0))));
+        .setTransform(transform * SimTK::Transform(SimTK::Vec3(0.0005, 0, 0))));
 
 }
 
@@ -490,42 +488,42 @@ void populate_wrapModelPrimitives(SimTK::Array_<DecorativeGeometry>& stdPrimitiv
             DecorativeFrame(1.0).setBodyId(1).setColor(SimTK::White)
             .setIndexOnBody(0).setScale(0.2).setOpacity(1)
             .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-            .setTransform(Vec3({ -.01, -.03, .03 })));
+            .setTransform(SimTK::Vec3({ -.01, -.03, .03 })));
     }
-    Transform cylTransform;
+    SimTK::Transform cylTransform;
     // This transform parallels the code in generateDecorations to reflect
     // that DecorativeCylinder is Y aligned while WrapCylinder is Z aligned
     cylTransform.updR().setRotationFromAngleAboutX(SimTK_PI / 2);
     stdPrimitives.push_back(
-        DecorativeCylinder(.025, .05).setBodyId(0).setColor(Vec3(0, 0.2, 0.8))
+        DecorativeCylinder(.025, .05).setBodyId(0).setColor(SimTK::Vec3(0, 0.2, 0.8))
         .setIndexOnBody(-1).setScale(1).setOpacity(0.5)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(Transform(cylTransform.R(), Vec3({ .01, -.4, .01 }))));
+        .setTransform(SimTK::Transform(cylTransform.R(), SimTK::Vec3({ .01, -.4, .01 }))));
     stdPrimitives.push_back(
         DecorativeCylinder(.03, .05).setBodyId(0).setColor(SimTK::Cyan)
         .setIndexOnBody(-1).setScale(1).setOpacity(0.5)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(Transform(cylTransform.R(), Vec3({ .025, -.25, 0 }))));
+        .setTransform(SimTK::Transform(cylTransform.R(), SimTK::Vec3({ .025, -.25, 0 }))));
     stdPrimitives.push_back(
         DecorativeCylinder(.03, .05).setBodyId(0).setColor(SimTK::Cyan)
         .setIndexOnBody(-1).setScale(1).setOpacity(0.5)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(Transform(cylTransform.R(), Vec3({ .05, -.25, 0 }))));
+        .setTransform(SimTK::Transform(cylTransform.R(), SimTK::Vec3({ .05, -.25, 0 }))));
     stdPrimitives.push_back(
-        DecorativeSphere(.055).setBodyId(0).setColor(Vec3(0, 0.2, 0.8))
+        DecorativeSphere(.055).setBodyId(0).setColor(SimTK::Vec3(0, 0.2, 0.8))
         .setIndexOnBody(-1).setScale(1).setOpacity(0.5)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(Vec3({ .01, -.3, .01 })));
+        .setTransform(SimTK::Vec3({ .01, -.3, .01 })));
     stdPrimitives.push_back(
-        DecorativeEllipsoid(Vec3(.1, .05, .15)).setBodyId(0).setColor(Vec3(0, 0.2, 0.8))
+        DecorativeEllipsoid(SimTK::Vec3(.1, .05, .15)).setBodyId(0).setColor(SimTK::Vec3(0, 0.2, 0.8))
         .setIndexOnBody(-1).setScale(1).setOpacity(0.5)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(Vec3({ -.01, -.5, .0 })));
+        .setTransform(SimTK::Vec3({ -.01, -.5, .0 })));
     stdPrimitives.push_back(
-        DecorativeTorus(.08, .035).setBodyId(1).setColor(Vec3(0, 0.2, 0.8))
+        DecorativeTorus(.08, .035).setBodyId(1).setColor(SimTK::Vec3(0, 0.2, 0.8))
         .setIndexOnBody(-1).setScale(1).setOpacity(0.5)
         .setRepresentation(SimTK::DecorativeGeometry::DrawSurface)
-        .setTransform(Vec3({ -.02, -.6, .01 })));
+        .setTransform(SimTK::Vec3({ -.02, -.6, .01 })));
 
 
-}
+}
\ No newline at end of file
